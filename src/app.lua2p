--[[============================================================
--=
--=  App
--=
--=-------------------------------------------------------------
--=
--=  LuaWebGen - static website generator in Lua!
--=  - Written by Marcus 'ReFreezed' Thunstr√∂m
--=  - MIT License (See LICENSE.txt)
--=
--============================================================]]

printf!("==== LuaWebGen v"..getReleaseVersion().." ====")



-- readyToExit = setup( )
local function setup()

	-- Parse arguments.
	--==============================================================

	local i = 1

	local command = programArguments[i]
	i             = i + 1

	if not command then
		print("Usage:")
		print("  cd path/to/siteroot")
		print("  webgen.exe command [options]")
		print("or")
		print("  cd path/to/siteroot")
		print("  lua webgen.lua command [options]")
		print()
		return true
	end

	----------------------------------------------------------------

	if command == "new" then
		local kind = programArguments[i] or errorNoPos("[Arguments] Missing kind after 'new'.")
		i          = i + 1

		----------------
		if kind == "site" then
			local pathToSite = programArguments[i] or errorNoPos("[Arguments] Missing path after 'site'.")
			i = i+1

			if programArguments[i] then
				errorNoPos("[Arguments] Unknown argument '%s'.", programArguments[i])
			end

			-- Create folders.
			for _, path in ipairs{
				pathToSite,
				pathToSite.."/"..DIR_CONTENT,
				pathToSite.."/"..DIR_DATA,
				pathToSite.."/"..DIR_LAYOUTS,
				pathToSite.."/"..DIR_LOGS,
				pathToSite.."/"..DIR_OUTPUT,
				pathToSite.."/"..DIR_SCRIPTS,
			} do
				if not isDirectory(path) then
					local ok, err = lfs.mkdir(path)
					if not ok then  errorNoPos(err)  end
				end
			end

			-- Create config.
			local path = pathToSite.."/config.lua"

			if not isFile(path) then
				local title = getFilename(pathToSite)

				local contents = formatTemplate(
					[=[
						return {
							title         = :title:,
							baseUrl       = "http://:host:/",
							languageCode  = "en",

							ignoreFiles   = {"%.lnk$","%.tmp$","^Thumbs%.db$"},
							ignoreFolders = {"^%."},
						}
					]=], {
						title = F("%q", title),
						host  = title:find"^%w[-.%w]*%.%a+$" and title:lower() or "example.com",
					}
				)

				local file, err = io.open(path, "wb")
				if not file then  errorNoPos(err)  end

				file:write(contents)
				file:close()
			end

			-- Create default page layout.
			local path = F("%s/%s/page.html", pathToSite, DIR_LAYOUTS)

			if not isFile(path) then
				local title = getFilename(pathToSite)

				local contents = !(unindent[=[
					<!DOCTYPE html>
					<html lang="{{ site.languageCode }}">
						<head>
							<meta charset="utf-8">
							<meta name="viewport" content="width=device-width, initial-scale=1">
							{{ generatorMeta() }}

							<title>
								{{ echo(page.title ~= "" and page.title.." - " or "") *}}
								{{ echo(site.title) }}
							</title>

							<link rel="canonical" href="{{ url(page.permalink) }}">
						</head>

						<body>
							{{ page.content }}
						</body>
					</html>
				]=])

				local file, err = io.open(path, "wb")
				if not file then  errorNoPos(err)  end

				file:write(contents)
				file:close()
			end

			printf("Created site: %s", pathToSite)

		----------------
		elseif kind == "page" then
			local pathRel = programArguments[i] or errorNoPos("[Arguments] Missing path after 'page'.")
			pathRel       = pathRel:gsub("^/", "")
			i             = i + 1

			if programArguments[i] then
				errorNoPos("[Arguments] Unknown argument '%s'.", programArguments[i])
			end

			local filename = getFilename(pathRel)
			local basename = getBasename(filename)
			local title    = basename :gsub("%-+", " ") :gsub("^%a", string.upper) :gsub(" %a", string.upper)

			local contents = formatTemplate(
				[=[
					{{
					page.title = :titleQuoted:
					page.date  = ":date:"
					}}

					:content:
				]=], {
					titleQuoted = F("%q", title),
					content     = "",
					date        = getDatetime(),
				}
			)

			local path = DIR_CONTENT.."/"..pathRel
			if lfs.attributes(path, "mode") then
				errorNoPos("File or directory already exists: %s", path)
			end

			createDirectory(getDirectory(path))

			local file, err = io.open(path, "wb")
			if not file then  errorNoPos(err)  end

			file:write(contents)
			file:close()

			printf("Created page: %s", path)

		----------------
		elseif kind == "feed" then
			local pathRel = "feed.xml"

			if programArguments[i] then
				pathRel = programArguments[i]:gsub("^/", "")
				i       = i + 1

				if programArguments[i] then
					errorNoPos("[Arguments] Unknown argument '%s'.", programArguments[i])
				end

				if not pathRel:find(".", 1, true) then
					pathRel = pathRel .. ".xml"
				end
			end

			local contents = !(unindent[=[
				<?xml version="1.0" encoding="UTF-8"?>
				<rss version="2.0">
					<channel>
						<title>{{ echo(site.title) }}</title>
						<link>{{ url(site.baseUrl) }}</link>
						<atom:link href="{{ url(page.permalink) }}" rel="self" type="application/rss+xml"/>
						<description>{{ echo(site.description) }}</description>
						<language>{{ site.languageCode }}</language>
						<lastBuildDate>{{ os.date"%Y-%m-%d" }}</lastBuildDate>

						{{ fori subpage in clampArray(subpages(), 15) }}
							{{ if not subpage.isIndex }}
							<item>
								<title>{{ echo(subpage.title) }}</title>
								<description><![CDATA[{{ subpage.description ~= "" and subpage.description or summarize(subpage.content, 400, true) }}]]></description>
								<pubDate>{{ os.date("!%a, %d %b %Y %H:%M:%S GMT", toTime(subpage.publishDate)) }}</pubDate>
								<link>{{ url(subpage.permalink) }}</link>
								<guid>{{ url(subpage.permalink) }}</guid>
							</item>
							{{ end }}
						{{ end }}
					</channel>
				</rss>
			]=])

			local path = DIR_CONTENT.."/"..pathRel
			if lfs.attributes(path, "mode") then
				errorNoPos("File or directory already exists: %s", path)
			end

			createDirectory(getDirectory(path))

			local file, err = io.open(path, "wb")
			if not file then  errorNoPos(err)  end

			file:write(contents)
			file:close()

			printf("Created feed: %s", path)

		----------------
		elseif kind == "sitemap" then
			if programArguments[i] then
				errorNoPos("[Arguments] Unknown argument '%s'.", programArguments[i])
			end

			local contents = !(unindent[=[
				<?xml version="1.0" encoding="UTF-8"?>
				<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
					{{ fori subpage in subpages() }}
					<url>
						<loc>{{ url(subpage.permalink) }}</loc>
						<lastmod>{{ os.date("%Y-%m-%d", toTime(subpage.dateModified)) }}</lastmod>
						<changefreq>daily</changefreq>
						<priority>0.5</priority>
					</url>
					{{ end }}
				</urlset>
			]=])

			local path = DIR_CONTENT.."/sitemap.xml"
			if lfs.attributes(path, "mode") then
				errorNoPos("File or directory already exists: %s", path)
			end

			createDirectory(getDirectory(path))

			local file, err = io.open(path, "wb")
			if not file then  errorNoPos(err)  end

			file:write(contents)
			file:close()

			printf("Created sitemap: %s", path)

		----------------
		else
			errorNoPos("[Arguments] Unknown kind '%s' after 'new'.", kind)
		end

		return true

	----------------------------------------------------------------

	elseif command == "build" then
		local SHORT_TO_LONG_FORM = {
			["-a"] = "--autobuild",
			["-d"] = "--drafts",
			["-f"] = "--force",
			["-v"] = "--verbose",
		}

		local options = {}

		while programArguments[i] do
			local argRaw = programArguments[i]
			local arg    = SHORT_TO_LONG_FORM[argRaw] or argRaw

			if arg == "--force" then
				_G.ignoreModificationTimes = true

			elseif arg == "--autobuild" then
				_G.autobuild = true

			elseif arg == "--date" then
				i              = i + 1
				local datetime = programArguments[i] or errorNoPos("[Arguments] Missing datetime value after '%s'.", argRaw)
				_G.nowTime     = datetimeToTime(datetime)
				arg            = arg .. os.date("! '%Y-%m-%d %H:%M:%S UTC'", nowTime)

			elseif arg == "--drafts" then
				_G.includeDrafts = true

			elseif arg == "--verbose" then
				_G.verbosePrint = true

			elseif arg == "--meta" then
				_G.outputMetaprograms = true

			elseif arg == "--nogc" then
				_G.enableGc = false
				collectgarbage("stop")

			elseif arg == "--fullpaths" then
				_G.useFullPaths = true

			elseif arg == "--baseurloverride" then
				i                  = i + 1
				_G.baseUrlOverride = programArguments[i] or errorNoPos("[Arguments] Missing URL after '%s'.", argRaw)
				arg                = arg .. '"' .. baseUrlOverride .. '"'

			elseif arg:find"^%-" then
				errorNoPos("[Arguments] Unknown option '%s'.", argRaw)
			else
				errorNoPos("[Arguments] Unknown argument '%s'.", argRaw)
			end

			table.insert(options, arg)
			i = i+1
		end

		if not (isDirectory(DIR_CONTENT) or isDirectory(DIR_LAYOUTS) or isFile"config.lua") then
			errorNoPos("The current folder doesn't seem to contain a site.")
		end

		print(os.date"%Y-%m-%d")

		if options[1] then
			printf("Options: %s", table.concat(options, ", "))
		end
		printf("SiteFolder: %s", getCwd())

		-- Continue...

	----------------------------------------------------------------
	else
		errorNoPos("[Arguments] Unknown command '%s'.", command)
	end



	-- Prepare log file.
	--==============================================================

	do
		if not isDirectory(DIR_LOGS) then
			local ok, err = lfs.mkdir(DIR_LOGS)
			if not ok then  errorNoPos(err)  end
		end

		local basePath = DIR_LOGS .. os.date"/%Y-%m-%d_%H-%M-%S"
		local i        = 1
		_G.logPath     = basePath .. ".log"

		while isFile(logPath) do
			i          = i + 1
			_G.logPath = basePath .. "_" .. i .. ".log"
		end

		_G.logFile = io.open(logPath, "w") -- We don't sweat it if this fails.
	end



	-- Prepare script environment.
	--==============================================================

	_G.scriptEnvironmentGlobals = {
		_WEBGEN_VERSION      = WEBGEN_VERSION, -- @Deprecated
		DATA_FILE_EXTENSIONS = {unpack(DATA_FILE_EXTENSIONS)},
		IMAGE_EXTENSIONS     = {unpack(IMAGE_EXTENSIONS)},
		WEBGEN_VERSION       = WEBGEN_VERSION,

		-- Lua globals.
		_G             = nil, -- Deny direct access to the script environment.
		_VERSION       = _VERSION,
		assert         = assert,
		collectgarbage = collectgarbage,
		dofile         = dofile,
		error          = error,
		getfenv        = getfenv,
		getmetatable   = getmetatable,
		ipairs         = ipairs,
		load           = load,
		loadfile       = loadfile,
		loadstring     = loadstring,
		module         = module,
		pcall          = pcall,
		print          = print,
		rawequal       = rawequal,
		rawget         = rawget,
		rawset         = rawset,
		require        = require,
		select         = select,
		setfenv        = setfenv,
		setmetatable   = setmetatable,
		tonumber       = tonumber,
		tostring       = tostringForTemplates,
		type           = type,
		unpack         = unpack,
		xpcall         = xpcall,

		next = function(t)
			if     isDataFolderReader(t)   then  preloadData(t)
			elseif isScriptFolderReader(t) then  preloadScripts(t)  end

			return next(t)
		end,

		pairs = function(t)
			if isDataFolderReader(t)   then  return pairsSorted(preloadData(t)),    t, nil  end
			if isScriptFolderReader(t) then  return pairsSorted(preloadScripts(t)), t, nil  end
			return next, t, nil
		end,

		-- Lua modules.
		coroutine = coroutine,
		debug     = debug,
		io        = io,
		math      = math,
		os        = os,
		package   = package,
		string    = string,
		table     = table,

		-- Lua libraries.
		json = jsonLib,
		lfs  = lfs,
		utf8 = utf8,
		xml  = xmlLib,

		toml = { -- @Cleanup: Don't use 3rd party TOML library.
			parse = dataParsers.toml,
		},

		-- Site objects. (Create at site generation.)
		site = nil,
		data = nil,

		-- Page objects. (Create for each individual page. Store in context.)
		page   = nil,
		params = nil,
		P      = nil,

		-- Utility functions.
		----------------------------------------------------------------

		ceil             = math.ceil,
		date             = os.date,
		entities         = encodeHtmlEntities,
		errorf           = errorf,
		F                = F,
		find             = itemWith,
		findAll          = itemWithAll,
		floor            = math.floor,
		formatTemplate   = formatTemplate,
		generatorMeta    = getGeneratorHtmlMetaTag,
		getFilename      = getFilename,
		getKeys          = getKeys,
		gmatchAndBetween = gmatchAndBetween,
		indexOf          = indexOf,
		ipairsr          = ipairsr,
		isAny            = isAny,
		isValueHtml      = doesValueLookLikeHtml,
		markdown         = markdownToHtml,
		max              = math.max,
		min              = math.min,
		newStringBuilder = newStringBuilder, newBuffer = newStringBuilder, -- newBuffer() is @Deprecated, I guess? 2021-05-15
		percent          = percentEncode,
		prettyUrl        = urlToPrettyText,
		printf           = printf,
		printfOnce       = printfOnce,
		printObject      = printObject,
		printOnce        = printOnce,
		removeItem       = removeItem,
		round            = round,
		sortNatural      = sortNatural,
		split            = splitString,
		toLua            = serializeLua,
		toTime           = datetimeToTime,
		trim             = trim,
		trimNewlines     = trimNewlines,
		url              = fixRelativeUrlAndEncode,
		urlAbs           = toAbsoluteAndEncodedUrl,
		urlExists        = urlExists,
		urlRaw           = partialEncodeUrl,
		urlize           = urlize,

		chooseExistingFile = function(sitePathWithoutExt, exts)
			local pathWithoutExt = sitePathToPath(sitePathWithoutExt, 2)

			for _, ext in ipairs(exts) do
				local pathRel = pathWithoutExt.."."..ext
				if isFile(DIR_CONTENT.."/"..pathRel) then  return (pathToSitePath(pathRel))  end
			end

			return nil
		end,

		chooseExistingImage = function(sitePathWithoutExt)
			return (scriptEnvironmentGlobals.chooseExistingFile(sitePathWithoutExt, IMAGE_EXTENSIONS))
		end,

		fileExists = function(sitePath)
			local pathRel = sitePathToPath(sitePath, 2)
			return (isFile(DIR_CONTENT.."/"..pathRel))
		end,

		fileExistsInOutput = function(sitePath, skipRewriting)
			local pathRel       = sitePathToPath(sitePath, 2)
			local pathOutputRel = skipRewriting and pathRel or rewriteOutputPath(pathRel)
			return (isFile(DIR_OUTPUT.."/"..pathOutputRel))
		end,

		getExtension = function(genericPath)
			local getExtension_internal = getExtension -- :BetterTraceback :BetterNameForRedirectedFunctionInErrorMessage
			return (getExtension_internal(getFilename(genericPath)))
		end,

		getBasename = function(genericPath)
			local getBasename_internal = getBasename -- :BetterTraceback :BetterNameForRedirectedFunctionInErrorMessage
			return (getBasename_internal(getFilename(genericPath)))
		end,

		X = function(node, tagName) -- @Cleanup: Remove this!
			if type(node) ~= "table" then  error("Invalid XML argument.", 2)  end
			return (itemWith(node, "tag", tagName))
		end,

		Xs = function(node, tagName) -- @Cleanup: Remove this!
			if type(node) ~= "table" then  error("Invalid XML argument.", 2)  end
			return (itemWithAll(node, "tag", tagName))
		end,

		forXml = function(node, tagName) -- @Cleanup: Remove this!
			if type(node) ~= "table" then  error("Invalid XML argument.", 2)  end
			return ipairs(itemWithAll(node, "tag", tagName))
		end,

		printXmlTree = function(node) -- @Cleanup: Remove this!
			if type(node) ~= "table" then  error("Invalid XML argument.", 2)  end

			local function printNode(node, indent)
				print(("    "):rep(indent)..node.tag)

				indent = indent+1
				for _, childNode in ipairs(node) do
					if type(childNode) == "table" then
						printNode(childNode, indent)
					end
				end
			end

			if xmlLib.isElement(node) then
				printNode(node, 0)
			else
				print("(xml array)")
				for _, childNode in ipairs(node) do
					printNode(childNode, 1)
				end
			end
		end,

		-- xmlGetTexts = function(node, tags)
		-- 	local texts = {}
		-- 	for i, tagName in ipairs(tags) do
		-- 		texts[tagName] = itemWith(node, "tag", tagName):get_text()
		-- 	end
		-- 	return texts
		-- end

		-- xmlGetTexts = function(node, ...) -- Messy to call!
		-- 	local function getText(tagName, ...)
		-- 		if select("#", ...) > 0 then
		-- 			return itemWith("tag", tagName):get_text(), getText(...)
		-- 		end
		-- 	end
		-- 	return getText(...)
		-- end

		-- xmlGetTexts = function(node) -- Different than above.
		-- 	local texts = {}
		-- 	for i, childNode in ipairs(node) do
		-- 		texts[i] = childNode:get_text()
		-- 	end
		-- 	return texts
		-- end

		-- html, thumbUrl, thumbWidth, thumbHeight = thumb( imagePath, thumbWidth [, thumbHeight ] [, isLink=false ] )
		thumb = function(sitePathImageRel, thumbW, thumbH, isLink)
			if type(thumbH) == "boolean" then
				thumbH, isLink = 0, thumbH
			end

			local pathImageRel = sitePathToPath(sitePathImageRel, 2)
			local thumbInfo    = createThumbnail(pathImageRel, thumbW, thumbH, 2)
			local thumbUrl     = fixRelativeUrlAndEncode("/"..thumbInfo.path)

			local b = newStringBuilder()
			if isLink then  b('<a href="%s" target="_blank">', fixRelativeUrlAndEncode("/"..pathImageRel))  end
			b('<img src="%s" width="%d" height="%d" alt="">', encodeHtmlEntities(thumbUrl), thumbInfo.width, thumbInfo.height)
			if isLink then  b('</a>')  end

			return b(), thumbUrl, thumbInfo.width, thumbInfo.height
		end,

		cssPrefix = function(prop, v)
			return F("-ms-%s: %s; -moz-%s: %s; -webkit-%s: %s; %s: %s;", prop, v, prop, v, prop, v, prop, v)
		end,

		warning = function(s)
			s = F("!!! WARNING: %s !!!", s)

			local border = ("!"):rep(#s)
			print()
			print(border)
			print(s)
			print(border)
			print()
		end,

		warningOnce = function(s)
			s = F("!!! WARNING: %s !!!", s)

			if oncePrints[s] then  return  end
			oncePrints[s] = true

			local border = ("!"):rep(#s)
			print()
			print(border)
			print(s)
			print(border)
			print()
		end,

		-- html = a( url [, label=prettyUrl ] )
		a = function(url, label)
			return F(
				'<a href="%s">%s</a>',
				encodeHtmlEntities(fixRelativeUrlAndEncode(url)),
				encodeHtmlEntities(label or urlToPrettyText(url))
			)
		end,

		-- html = img( url [, alt="", title ] )
		-- html = img( url [, alt="", useAltAsTitle ] )
		img = function(url, alt, title)
			-- @Incomplete: Do we want to add 'width' and 'height' attributes here if the URL looks like a local image path?
			-- Maybe we want a separate function for that, like imgLocal()? Not sure...
			if title then
				return F(
					'<img src="%s" alt="%s" title="%s">',
					encodeHtmlEntities(fixRelativeUrlAndEncode(url)),
					encodeHtmlEntities(alt or ""),
					encodeHtmlEntities(title == true and alt or title)
				)
			else
				return F(
					'<img src="%s" alt="%s">',
					encodeHtmlEntities(fixRelativeUrlAndEncode(url)),
					encodeHtmlEntities(alt or "")
				)
			end
		end,

		-- filePaths = files( folder, [ onlyFilenames=false, ] stringPattern )
		-- filePaths = files( folder, [ onlyFilenames=false, ] fileExtensionArray )
		-- filePaths = files( folder, [ onlyFilenames=false, ] filterFunction )
		files = function(sitePath, onlyFilenames, filter)
			if type(onlyFilenames) ~= "boolean" then
				onlyFilenames, filter = false, onlyFilenames
			end

			local pathRel = sitePathToPath(sitePath, 2)
			local dirPath = pathRel == "" and DIR_CONTENT or DIR_CONTENT.."/"..pathRel
			local sitePaths = {}

			for name in lfs.dir(dirPath) do
				if name ~= "." and name ~= ".." and isFile(dirPath.."/"..name) then
					if filter == nil then
						table.insert(sitePaths, (onlyFilenames and name or sitePath.."/"..name))

					elseif type(filter) == "string" then
						if name:find(filter) then
							table.insert(sitePaths, (onlyFilenames and name or sitePath.."/"..name))
						end

					elseif type(filter) == "table" then
						if indexOf(filter, getExtension(name)) then
							table.insert(sitePaths, (onlyFilenames and name or sitePath.."/"..name))
						end

					elseif type(filter) == "function" then
						if filter(name) then
							table.insert(sitePaths, (onlyFilenames and name or sitePath.."/"..name))
						end

					else
						errorf(2, "Invalid filter type '%s'. (Must be string, table or function)", type(filter))
					end
				end
			end

			return sitePaths
		end,

		toDatetime = function(time)
			!ARGS "time:number"
			return getDatetime(time)
		end,

		now = function()
			return getDatetime()
		end,

		getCompleteOutputPath = function(sitePath)
			local pathRel       = sitePathToPath(sitePath, 2)
			local pathOutputRel = rewriteOutputPath(pathRel)
			return DIR_OUTPUT.."/"..pathOutputRel
		end,

		pairsSorted = function(t)
			if     isDataFolderReader(t)   then  preloadData(t)
			elseif isScriptFolderReader(t) then  preloadScripts(t)  end

			local pairsSorted_internal = pairsSorted -- :BetterTraceback :BetterNameForRedirectedFunctionInErrorMessage
			return (pairsSorted_internal(t))
		end,

		validateUrls = function(urls)
			-- @Robustness: Should we restrict context here? (I think not. 2021-05-01)
			local ok = true

			for _, url in ipairs(urls) do
				if not urlExists(url) then
					timestampPrintError("URL is missing: %s", url)
					ok = false
				end
			end

			if not ok then
				error("URLs were missing.", 2)
			end
		end,

		getImageDimensions = function(sitePath)
			local getImageDimensions_internal = getImageDimensions -- :BetterTraceback :BetterNameForRedirectedFunctionInErrorMessage
			local wOrNil, hOrErr              = getImageDimensions_internal(sitePathToPath(sitePath, 2), false)
			return wOrNil, hOrErr
		end,
		XXX_getImageDimensionsFast = function(sitePath)
			local wOrNil, hOrErr = getImageDimensions(sitePathToPath(sitePath, 2), true)
			return wOrNil, hOrErr
		end,

		getOutputtedFiles = function()
			-- There's no reason to restrict context for this function, I don't think. 2021-04-27
			local fileInfos = {}

			for i, entry in ipairs(site._writtenOutputEntries) do
				table.insert(fileInfos, {
					sourcePath = entry.path ~= "" and pathToSitePath(entry.path) or "",
					path       = pathToSitePath(entry.pathOut),
					url        = entry.url,
					serial     = i, -- @Doc?
				})
			end

			table.sort(fileInfos, function(a, b)
				return a.url < b.url
			end)

			return fileInfos
		end,

		getGeneratedPages = function()
			-- Just like getOutputtedFiles(), there's no reason to restrict context for this function, I don't think. 2021-05-18
			local generatedPages = {}

			for _, page in ipairs(site._pages) do
				if page._isGenerated then
					table.insert(generatedPages, getProtectionWrapper(page, "page"))
				end
			end

			return generatedPages -- Should we sort these?
		end,

		getDataTextParsers = function()
			local _dataParsers = {}

			for ext, dataParser in pairs(dataParsers) do
				if not dataParserIsBinary[ext] then
					_dataParsers[ext] = dataParser
				end
			end

			return _dataParsers
		end,

		getDataBinaryParsers = function()
			local _dataParsers = {}

			for ext, dataParser in pairs(dataParsers) do
				if dataParserIsBinary[ext] then
					_dataParsers[ext] = dataParser
				end
			end

			return _dataParsers
		end,

		clampArray = function(t, len)
			for i = #t, len+1, -1 do
				t[i] = nil
			end
			return t
		end,

		--
		-- html = summarize( html, maxCharacters [, keepSomeElements=false ] )
		--
		-- Limit the amount of text and restrict allowed tags in an HTML string
		-- to be used e.g. as the description for an item in an RSS feed.
		--
		-- 'html' must be valid HTML code.
		-- 'keepSomeElements' includes elements like <a>, <em>, <code>, <img> and <svg>.
		-- Elements like <br> and <bdo>, and any occurrences of the 'dir' attribute, are always preserved.
		--
		summarize = function(html, maxChars, keepSomeElements)
			local doc = assert(xmlLib.parseHtml("<div>"..html.."</div>"))

			-- Remove (probably) unwanted elements.
			local elementsToRemove = !(Set{
				"dialog",
				"menu", -- (Non-standard.)
				"nav",
				"script",
				"style",
				"template",
			})
			if not keepSomeElements then
				elementsToRemove.math = true
				elementsToRemove.svg  = true
			end

			xmlLib.walk(doc, false, function(tag, el)
				for i, child in ipairsr(el) do
					if xmlLib.isElement(child) and elementsToRemove[child.tag] then
						table.remove(el, i)
					end
				end
			end)

			-- Filter the HTML.
			local function processChildren(buffer, textIndices, el)
				for _, child in ipairs(el) do
					if xmlLib.isText(child) then
						insertMultiple(buffer, (encodeHtmlEntities(child):gsub("%s+", " ")))
						table.insert(textIndices, #buffer)

					-- Elements to always keep.

					elseif isAny(child.tag, "br","wbr") then
						insertMultiple(buffer, "<",child.tag,">")

					elseif isAny(child.tag, "ruby","rt","rp","bdi","bdo") then
						insertMultiple(buffer, "<",child.tag)
						if child.attr.dir then  insertMultiple(buffer, " dir='",encodeHtmlEntities(child.attr.dir),"'")  end
						insertMultiple(buffer, ">")
						processChildren(buffer, textIndices, child)
						insertMultiple(buffer, "</",child.tag,">")

					-- Elements to sometimes keep.

					elseif keepSomeElements and child.tag == "a" and child.attr.href and not child.attr.href:find"^javascript:" then
						insertMultiple(buffer, "<a href='",encodeHtmlEntities(child.attr.href),"'")
						if child.attr.dir then  insertMultiple(buffer, " dir='",encodeHtmlEntities(child.attr.dir),"'")  end
						insertMultiple(buffer, ">")
						processChildren(buffer, textIndices, child)
						insertMultiple(buffer, "</a>")

					elseif keepSomeElements and isAny(child.tag, "em","strong","b","i","code","sub","sup") then
						insertMultiple(buffer, "<",child.tag)
						if child.attr.dir then  insertMultiple(buffer, " dir='",encodeHtmlEntities(child.attr.dir),"'")  end
						insertMultiple(buffer, ">")
						processChildren(buffer, textIndices, child)
						insertMultiple(buffer, "</",child.tag,">")

					elseif keepSomeElements and child.tag == "img" and child.attr.src then
						insertMultiple(buffer, "<img src='",encodeHtmlEntities(child.attr.src),"' alt='",encodeHtmlEntities(child.attr.alt or ""),"'>")
					elseif not keepSomeElements and child.tag == "img" and (child.attr.alt or "") ~= "" then
						insertMultiple(buffer, (encodeHtmlEntities(child.attr.alt):gsub("%s+", " ")))
						table.insert(textIndices, #buffer)

					elseif keepSomeElements and child.tag == "math" or child.tag == "svg" then
						insertMultiple(buffer, child:toHtml()) -- (We could call toXml() instead since these elements will be encoded as XML anyway.)

					-- For anything else we just care about the text contents.

					else
						if child.attr.dir then  insertMultiple(buffer, "<span dir='",encodeHtmlEntities(child.attr.dir),"'>")  end
						processChildren(buffer, textIndices, child)
						if child.attr.dir then  insertMultiple(buffer, "</span")  end
					end
				end
			end

			local function trimText(buffer, textIndices, i1, i2, iDir)
				for i = i1, i2, iDir do
					local textNode = buffer[textIndices[i]]

					if not textNode:find"^%s*$" then
						local pat              = (iDir > 0) and "^%s+" or "%s+$"
						buffer[textIndices[i]] = textNode:gsub(pat, "")
						break
					end

					buffer[textIndices[i]] = ""
				end
			end

			local buffer      = {"<div>"}
			local textIndices = {}

			for _, child in ipairs(doc) do
				-- @Incomplete: Handle tables better?

				if xmlLib.isText(child) then
					-- void

				else
					local textStartIndex = #textIndices + 1

					if child.tag == "ul" or child.tag == "ol" then
						insertMultiple(buffer, "<",child.tag,">")

						for li in child:eachChildElement() do
							insertMultiple(buffer, "<li>")
							processChildren(buffer, textIndices, li)
							insertMultiple(buffer, "</li>")
						end

						insertMultiple(buffer, "</",child.tag,">\n")

					elseif child.tag == "pre" then
						insertMultiple(buffer, "<",child.tag,">")
						processChildren(buffer, textIndices, child)
						insertMultiple(buffer, "</",child.tag,">\n")

					else
						insertMultiple(buffer, "<p>")
						processChildren(buffer, textIndices, child)
						insertMultiple(buffer, "</p>\n")
					end

					trimText(buffer, textIndices, textStartIndex, #textIndices,    1)
					trimText(buffer, textIndices, #textIndices,   textStartIndex, -1)
				end
			end

			table.insert(buffer, "</div>")

			local len   = #buffer
			buffer[len] = buffer[len]:gsub("\n$", "")
			doc         = assert(xmlLib.parseHtml(table.concat(buffer))) -- @Speed: So much back and forth between HTML strings and parsed documents!

			-- Limit text length.
			local charsRemaining = maxChars
			local hasText        = {}

			local function limit(node, parentEl, i)
				if charsRemaining <= 0 then
					parentEl[i] = ""

				elseif xmlLib.isText(node) then
					hasText[parentEl] = true
					local len         = utf8.getLength(node)
					charsRemaining    = charsRemaining - len

					if charsRemaining < 0 then
						!local ELLIPSIS   = "..."
						local nextCharPos = #node + 1

						for i = charsRemaining, !(#ELLIPSIS-1) do
							nextCharPos = utf8.getStartOfCharacter(node, nextCharPos-1)

							if not nextCharPos then
								nextCharPos = 1
								break
							end
						end

						parentEl[i] = node:sub(1, nextCharPos-1) .. !(ELLIPSIS)
					end

				else
					for i, child in ipairs(node) do
						limit(child, node, i)
					end

					if hasText[node] and parentEl then
						hasText[parentEl] = true
					end
				end
			end

			limit(doc, nil, nil)

			-- @Polish: Remove empty elements, like <p></p> (but not <br>).

			return (doc:contentsToHtml())
		end,

		-- Context functions.
		----------------------------------------------------------------

		echo = function(v)
			assertContext("template", "echo")
			local s = tostringForTemplates(v)

			local ctx = getContext"template"
			if ctx.enableHtmlEncoding then
				s = encodeHtmlEntities(s)
			end

			table.insert(ctx.out, s)
		end,

		echoRaw = function(s)
			assertContext("template", "echoRaw")
			table.insert(getContext"template".out, tostringForTemplates(s))
		end,

		echoSmart = function(v)
			assertContext("template", "echoSmart")
			if v == nil then
				-- void  Echo nothing.
			elseif doesValueLookLikeHtml(v) then
				scriptEnvironmentGlobals.echoRaw(v)
			else
				scriptEnvironmentGlobals.echo(v)
			end
		end,

		echof = function(s, ...)
			assertContext("template", "echof")
			!ARGS "s:string"
			scriptEnvironmentGlobals.echo(s:format(...))
		end,

		echofRaw = function(s, ...)
			assertContext("template", "echofRaw")
			!ARGS "s:string"
			scriptEnvironmentGlobals.echoRaw(s:format(...))
		end,

		include = function(htmlFileBasename, ...)
			assertContext("template", "include")
			if htmlFileBasename:find"^/" then
				errorf(2, "Filename is not valid: %s", htmlFileBasename)
			end

			local path = F("%s/%s.html", DIR_LAYOUTS, htmlFileBasename)
			local template, err = getFileContentsText(path)
			if not template then
				errorf(2, "Could not read file '%s': %s", maybeFullPath(path), err)
			end

			local args = (select("#", ...) > 0) and pack(...) or nil

			-- timestampPrintVerbose("--> Processing(start): %s", maybeFullPath(path))
			local html = parseAndRunTemplate(getContext().page, path, template, "html", true, nil, args)
			-- timestampPrintVerbose("--> Processing(finish): %s", maybeFullPath(path))
			return html
		end,

		generateFromTemplate = function(sitePathRel, template, paramsOrInit)
			assertContext("config", "generateFromTemplate")
			!ARGS "sitePathRel,template:string ? paramsOrInit:table,function"

			local pathRel = sitePathToPath(sitePathRel, 2)
			local page    = newPage(pathRel, false)

			if type(paramsOrInit) == "table" then
				page.params.v = paramsOrInit
			end

			local onPageInit = (type(paramsOrInit) == "function") and paramsOrInit or nil
			generateFromTemplateString(page, template, nil, onPageInit)

			if page.isPage.v and not page._isSkipped then
				table.insert(site._pages, page)
			end

			return (getProtectionWrapper(page, "page"))
		end,

		outputRaw = function(sitePathRel, contents)
			assertContext("config", "outputRaw")
			!ARGS "sitePathRel,contents:string"

			local pathRel = sitePathToPath(sitePathRel, 2)
			writeOutputFile("raw", pathRel, sitePathRel, contents, nil, "")
		end,

		preserveRaw = function(sitePathRel)
			assertContext("config", "preserveRaw")

			local pathRel       = sitePathToPath(sitePathRel, 2)
			local pathOutputRel = rewriteOutputPath(pathRel)
			local path          = DIR_OUTPUT.."/"..pathOutputRel

			if not isFile(path) then
				errorf(2, "File does not exist. (%s)", maybeFullPath(path))
			end

			preserveExistingOutputFile("raw", pathRel, sitePathRel, "")
		end,

		isCurrentUrl = function(url)
			assertContext("template", "isCurrentUrl")
			return getContext().page.url.v == url
		end,

		isCurrentUrlBelow = function(urlPrefix)
			assertContext("template", "isCurrentUrlBelow")
			return getContext().page.url.v:find(urlPrefix, 1, true) == 1
		end,

		subpages = function(pathPrefixOrAllowCurrentPage)
			local subpages = {}
			local pageCurrent, pathPrefix, allowCurrentPage

			if type(pathPrefixOrAllowCurrentPage) == "string" then
				pageCurrent      = nil
				pathPrefix       = sitePathToPath(pathPrefixOrAllowCurrentPage, 2)
				allowCurrentPage = false -- Doesn't matter.
			else
				assertContext("template", "subpages")
				pageCurrent      = getContext().page
				pathPrefix       = pageCurrent._path:gsub("[^/]+$", "")
				allowCurrentPage = pathPrefixOrAllowCurrentPage
			end

			generateNonPages() -- Make sure as many non-pages as possible finish generating before any actual page begins.

			for _, page in ipairs(site._pages) do
				if (page ~= pageCurrent or allowCurrentPage) and (
					pathPrefix == ""
					or page._path:find(pathPrefix, 1, true) == 1
				) then
					if not page._isGenerated then
						generateFromTemplateFile(page)
					end
					if not (page._isSkipped or page.isSpecial.v) then
						table.insert(subpages, page)
					end
				end
			end

			table.sort(subpages, function(a, b)
				local aDatetime = a.publishDate:g()
				local bDatetime = b.publishDate:g()
				if aDatetime ~= bDatetime then  return aDatetime > bDatetime  end

				return a._path < b._path
			end)

			for i, page in ipairs(subpages) do
				subpages[i] = getProtectionWrapper(page, "page")
			end

			return subpages
		end,

		lock = function()
			assertContext("template", "lock")

			local page     = getContext().page
			page._isLocked = true -- Note: It's OK for this function to be called multiple times.
			page._readonly = true
		end,

		-- Hacks. (These are not very robust!)
		----------------------------------------------------------------

		XXX_minimizeCss = function(s, sourcePath)
			local oldLen = #s
			local header = s:match"^/%*.-%*/" or ""

			s = (header..s
				:sub(#header+1)
				:gsub("/%*.-%*/", "")   -- Remove comments.
				:gsub("\t+",      "")   -- Remove all tabs.
				:gsub("\n +",     "\n") -- Remove space indentations.
				:gsub("  +",      " ")  -- Remove extra spaces.
				:gsub("\n\n+",    "\n") -- Remove empty lines.
				:gsub("%b{}",     function(scope)  return (scope:gsub("\n", " "))  end) -- Compress rules to one line each.
			)

			!if DEV then
				if verbosePrint then  printf("[opti] %s  from %d  to %d  (diff=%d)", getFilename(sourcePath or "<css>"), oldLen, #s, oldLen-#s)  end
			!end

			return s
		end,

		XXX_minimizeJavaScript = function(s, sourcePath)
			local oldLen = #s
			local header = s:match"^/%*.-%*/" or ""

			s = (header..s
				:sub(#header+1)
				:gsub("()/%*.-%*/", "")   -- Remove long comments.
				:gsub("\n\t+",      "\n") -- Remove indentations.
				:gsub("\n//[^\n]*", "\n") :gsub(" // [^\n]*", "") -- Remove all comment lines.
				:gsub("\n\n+",      "\n") -- Remove empty lines.
			)

			!if DEV then
				if verbosePrint then  printf("[opti] %s  from %d  to %d  (diff=%d)", getFilename(sourcePath or "<css>"), oldLen, #s, oldLen-#s)  end
			!end

			return s
		end,

		XXX_minimizeHtaccess = function(s, sourcePath)
			local oldLen = #s

			s = (s
				:gsub("\n\t+",     "\n") -- Remove indentations.
				:gsub("\n#[^\n]*", "\n") :gsub("^#[^\n]*", "") -- Remove all comments.
				:gsub("\n\n+",     "\n") :gsub("^\n",      "") -- Remove empty lines.
			)

			!if DEV then
				if verbosePrint then  printf("[opti] %s  from %d  to %d  (diff=%d)", getFilename(sourcePath or "<css>"), oldLen, #s, oldLen-#s)  end
			!end

			return s
		end,

		XXX_getMinimizingProcessors = function()
			return {
				["css"]      = scriptEnvironmentGlobals.XXX_minimizeCss,
				["htaccess"] = scriptEnvironmentGlobals.XXX_minimizeHtaccess,
				["js"]       = scriptEnvironmentGlobals.XXX_minimizeJavaScript,
			}
		end

		----------------------------------------------------------------
	}

	-- These functions are used by metaprograms.
	scriptEnvironmentGlobals.echo__        = scriptEnvironmentGlobals.echo
	scriptEnvironmentGlobals.echoRaw__     = scriptEnvironmentGlobals.echoRaw
	scriptEnvironmentGlobals.echoSmart__   = scriptEnvironmentGlobals.echoSmart
	scriptEnvironmentGlobals.fori__        = ipairs
	scriptEnvironmentGlobals.foriReverse__ = ipairsr
	scriptEnvironmentGlobals.lock__        = scriptEnvironmentGlobals.lock
	scriptEnvironmentGlobals.url__         = fixRelativeUrlAndEncode



	_G.scriptEnvironment = setmetatable({}, {
		__index = function(env, k)
			local v = scriptEnvironmentGlobals[k]
			if v ~= nil then  return v  end

			v = getContext()._scriptEnvironmentGlobals[k]
			if v ~= nil then  return v  end

			v = rawget(site._scripts, k)
			if v then  return v  end

			local scriptPath = F("%s/%s", DIR_SCRIPTS, k)
			if isFile(scriptPath..".lua") or isDirectory(scriptPath) then
				return site._scripts[k] -- Should succeed (unless there's a parsing error or something, of course).
			end

			errorf(2, "Tried to get non-existent global or script '%s'.", tostring(k))
		end,

		__newindex = function(env, k, v)
			errorf(2, "Tried to set global '%s'. (Globals are disabled.)", tostring(k))
		end,
	})

	return false
end



local function xpcallErrorHandler(err)
	local alsoPrintTraceback = (err:find("\n>-", 1, true) == nil) -- We don't need to show the traceback if it's a parsing error with a preview thing.

	timestampPrintError(tostring(err))
	logErrorTraceback(2, alsoPrintTraceback)
end

local appOk, done = xpcall(setup, xpcallErrorHandler)

if not appOk then  return false  end
if done      then  return true   end



-- Build website!
--==============================================================

local function buildWebsite()
	local startTime = getTimeBetter()

	_G.site         = newSite()
	_G.oncePrints   = {}
	_G.warningCount = 0

	scriptEnvironmentGlobals.site    = getProtectionWrapper(site, "site")
	scriptEnvironmentGlobals.data    = newDataFolderReader(DIR_DATA, true)
	scriptEnvironmentGlobals.scripts = site._scripts



	-- Read config.
	----------------------------------------------------------------

	local function lineAssertType(v, vType, s, ...)
		if type(v) == vType then  return v  end
		errorNoPos(s, ...)
	end

	local function lineAssertTable(t, kType, vType, s, ...)
		lineAssertType(t, "table", s, ...)
		for k, v in pairs(t) do
			if kType then  lineAssertType(k, kType, s, ...)  end
			if vType then  lineAssertType(v, vType, s, ...)  end
		end
		return t
	end

	if not isFile"config.lua" then
		errorNoPos("Missing %s in site folder.", maybeFullPath"config.lua")
	end

	local main_chunk, err = loadLuaFile("config.lua", scriptEnvironment)
	if not main_chunk then  errorNoPos(err)  end

	timestampPrintVerbose("--> config(start)")
	local config = main_chunk()
	lineAssertTable(config, nil, nil, "%s: The file must return a table.", maybeFullPath"config.lua")
	timestampPrintVerbose("--> config(finish)")

	local function get(kPath, default, assertFunc, ...)
		local v     = config
		local tLast = nil
		local kLast = nil

		for k in kPath:gmatch"[^.]+" do
			if type(v) ~= "table" then  return default  end

			kLast = k
			tLast = v
			v     = v[k]

			if v == nil then  return default  end
		end

		assertFunc(v, ...)

		tLast[kLast] = nil -- Helps us find extra/unknown fields later.
		return v
	end

	local function getV(kPath, default, vType) -- Value.
		return get(
			kPath, default, lineAssertType, vType,
			"%s: config.%s must be a %s.",
			maybeFullPath"config.lua", kPath, vType
		)
	end
	local function getT(kPath, default, kType, vType) -- Table
		return get(
			kPath, default, lineAssertTable, kType, vType,
			"%s: config.%s must be a table of [%s]=%s.",
			maybeFullPath"config.lua", kPath, (kType or "value"), (vType or "value")
		)
	end
	local function getA(kPath, default, vType) -- Array.
		return get(
			kPath, default, lineAssertTable, "number", vType,
			"%s: config.%s must be an array of %s.",
			maybeFullPath"config.lua", kPath, vType
		)
	end

	site.title.v                  = getV("title",             site.title.v,          "string")
	site.description.v            = getV("description",       site.description.v,    "string")
	site.baseUrl.v                = getV("baseUrl",           site.baseUrl.v,        "string")
	site.languageCode.v           = getV("languageCode",      site.languageCode.v,   "string")
	site.defaultLayout.v          = getV("defaultLayout",     site.defaultLayout.v,  "string")

	site.redirections.v           = getT("redirections",      site.redirections.v,   "string", "string")

	site._ignoreFiles             = getA("ignoreFiles",       site._ignoreFiles,     "string")
	site._ignoreFolders           = getA("ignoreFolders",     site._ignoreFolders,   "string")
	site._ignorePaths             = getA("ignorePaths",       site._ignorePaths,     "string")

	site._fileTypes               = getT("types",             site._fileTypes,       "string", "string")
	site._fileProcessors          = getT("processors",        site._fileProcessors,  "string", "function")
	local customDataTextParsers   = getT("dataTextParsers",   {},                    "string", "function")
	local customDataBinaryParsers = getT("dataBinaryParsers", {},                    "string", "function")

	local htaRedirect             = getV("htaccess.redirect", false,                 "boolean")
	local htaWww                  = getV("htaccess.www",      false,                 "boolean")
	site._htaErrors               = getT("htaccess.errors",   site._htaErrors,       "number", "string")
	local htaNoIndexes            = getV("htaccess.noIndexes",false,                 "boolean")
	local htaPrettyUrlDir         = getV("htaccess.XXX_prettyUrlDirectory", "",      "string")
	local htaDenyAccess           = getA("htaccess.XXX_denyDirectAccess",   {},      "string")
	local htaccess                = getT("htaccess",          nil,                   "string")
	local handleHtaccess          = htaccess ~= nil

	site._outputPathFormat        = get("rewriteOutputPath", "%s", NOOP)
	site._rewriteExcludes         = getA("rewriteExcludes",   site._rewriteExcludes, "string")

	local onBefore                = getV("before",            nil,                   "function")
	local onAfter                 = getV("after",             nil,                   "function")
	local onValidate              = getV("validate",          nil,                   "function")

	site._autoLockPages           = getV("autoLockPages",     site._autoLockPages,   "boolean")
	site._noTrailingSlash         = getV("removeTrailingSlashFromPermalinks", site._noTrailingSlash, "boolean") -- @Doc? @Hack? Also, this affects page.url too now. 2021-04-28

	site._redirectionLayout       = getV("redirectionLayout", site._redirectionLayout, "string")

	for k in pairs(config) do
		timestampPrintWarning("%s: Unknown config field '%s'.", maybeFullPath"config.lua", k)
	end
	for k in pairs(htaccess or {}) do
		timestampPrintWarning("%s: Unknown config.htaccess field '%s'.", maybeFullPath"config.lua", k)
	end

	if not isAny(type(site._outputPathFormat), "string","function") then
		errorNoPos("%s: config.rewriteOutputPath must be a string or a function.", maybeFullPath"config.lua")
	end

	-- Validate config.types
	for ext, fileType in pairs(site._fileTypes) do
		if ext ~= ext:lower() then
			errorNoPos("%s: File extensions must be lower case: config.types[\"%s\"]", maybeFullPath"config.lua", ext)
		elseif not FILE_TYPE_SET[fileType] then
			errorNoPos("%s: Invalid generator file type '%s'.", maybeFullPath"config.lua", fileType)
		end
	end

	-- Validate config.processors
	for ext in pairs(site._fileProcessors) do
		if ext ~= ext:lower() then
			errorNoPos("%s: File extensions must be lower case: config.processors[\"%s\"]", maybeFullPath"config.lua", ext)
		end
	end

	-- Validate config.baseUrl
	if baseUrlOverride ~= "" then
		site.baseUrl.v = baseUrlOverride
	end

	local parsedUrl = require"url".parse(site.baseUrl.v)

	if site.baseUrl.v == "" then
		errorNoPos("%s: config.baseUrl is missing or empty.", maybeFullPath"config.lua", site.baseUrl.v)

	elseif not parsedUrl.host then
		errorNoPos("%s: Missing host in config.baseUrl (%s)", maybeFullPath"config.lua", site.baseUrl.v)

	elseif not parsedUrl.scheme then
		errorNoPos("%s: Missing scheme in config.baseUrl (%s)", maybeFullPath"config.lua", site.baseUrl.v)
	elseif not isAny(parsedUrl.scheme, "http","https") then
		errorNoPos("%s: Invalid scheme in config.baseUrl (Expected http or https, got '%s')", maybeFullPath"config.lua", parsedUrl.scheme)

	elseif not (parsedUrl.path or ""):find"/$" then
		errorNoPos("%s: config.baseUrl must end with '/'. (%s)", maybeFullPath"config.lua", site.baseUrl.v)

	elseif parsedUrl.query then
		errorNoPos("%s: config.baseUrl Cannot contain a query. (%s)", maybeFullPath"config.lua", site.baseUrl.v)
	elseif parsedUrl.fragment then
		errorNoPos("%s: config.baseUrl Cannot contain a fragment. (%s)", maybeFullPath"config.lua", site.baseUrl.v)
	end

	-- Final config handling.
	for ext, customDataParser in pairs(customDataTextParsers) do
		-- ext = ext:lower() -- Actually a bad idea! (Until we have a version of isFile() that is case insensitive, that is. Also, we should probably raise an error if it's not lowercase.)

		dataParsers[ext]        = customDataParser
		dataParserIsBinary[ext] = false

		if customDataBinaryParsers[ext] then
			errorNoPos("%s: Both config.dataTextParsers.%s and config.dataBinaryParsers.%s are defined.", maybeFullPath"config.lua", ext, ext)
		end
	end

	for ext, customDataParser in pairs(customDataBinaryParsers) do
		-- ext = ext:lower() -- Actually a bad idea! (Until we have a version of isFile() that is case insensitive, that is. Also, we should probably raise an error if it's not lowercase.)

		dataParsers[ext]        = customDataParser
		dataParserIsBinary[ext] = true

		if customDataTextParsers[ext] then
			errorNoPos("%s: Both config.dataTextParsers.%s and config.dataBinaryParsers.%s are defined.", maybeFullPath"config.lua", ext, ext)
		end
	end



	-- Generate website from content folder.
	----------------------------------------------------------------

	timestampPrint("Generating website...")

	for category in pairs(OUTPUT_CATEGORY_SET) do
		site._outputFileCounts[category] = 0
	end

	if onBefore then
		!PUSH_CONTEXT "config"
			local before = onBefore -- :BetterTraceback
			timestampPrintVerbose("--> config.before(start)")
			before()
			timestampPrintVerbose("--> config.before(finish)")
		!POP_CONTEXT()
	end

	--
	-- Generate output
	--
	traverseFiles(DIR_CONTENT, site._ignoreFolders, function(path, pathRel, filename, extLower)
		-- Ignored.
		if
			(site._ignoreFiles[1] and isStringMatchingAnyPattern(filename,                site._ignoreFiles)) or
			(site._ignorePaths[1] and isStringMatchingAnyPattern(pathToSitePath(pathRel), site._ignorePaths))
		then
			-- void

		-- Template.
		elseif site._fileTypes[extLower] then
			-- Generate these later so e.g. urlExists() works better.
			local page       = newPage(pathRel, false)
			local pagesArray = (page.isPage.v and site._pages or site._nonPagePages)
			table.insert(pagesArray, page)

		-- Special.
		elseif pathRel == ".htaccess" and handleHtaccess then
			-- void  Ignore for now. We handle this file later.

		-- Other.
		else
			local modTime       = lfs.attributes(path, "modification")
			local pathOutputRel = rewriteOutputPath(pathRel)

			-- Non-templates should be OK to preserve (if there's no file processor).
			local oldModTime = (
				not ignoreModificationTimes and not site._fileProcessors[extLower]
				and lfs.attributes(DIR_OUTPUT.."/"..pathOutputRel, "modification")
				or  nil
			)

			if modTime and modTime == oldModTime then
				preserveExistingOutputFile("raw", pathRel, "/"..pathRel, pathRel)
			else
				local contents = assert(getFileContentsBinary(path))
				writeOutputFile("raw", pathRel, "/"..pathRel, contents, modTime, pathRel)
			end
		end
	end)

	timestampPrintVerbose("--> RegularGeneration(start)")

	generateNonPages()

	for _, page in ipairs(site._pages) do
		if not page._isGenerated then
			generateFromTemplateFile(page)
		end
	end

	timestampPrintVerbose("--> RegularGeneration(finish)")

	if onAfter then
		!PUSH_CONTEXT "config"
			local after = onAfter -- :BetterTraceback
			timestampPrintVerbose("--> config.after(start)")
			after()
			timestampPrintVerbose("--> config.after(finish)")
		!POP_CONTEXT()
	end

	--
	-- Redirections
	--

	-- Note: If the same key in allRedirections is set multiple times then we have
	-- duplicate redirections and generateRedirection() will raise an error.
	local allRedirections = {--[[ [url1]=targetUrl1, ... ]]}

	for url, targetUrl in pairs(site.redirections.v) do
		allRedirections[url] = targetUrl
	end

	for _, page in ipairs(site._pages) do
		if page.isPage.v and not page._isSkipped then
			assert(page._isGenerated)

			for _, url in ipairs(page.aliases.v) do
				allRedirections[url] = page.url.v
			end
		end
	end

	-- Fast-forward indirect redirections.
	for url, targetUrl in pairsSorted(site.redirections.v) do
		while allRedirections[targetUrl] do
			targetUrl = allRedirections[targetUrl]

			if targetUrl == url then
				local buffer = {"Redirection loop found:\n  -> ", url}
				targetUrl    = site.redirections.v[url]

				while targetUrl ~= url do
					table.insert(buffer, "\n     ")
					table.insert(buffer, targetUrl)
					targetUrl = allRedirections[targetUrl]
				end

				table.insert(buffer, "\n  -> ")
				table.insert(buffer, url)

				errorNoPos(table.concat(buffer))
			end
		end

		allRedirections[url]     = targetUrl
		site.redirections.v[url] = targetUrl
	end

	-- Validate targets.
	for url, targetUrl in pairsSorted(allRedirections) do
		if targetUrl:find"^/" and not site._writtenOutputUrls[targetUrl:gsub("[?#].*", "")] then
			errorNoPos("Missing target page for redirection: %s -> %s", url, targetUrl)
		end
	end

	-- Write redirections.
	for _, page in ipairs(site._pages) do
		if page.isPage.v and not page._isSkipped then
			for _, url in ipairs(page.aliases.v) do
				generateRedirection(url, page.url.v, page._path)
			end
		end
	end

	for url, targetUrl in pairsSorted(site.redirections.v) do
		local sourcePath = ""

		if targetUrl:find"^/" then
			for _, page in ipairs(site._pages) do
				if page.url.v == targetUrl then
					sourcePath = page._path
					break
				end
			end
		end

		generateRedirection(url, targetUrl, sourcePath)
	end

	--
	-- Htaccess
	--
	local handlingSpecialRedirections = false

	if handleHtaccess then
		local contents    = getFileContentsText(DIR_CONTENT.."/.htaccess")
		local fileExisted = (contents ~= nil)
		contents          = contents or ""

		-- Non-rewriting.
		--------------------------------

		if htaNoIndexes then
			contents = contents.."\nOptions -Indexes\n"
		end

		if next(site._htaErrors) then
			local b = newStringBuilder()

			for errCode, targetDoc in pairsSorted(site._htaErrors) do
				-- The target may be a URL or HTML code.
				if targetDoc:find"^/%S*$" then
					-- @Incomplete: Does Apache rewrite URLs to error documents? I don't think v2.2 did, but maybe
					-- that has changed. If so, we should test for multiple file locations. :ApacheErrorDocumentFile
					if not isFile(DIR_OUTPUT..targetDoc:gsub("[?#].*", "")) then
						errorNoPos("%s: Missing target page for error %d document (in output folder): %s%s", maybeFullPath"config.lua", errCode, DIR_OUTPUT, targetDoc)
					end
					targetDoc = fixRelativeUrl(targetDoc)
				end

				b("ErrorDocument %d %s\n", errCode, targetDoc)
			end

			contents = F("%s\n%s", contents, b())
		end

		-- Rewriting.
		--------------------------------

		local escapeTestStr = htaccessRewriteEscapeTestString
		local escapeCondPat = htaccessRewriteEscapeCondPattern
		local escapeRuleSub = htaccessRewriteEscapeRuleSubstitution

		local b = newStringBuilder()

		b("<IfModule mod_rewrite.c>\n")
		b("\tOptions +FollowSymLinks\n") -- Required for rewriting to work in .htaccess files!
		b("\tRewriteEngine On\n")
		b("\n")

		local rewriteStartIndex = #b+1

		if htaWww then
			local protocol, theRest = site.baseUrl.v:match"^(https?)://(.+)"
			if theRest:find"^www%." then
				b("\t# Add www.\n")
				b("\tRewriteCond %{HTTP_HOST} !^www\\. [NC]\n")
				b('\tRewriteRule .* %s://www.%%{HTTP_HOST}%%{REQUEST_URI} [R=301,L]\n', protocol)
			else
				b("\t# Remove www.\n")
				b("\tRewriteCond %{HTTP_HOST} ^www\\.(.*)\n")
				b('\tRewriteRule .* %s://%%1%%{REQUEST_URI} [R=301,L]\n', protocol)
			end
			b("\n")
		end

		if htaRedirect and (next(site._writtenRedirects) or next(site._unwrittenRedirects)) then
			handlingSpecialRedirections = true
			b("\t# Redirect moved resources.\n")

			for url, targetUrl in pairsSorted(site._writtenRedirects) do
				-- Make absolute target URLs relative if possible.
				if targetUrl:sub(1, #site.baseUrl.v) == site.baseUrl.v then
					targetUrl = targetUrl:sub(#site.baseUrl.v) -- Note: We keep the initial '/'.
				end

				url       = fixRelativeUrl(url)
				targetUrl = fixRelativeUrl(targetUrl)

				b('\tRewriteCond %%{REQUEST_URI} "=%s"\n', url)
				b('\tRewriteRule .* "%s" [NE,R=301,L]\n', escapeRuleSub(targetUrl, true))
			end

			for url, targetUrl in pairsSorted(site._unwrittenRedirects) do
				-- Some @Copypaste from above.

				-- Make absolute target URLs relative if possible.
				if targetUrl:sub(1, #site.baseUrl.v) == site.baseUrl.v then
					targetUrl = targetUrl:sub(#site.baseUrl.v) -- Note: We keep the initial '/'.
				end

				local slug, query = url:match"^(.-)%?(.*)$"
				if not slug then  slug = url  end

				slug      = fixRelativeUrl(slug)
				targetUrl = fixRelativeUrl(targetUrl)

				if query and not targetUrl:find("?", 1, true) then
					targetUrl = targetUrl .. "?" -- This will make sure the query from the source URL doesn't carry over to the target URL.
				end

				b('\tRewriteCond %%{REQUEST_URI} "=%s"\n', slug)
				if query then
					b('\tRewriteCond %%{QUERY_STRING} "=%s"\n', query)
				end

				b('\tRewriteRule .* "%s" [NE,R=301,L]\n', escapeRuleSub(targetUrl, true))
			end

			b("\n")
		end

		if site._noTrailingSlash then
			b("\t# Remove trailing slash.\n")
			b("\tRewriteCond %{REQUEST_FILENAME} !-d\n")
			b("\tRewriteCond %{REQUEST_URI} ./$\n")
			b("\tRewriteRule (.*)/$ /$1 [R=301,L]\n")
			b("\n")
		end

		if htaDenyAccess[1] then
			b("\t# Deny direct access to some directories.\n")
			b("\tRewriteCond %{ENV:REDIRECT_STATUS} ^$\n")

			for i, urlPrefix in ipairs(htaDenyAccess) do
				urlPrefix = fixRelativeUrl(urlPrefix)
				b(
					'\tRewriteCond %%{REQUEST_URI} "^%s"%s\n',
					escapeCondPat(urlPrefix, false),
					htaDenyAccess[i+1] and " [OR]" or ""
				)
			end

			b("\tRewriteRule ^ - [R=404,L]\n")
			b("\n")
		end

		if htaPrettyUrlDir ~= "" then
			if not isDirectory(DIR_OUTPUT.."/"..htaPrettyUrlDir) then
				errorNoPos("%s: config.htaccess.XXX_prettyUrlDirectory points to a missing directory (in output folder): %s/%s", maybeFullPath"config.lua", DIR_OUTPUT, htaPrettyUrlDir)
			end

			b('\t# Point to "%s" directory.\n', htaPrettyUrlDir)
			b("\tRewriteCond %{REQUEST_FILENAME} !-f\n")
			b('\tRewriteCond "%%{DOCUMENT_ROOT}%s%s/%%{REQUEST_URI}" -f\n', fixRelativeUrl"/", escapeTestStr(htaPrettyUrlDir))
			b('\tRewriteRule .* "%s%s/$0" [L]\n', fixRelativeUrl"/", escapeRuleSub(htaPrettyUrlDir, false))
			b("\n")

			b("\tRewriteCond %{REQUEST_FILENAME} !-f\n")
			b("\tRewriteCond %{REQUEST_URI} !^/$\n")
			b('\tRewriteCond "%%{DOCUMENT_ROOT}%s%s/%%{REQUEST_URI}/" -d\n', fixRelativeUrl"/", escapeTestStr(htaPrettyUrlDir))
			b('\tRewriteRule .* "%s%s/$0/" [L]\n', fixRelativeUrl"/", escapeRuleSub(htaPrettyUrlDir, false))
			b("\n")
		end

		if b[rewriteStartIndex] then
			if b[#b] == "\n" then
				b[#b] = nil
			end

			b("</IfModule>\n")

			local directives = b()

			local count1, count2
			contents, count1 = gsubPlainSub(contents, "#[ \t]*:webgen%.rewriting:[ \t]*\n", directives)
			contents, count2 = gsubPlainSub(contents, "#[ \t]*:webgen%.rewriting:[ \t]*$",  directives)
			if count1+count2 == 0 then
				contents = F("%s\n%s", contents, directives)
			end
		end

		--------------------------------

		writeOutputFile("raw", ".htaccess", "/.htaccess", contents, nil, (fileExisted and ".htaccess" or ""))
	end--if handleHtaccess

	if not handlingSpecialRedirections and next(site._unwrittenRedirects) then
		local count = #getKeys(site._unwrittenRedirects)
		timestampPrintWarning("%d URL redirection%s could not be satisfied:", count, (count == 1 and "" or "s"))

		for url, targetUrl in pairsSorted(site._unwrittenRedirects) do
			local s = F("    %s", url, targetUrl)
			io.stderr:write(s, "\n")
			log(s)
		end
	end

	if onValidate then
		!PUSH_CONTEXT "validation"
			local validate = onValidate -- :BetterTraceback
			timestampPrintVerbose("--> config.validate(start)")
			validate()
			timestampPrintVerbose("--> config.validate(finish)")
		!POP_CONTEXT()
	end

	--
	-- Clean up old generated files and folders
	--
	traverseFiles(DIR_OUTPUT, nil, function(path, pathOutputRel, filename, extLower)
		if not site._writtenOutputFiles[pathOutputRel] then
			timestampPrintVerbose("Removing: %s", maybeFullPath(path))
			assert(os.remove(path))
		end
	end)
	removeEmptyDirectories(DIR_OUTPUT)

	timestampPrint("Generating website... done!")



	----------------------------------------------------------------

	!local SEPARATOR = ("-"):rep(64)
	local endTime    = getTimeBetter()

	print!(SEPARATOR)
	printf("Files: %d", site._outputFileCount)
	printf("    Pages:           %d  (Skipped: %d)", site._outputFileCounts["page"], site._outputFileSkippedPageCount)
	printf("    OtherTemplates:  %d", site._outputFileCounts["template"])
	printf("    OtherFiles:      %d  (Preserved: %d, %.1f%%)",
		site._outputFileCounts["raw"], site._outputFilePreservedCount,
		site._outputFileCounts["raw"] == 0 and 100 or site._outputFilePreservedCount/site._outputFileCounts["raw"]*100
	)
	printf("TotalSize: %s", formatBytes(site._outputFileByteCount))
	printf("Time: %.2f seconds", endTime-startTime)
	print!(SEPARATOR)

	logFile:flush()
end

appOk = xpcall(buildWebsite, xpcallErrorHandler)



if autobuild then
	printNoLog("Press Ctrl+C to stop auto-building.")

	local lastDirTree = nil

	while true do
		sleep(AUTOBUILD_MIN_INTERVAL)

		local dirTree          = {--[[ [path1]=modificationTime1, ... ]]}
		local somethingChanged = false

		-- @Incomplete: Don't raise any errors when checking files and folders - just stop and try again after another change is detected.

		local function checkFile(path, silent)
			dirTree[path] = assert(lfs.attributes(path, "modification"))

			if lastDirTree and lastDirTree[path] and dirTree[path] > lastDirTree[path] then
				if not silent then
					printf("Detected file change: %s", maybeFullPath(path))
				end
				somethingChanged = true
			end
		end

		local function checkDirectory(dir, silent)
			traverseDirectory(dir, site._ignoreFolders, function(path, pathRel, filename, itemType)
				if itemType == "directory" then
					dirTree[path] = -1

				elseif itemType == "file" then
					if site._ignoreFiles[1] and isStringMatchingAnyPattern(filename,                site._ignoreFiles) then  return  end
					if site._ignorePaths[1] and isStringMatchingAnyPattern(pathToSitePath(pathRel), site._ignorePaths) then  return  end
					checkFile(path, silent)
				end

				if lastDirTree and not lastDirTree[path] then
					somethingChanged = true
					if not silent then
						printf("Detected addition: %s", maybeFullPath(path))
					end
				end
			end)
		end

		-- Check for additions and modifications.
		checkFile("config.lua")
		local configChanged = somethingChanged
		checkDirectory(DIR_CONTENT, false)
		checkDirectory(DIR_DATA,    false)
		checkDirectory(DIR_LAYOUTS, false)
		checkDirectory(DIR_SCRIPTS, false)

		-- Check for removals.
		if lastDirTree and not somethingChanged then
			for path in pairs(lastDirTree) do
				if not dirTree[path] then
					somethingChanged = true
					printf("Detected removal: %s", maybeFullPath(path))
					break
				end
			end
		end

		if somethingChanged then
			appOk = xpcall(buildWebsite, xpcallErrorHandler)
		end

		if configChanged then
			-- Recheck everything in case config.ignore* changed.
			dirTree = {["config.lua"]=dirTree["config.lua"]}
			checkDirectory(DIR_CONTENT, true)
			checkDirectory(DIR_DATA,    true)
			checkDirectory(DIR_LAYOUTS, true)
			checkDirectory(DIR_SCRIPTS, true)
		end

		lastDirTree = dirTree
	end
end



--==============================================================

if not appOk then
	printf("Aborted after error!")
elseif warningCount > 0 then
	printf("Finished with %d warnings!", warningCount)
else
	printf("Finished!")
end

if not enableGc then
	printf("Memory usage: %s", formatBytes(collectgarbage"count"*1024))
end

printfNoLog("Check log for details: %s", maybeFullPath(logPath))
if logFile then
	logFile:close()
	_G.logFile = nil
end

return appOk

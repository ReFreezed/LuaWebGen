--[[============================================================
--=
--=  Global Functions
--=
--=-------------------------------------------------------------
--=
--=  LuaWebGen - static website generator in Lua!
--=  - Written by Marcus 'ReFreezed' Thunström
--=  - MIT License (See LICENSE.txt)
--=
--==============================================================

	attributeWith, attributeWithAny
	cleanupPath
	countString, countSubString
	createDirectory, isDirectoryEmpty, removeEmptyDirectories
	createThumbnail
	datetimeToTime, getDatetime
	encodeHtmlEntities, markdownToHtml, doesValueLookLikeHtml
	error, errorf, fileError, errorNoPos
	F, formatBytes, formatTemplate
	generateFromTemplateString, generateFromTemplateFile, generateRedirection
	generateNonPages
	getCwd
	getDirectory, getFilename, getExtension, getBasename
	getFileContentsBinary, getFileContentsText
	getGeneratorHtmlMetaTag
	getKeys
	getLayoutTemplate
	getLineNumber
	getProtectionWrapper
	getTimeBetter, sleep
	getTimezone, getTimezoneOffsetString, getTimezoneOffset
	gsubPlainSub, gmatchAndBetween
	htaccessRewriteEscapeTestString, htaccessRewriteEscapeCondPattern, htaccessRewriteEscapeRuleSubstitution
	indexOf, itemWith, itemWithAll
	insertMultiple
	ipairsr, iprev
	isAny
	isArgs
	isFile, isDirectory
	isStringMatchingAnyPattern
	loadImage, getImageDimensions
	loadLuaFile
	maybeFullPath
	newDataFolderReader, isDataFolderReader, preloadData
	newScriptFolderReader, isScriptFolderReader, preloadScripts
	newSite, newPage
	newStringBuilder
	pack
	pairsSorted
	parseAndRunTemplate
	pathToSitePath, sitePathToPath
	percentEncode, partialEncodeUrl, fixRelativeUrl, fixRelativeUrlAndEncode, toAbsoluteAndEncodedUrl, urlize, urlToPrettyText
	printNoLog, printfNoLog, log, print, printOnce, printf, printfOnce, timestampPrint, timestampPrintOnce, timestampPrintVerbose, timestampPrintError, timestampPrintWarning, timestampPrintWarningOnce, printObject, logErrorTraceback
	pushContext, assertContext, getContext, isContext
	removeItem
	rewriteOutputPath
	round
	serializeLua
	sort
	sortNatural, compareNatural
	splitString
	toNormalPath, toWindowsPath
	tostringForTemplates
	traverseDirectory, traverseFiles
	trim, trimNewlines
	unindent
	urlExists
	writeOutputFile, preserveExistingOutputFile

--============================================================]]

!local PRINT_METAPROGRAMS = DEV and 1==0

local templateMetaprogramCache = {}



function _G.traverseDirectory(dirPath, ignoreFolders, cb, _pathRelStart)
	_pathRelStart = _pathRelStart or #dirPath+2

	for filename in lfs.dir(dirPath) do
		local path = dirPath.."/"..filename

		if filename ~= "." and filename ~= ".." then
			local mode = lfs.attributes(path, "mode")

			if mode == "file" then
				local pathRel = path:sub(_pathRelStart)
				local abort   = cb(path, pathRel, filename, "file")
				if abort then  return true  end

			elseif mode == "directory" and not (ignoreFolders and isStringMatchingAnyPattern(filename, ignoreFolders)) then
				local pathRel = path:sub(_pathRelStart)
				local abort   = cb(path, pathRel, filename, "directory")
				if abort then  return true  end

				local abort = traverseDirectory(path, ignoreFolders, cb, _pathRelStart)
				if abort then  return true  end
			end
		end
	end
end

function _G.traverseFiles(dirPath, ignoreFolders, cb, _pathRelStart)
	_pathRelStart = _pathRelStart or #dirPath+2

	for filename in lfs.dir(dirPath) do
		local path = dirPath.."/"..filename

		if filename ~= "." and filename ~= ".." then
			local mode = lfs.attributes(path, "mode")

			if mode == "file" then
				local pathRel  = path:sub(_pathRelStart)
				local extLower = getExtension(filename):lower()
				local abort    = cb(path, pathRel, filename, extLower)
				if abort then  return true  end

			elseif mode == "directory" and not (ignoreFolders and isStringMatchingAnyPattern(filename, ignoreFolders)) then
				local abort = traverseFiles(path, ignoreFolders, cb, _pathRelStart)
				if abort then  return true  end
			end
		end
	end
end



function _G.isStringMatchingAnyPattern(s, patterns)
	for _, pat in ipairs(patterns) do
		if s:find(pat) then  return true  end
	end
	return false
end



function _G.getFileContentsBinary(path)
	local file, err = io.open(path, "rb")
	if not file then  return nil, err  end

	local contents = file:read"*a"
	file:close()

	return contents
end

function _G.getFileContentsText(path)
	local file, err = io.open(path, "r")
	if not file then  return nil, err  end

	local contents = file:read"*a"
	file:close()

	if contents:find("\r", 1, true) then
		contents = contents:gsub("\n?\r\n?", "\n")
	end

	return contents
end



do
	-- isValueExpression = insertLuaForEchoingIfExpression( luaOutputBuffer, luaCode )
	local function insertLuaForEchoingIfExpression(out, luaCode)
		-- Note: echo() and echoRaw() do the same thing in e.g. CSS files, so we
		-- can output the same code here no matter what file is being processed.
		-- It is a thing we can optimize though. @Speed
		local doBlock = F("echoSmart__(%s)", luaCode)
		if not loadstring(doBlock) then  return false  end

		table.insert(out, doBlock)
		return true
	end

	local BRACKET_ENDS = {
		["("] = ")",
		["{"] = "}",
		["["] = "]",
	}

	-- position, isUrlBlock = findEndOfBlockContents( path, template, position, blockI1 )
	local function findEndOfBlockContents(path, template, pos, blockI1)
		!local PRINT_PROGRESS = DEV and 1==0
		!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: >>>>>>>>", path, pos, getLineNumber(template, pos))`  end

		-- URL block:
		--   /(...)
		--   ./(...)
		--   ../(...)
		--   proto:/(...)
		if template:find("^ *%.?%.?/", pos) or template:find("^ *%a%w*:/", pos) then
			local i1 = template:find("%*?}}", pos)
			if not i1 then
				fileError(path, template, blockI1, "Incomplete URL block.")
			end
			return i1-1, true
		end

		-- Lua code block:

		local blockContentsI1 = pos

		local bracketBalance        = 0
		local bracketStartPositions = {}
		local bracketEndCharacters  = {}

		while true do
			--
			-- Note: We don't need to match every Lua token - only those that could
			-- intercept our search for the "}}" at the end of the code block.
			--
			-- @Speed? Positions can sometimes be cached between iterations.
			--
			local posBlockEnd     = bracketBalance == 0 and template:find("%*?}}", pos) or nil
			local posComment      = template:find("--",     pos, true)
			local posStringShort  = template:find("[\"']",  pos, false)
			local posStringLong   = template:find("%[=*%[", pos, false)
			local posBracketStart = template:find("[({%[]", pos, false)
			local posBracketEnd   = template:find("[)}%]]", pos, false)

			local posNext = math.min(
				(posBlockEnd     or 1/0),
				(posComment      or 1/0),
				(posStringShort  or 1/0),
				(posStringLong   or 1/0),
				(posBracketStart or 1/0),
				(posBracketEnd   or 1/0)
			)

			if posNext == posBlockEnd then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: <<<<<<<<", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBlockEnd - 1
				return pos, false

			elseif posNext == posComment then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Comment", path, posNext, getLineNumber(template, posNext))`  end
				pos                   = posComment
				local longStringLevel = template:match("^%[(=*)%[", pos+2)

				if longStringLevel then
					pos         = pos + 4 + #longStringLevel -- Eat "--[=[".
					local _, i2 = template:find("%]"..longStringLevel.."%]", pos)

					if not i2 then
						fileError(
							path, template, posComment,
							"Incomplete long comment. (Code block starting at line %d)",
							getLineNumber(template, blockContentsI1)
						)
					end

					pos = i2+1

				else
					pos     = pos + 2 -- Eat "--".
					local i = template:find("\n", pos, true)
					pos     = i and i+1 or pos
				end

			elseif posNext == posStringShort then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: String", path, posNext, getLineNumber(template, posNext))`  end
				pos = posStringShort + 1

				local pat = "(["..template:sub(posStringShort, posStringShort).."\\])"

				while true do
					local i, _, c = template:find(pat, pos)
					if not i then
						fileError(
							path, template, posStringShort,
							"Missing end quote for string. (Code block starting at line %d)",
							getLineNumber(template, blockContentsI1)
						)
					end
					pos = i + 1
					if c == "\\" then
						pos = pos + 1 -- It's fine to always skip one character, even if the escape sequence is something like "\173". Any errors will be checked later by loadstring().
					else
						break
					end
				end

			elseif posNext == posStringLong then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: String (long)", path, posNext, getLineNumber(template, posNext))`  end
				pos                   = posStringLong
				local longStringLevel = template:match("^%[(=*)%[", pos)

				pos         = pos + 2 + #longStringLevel -- Eat "[=[".
				local _, i2 = template:find("%]"..longStringLevel.."%]", pos)

				if not i2 then
					fileError(
						path, template, posStringLong,
						"Incomplete long string. (Code block starting at line %d)",
						getLineNumber(template, blockContentsI1)
					)
				end

				pos = i2 + 1

			elseif posNext == posBracketStart then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Bracket start", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBracketStart

				bracketBalance                        = bracketBalance + 1
				bracketStartPositions[bracketBalance] = pos
				bracketEndCharacters[bracketBalance]  = BRACKET_ENDS[template:sub(pos, pos)]

				pos = pos + 1

			elseif posNext == posBracketEnd then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Bracket end", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBracketEnd

				if bracketBalance == 0 then
					fileError(
						path, template, pos,
						"Unexpected '%s'. Too many end brackets. (Code block starting at line %d)",
						template:sub(pos, pos), getLineNumber(template, blockContentsI1)
					)
				end

				local bracketEndChar = bracketEndCharacters[bracketBalance]

				if template:sub(pos, pos) ~= bracketEndChar then
					fileError(
						path, template, pos,
						"Expected '%s' to end bracket starting at line %d, but got '%s'. (Code block starting at line %d)",
						bracketEndChar,
						getLineNumber(template, bracketStartPositions[bracketBalance]),
						template:sub(pos, pos),
						getLineNumber(template, blockContentsI1)
					)
				end

				bracketStartPositions[bracketBalance] = nil
				bracketEndCharacters[bracketBalance]  = nil
				bracketBalance                        = bracketBalance - 1

				pos = pos + 1

			else
				if bracketBalance > 0 then
					fileError(
						path, template, bracketStartPositions[bracketBalance],
						"Missing '%s'. Unbalanced brackets in code. (Code block starting at line %d)",
						bracketEndCharacters[bracketBalance], getLineNumber(template, blockContentsI1)
					)
				end

				fileError(path, template, blockI1, "Missing end of this code block.")
			end
		end

		assert(false)
	end

	-- endBlockI1, endBlockI2, endBlockContents = templateToLua( luaOutputBuffer, path, template, position, templateifiedControlStructureLevel, templateifiedControlStructurePosition )
	local function templateToLua(out, path, template, pos, tcsLevel, tcsPos)
		!local PATTERN_IDENT       = "[%a_][%w_]*"
		!local PATTERN_IDENT_BEGIN = "%f[%w_]"
		!local PATTERN_IDENT_END   = "%f[^%w_]"

		while pos <= #template do
			local blockI1Trimmed, blockI1, doTrim, blockContentsI1 = template:match(!(NOSPACE"() %s* () {{ (%*?) ()"), pos)
			if not blockI1 then  break  end

			local autoLock = (site._autoLockPages and blockI1Trimmed == 1)
			doTrim         = (doTrim == "*")
			local echoI2   = (doTrim and blockI1Trimmed or blockI1) - 1

			if doTrim and blockI1 > blockI1Trimmed then
				table.insert(out, ("\n"):rep(countSubString(template, blockI1Trimmed, blockI1-1, "\n", true))) -- :TrimBlocks
			end

			if pos <= echoI2 then
				local plainSegment = template:sub(pos, echoI2)
				table.insert(out, "echoRaw__'") -- Note: Templates will probably have more double quotes than single, that's why we use single quotes here - for nicer metaprogram output. :TemplateOutputQuotes
				table.insert(out, (plainSegment:gsub("[\\'\n]", "\\%0")))
				table.insert(out, "'")
			end

			pos = blockContentsI1

			table.insert(out, "do end ") -- Statement divider.

			local blockContentsI2, isUrlBlock = findEndOfBlockContents(path, template, pos, blockI1)
			local blockContents               = template:sub(blockContentsI1, blockContentsI2)
			pos                               = blockContentsI2 + 1

			!if DEV and 1==0 then
				print("BLOCK: "..trim(blockContents))
			!end

			doTrim, pos = template:match(!(NOSPACE"^(%*?) }} ()"), pos)
			doTrim      = (doTrim == "*")

			!local TRIM_POS_AFTER_BLOCK = `
			if doTrim then
				local posAfterBlock;posAfterBlock, pos = template:match("^()%s*()", pos)
				if pos > posAfterBlock then
					table.insert(out, ("\n"):rep(countSubString(template, posAfterBlock, pos, "\n", true))) -- :TrimBlocks
				end
			end
			`

			----------------------------------------------------------------

			-- URL block.
			if isUrlBlock then
				table.insert(out, F("echo__(url__%q)", trim(blockContents)))
				-- @Incomplete: Fix line numbers if blockContents has newlines (which is probably rare).
				!!(TRIM_POS_AFTER_BLOCK)

			-- Match custom keywords first so we don't confuse those with normal Lua identifiers later.

			-- fori [<] item in <array> (...) end
			-- fori [<] <array> (...) end
			elseif blockContents:find!("^ *fori"..PATTERN_IDENT_END) then
				local             reverse, ident, expr = blockContents:match!(NOSPACE("^ %s* fori %s* (< ) %s* ("..PATTERN_IDENT..") %s+ in "..PATTERN_IDENT_END.." %s* (%S.*)"))
				if not expr then           ident, expr = blockContents:match!(NOSPACE("^ %s* fori %s+          ("..PATTERN_IDENT..") %s+ in "..PATTERN_IDENT_END.." %s* (%S.*)"))
				if not expr then  reverse,        expr = blockContents:match!(NOSPACE("^ %s* fori %s* (<?) %s*                                                          (%S.*)"))
				if not expr then
					fileError(path, template, blockContentsI1, "Invalid 'fori' statement.")
				end end end

				reverse = (reverse == "<")

				if not loadstring("_=("..expr..")") then
					fileError(path, template, blockContentsI1, "Invalid value expression for 'fori' loop: %s", trim(expr)) -- @UX: Better error message.
				end

				table.insert(out, "for i, ")
				table.insert(out, (ident or "it"))
				table.insert(out, " in ")
				table.insert(out, (reverse and "foriReverse__" or "fori__"))
				table.insert(out, "(")
				table.insert(out, expr)
				table.insert(out, ") do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'fori' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, "end ")
				pos = scopeEndBlockI2 + 1

			-- for index [, item, ... ] in <expression> (...) end
			-- for index = <from>, <to> [, <step> ] (...) end
			elseif
				blockContents:find!("^ *for%s+"..PATTERN_IDENT.."%s*[,=]") or
				blockContents:find!("^ *for%s+"..PATTERN_IDENT.."%s+in"..PATTERN_IDENT_END)
			then
				table.insert(out, blockContents) -- @Robustness: Surround value in parenthesis, when possible.
				table.insert(out, " do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'for' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, " end ")
				pos = scopeEndBlockI2 + 1

			-- for [<] <to> (...) end
			elseif blockContents:find!("^ *for"..PATTERN_IDENT_END) then
				-- for < <to>
				if blockContents:find"^ *for%s*<" then
					local expr = blockContents:gsub("for%s*<", "", 1)

					if not loadstring("_=("..expr..")") then
						fileError(path, template, blockContentsI1, "Invalid value expression for simplified 'for' loop: %s", trim(expr)) -- @UX: Better error message.
					end

					table.insert(out, "for i = (")
					table.insert(out, expr)
					table.insert(out, "), 1, -1 do ")

				-- for <to>
				else
					local expr = blockContents:gsub("for", "", 1)

					if not loadstring("_=("..expr..")") then
						fileError(path, template, blockContentsI1, "Invalid value expression for simplified 'for' loop: %s", trim(expr)) -- @UX: Better error message.
					end

					table.insert(out, "for i = 1, (")
					table.insert(out, expr)
					table.insert(out, ") do ")
				end

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'for' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, " end ")
				pos = scopeEndBlockI2 + 1

			-- do (...) end
			elseif blockContents:find!("^ *do"..PATTERN_IDENT_END) then
				-- @Polish: Make sure there's no garbage at the end of blockContents.
				table.insert(out, "do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'do' starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, " end ")
				pos = scopeEndBlockI2 + 1

			-- if <condition> (...) end
			elseif blockContents:find!("^ *if"..PATTERN_IDENT_END) then
				table.insert(out, blockContents) -- @Robustness: Surround value in parenthesis.
				table.insert(out, " then ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				while scopeEndBlockContents:find!("^ *elseif"..PATTERN_IDENT_END) do
					table.insert(out, scopeEndBlockContents)
					table.insert(out, " then ")

					scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, scopeEndBlockI2+1, tcsLevel+1, scopeEndBlockI1)
				end

				if scopeEndBlockContents:find!("^ *else"..PATTERN_IDENT_END) then
					table.insert(out, "else ")

					scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, scopeEndBlockI2+1, tcsLevel+1, scopeEndBlockI1)
				end

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'if' starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, "end ")
				pos = scopeEndBlockI2 + 1

			-- while <condition> (...) end
			elseif blockContents:find!("^ *while"..PATTERN_IDENT_END) then
				table.insert(out, blockContents) -- @Robustness: Surround value in parenthesis.
				table.insert(out, " do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'while' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, "end ")
				pos = scopeEndBlockI2 + 1

			-- repeat (...) until <condition>
			elseif blockContents:find!("^ *repeat"..PATTERN_IDENT_END) then
				-- @Polish: Make sure there's no garbage at the end of blockContents.
				table.insert(out, "repeat ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *until" ..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'until' for 'repeat' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, scopeEndBlockContents)
				table.insert(out, " ")
				pos = scopeEndBlockI2 + 1

			-- End block + elseif.
			elseif
				blockContents:find!("^ *end"   ..PATTERN_IDENT_END) or
				blockContents:find!("^ *until" ..PATTERN_IDENT_END) or
				blockContents:find!("^ *else"  ..PATTERN_IDENT_END) or
				blockContents:find!("^ *elseif"..PATTERN_IDENT_END)
			then
				-- @Polish: Make sure there's no garbage at the end of blockContents.
				if tcsLevel == 1 then
					fileError(path, template, blockContentsI1, "Unexpected templateified '%s'.", blockContents:match"%a+")
				end
				!!(TRIM_POS_AFTER_BLOCK)
				local blockI2 = pos - 1
				return blockI1, blockI2, blockContents

			-- Value expression.
			elseif insertLuaForEchoingIfExpression(out, blockContents) then
				if blockContents:find"^%s*function%s*%(" then -- We do allow echoing functions, but this specifically is probably an error made by the user.
					fileError(path, template, blockContentsI1, "Invalid value expression.")
				end
				!!(TRIM_POS_AFTER_BLOCK)

			-- Any other Lua code.
			else
				table.insert(out, blockContents)
				table.insert(out, " ")
				!!(TRIM_POS_AFTER_BLOCK)
			end

			----------------------------------------------------------------

			table.insert(out, "do end ") -- Statement divider.

			if autoLock then
				table.insert(out, "lock__()")
			end
		end

		if pos <= #template then
			local plainSegment = template:sub(pos)
			table.insert(out, "echoRaw__'") -- :TemplateOutputQuotes
			table.insert(out, (plainSegment:gsub("[\\'\n]", "\\%0")))
			table.insert(out, "'")
		end

		if tcsLevel > 1 then
			fileError(path, template, tcsPos, "Templateified control structure doesn't have an end.")
		end

		return #template+1, #template, "", false -- These return values should never actually be used if everything is working correctly.
	end

	local function _parseAndRunTemplate(page, path, template, useCache, onPageInit, enableHtmlEncoding, args)
		local luaCode = (
			template == "" and ""
			or useCache    and templateMetaprogramCache[path]
			or                 nil
		)

		if not luaCode then
			local luaBuffer = {}
			templateToLua(luaBuffer, path, template, 1, 1, 1)

			luaCode = table.concat(luaBuffer)
			if useCache then  templateMetaprogramCache[path] = luaCode  end

			if outputMetaprograms then
				local metaPath = "temp/meta/" .. path:gsub("/", "__") .. ".lua"
				timestampPrintVerbose("Writing: %s", maybeFullPath(metaPath))

				createDirectory("temp/meta")

				local file = assert(io.open(metaPath, "wb"))
				file:write(luaCode)
				file:close()
			end

			!if PRINT_METAPROGRAMS then
				-- if path:find"test" then
					print("-- LUA "..path.." --")
					print(luaCode)
					print("-- /LUA --")
				-- end
			!end
		end

		local main_chunk, err = loadstring(luaCode, "@"..maybeFullPath(path))
		if not main_chunk then  errorNoPos(err)  end

		setfenv(main_chunk, scriptEnvironment)

		local templateResult

		!PUSH_CONTEXT "template"
			ctx.page                             = page
			ctx._scriptEnvironmentGlobals.page   = getProtectionWrapper(page, "page")
			ctx._scriptEnvironmentGlobals.params = page.params.v
			ctx._scriptEnvironmentGlobals.P      = page.params.v
			ctx.out                              = {}
			ctx.enableHtmlEncoding               = enableHtmlEncoding

			if onPageInit then
				-- Note: We don't strictly need to have the page as an argument for this
				-- callback because globals work as usual - it's just in case there's a
				-- problem with name shadowing for the user.
				onPageInit(ctx._scriptEnvironmentGlobals.page)
			end

			if args then
				main_chunk(unpack(args, 1, args.n))
			else
				main_chunk()
			end

			templateResult = (table.concat(ctx.out)
				:gsub("[ \t]+\n", "\n"  ) -- :Beautify spaces at the end of lines.
				:gsub("\n\n\n+",  "\n\n") -- :Beautify empty lines.  @Robustness: Not sure this is actually good. Might mess up <pre> tag contents.
			)
		!POP_CONTEXT()

		return templateResult
	end

	-- stringResult = parseAndRunTemplate( page, path, template, fileType=fromPage, useCache, onPageInit=nil, packedArguments=nil )
	-- onPageInit   = function( wrappedPage )
	function _G.parseAndRunTemplate(page, path, template, fileType, useCache, onPageInit, args)
		-- timestampPrintVerbose("--> Template(start): %s", maybeFullPath(path))
		local result

		if template == "" and not onPageInit then
			result = ""

		else
			fileType = (fileType or site._fileTypes[page._extension])

			!local PRINT_RESULT = DEV and 1==0

			if fileType == "markdown" then
				result = _parseAndRunTemplate(page, path, template, useCache, onPageInit, true, args)
				result = markdownToHtml(result)
				result = trimNewlines(result).."\n" -- :Beautify
				!if PRINT_RESULT then  __LUA` print"-- HTML --" print(result) print"-- /HTML --" `  end

			elseif fileType == "html" then
				result = _parseAndRunTemplate(page, path, template, useCache, onPageInit, true, args)
				result = trimNewlines(result).."\n" -- :Beautify
				!if PRINT_RESULT then  __LUA` print"-- HTML --" print(result) print"-- /HTML --" `  end

			elseif fileType == "xml" then
				result = _parseAndRunTemplate(page, path, template, useCache, onPageInit, true, args)
				result = trimNewlines(result).."\n" -- :Beautify
				!if PRINT_RESULT then  __LUA` print"-- XML --" print(result) print"-- /XML --" `  end

			else
				result = _parseAndRunTemplate(page, path, template, useCache, onPageInit, false, args)
				result = trimNewlines(result).."\n" -- :Beautify
				!if PRINT_RESULT then  __LUA` print"-- result --" print(result) print"-- /result --" `  end
			end
		end

		-- timestampPrintVerbose("--> Template(finish): %s", maybeFullPath(path))
		return result
	end

end



-- errorf( [ level=1, ] formatString, ... )
function _G.errorf(levelOrS, ...)
	if type(levelOrS) == "number" then
		error(F(...), (levelOrS == 0 and 0 or 1+levelOrS))
	else
		error(F(levelOrS, ...), 2)
	end
end

do
	local function findStartOfLine(s, pos, canBeEmpty)
		while pos > 1 do
			if s:byte(pos-1) == !(string.byte"\n") and (canBeEmpty or s:byte(pos) ~= !(string.byte"\n")) then  break  end
			pos = pos - 1
		end
		return math.max(pos, 1)
	end
	local function findEndOfLine(s, pos)
		while pos < #s do
			if s:byte(pos+1) == !(string.byte"\n") then  break  end
			pos = pos + 1
		end
		return math.min(pos, #s)
	end

	local function formatFileMessage(path, contents, pos, s, ...)
		if contents then
			pos = math.min(math.max(pos, 1), #contents+1)
		end
		local ln = contents and getLineNumber(contents, pos) or pos

		if type(s) ~= "string" then
			s = F("%s:%d: %s", maybeFullPath(path), ln, tostring(s))
		else
			s = F("%s:%d: "..s, maybeFullPath(path), ln, ...)
		end

		if contents then
			!local MAX_VIEW_BEFORE = 60
			!local MAX_VIEW_AFTER  = 40

			local lineStart     = findStartOfLine(contents, pos, true)
			local lineEnd       = findEndOfLine  (contents, pos-1)
			local linePre1Start = findStartOfLine(contents, lineStart-1, false)
			local linePre1End   = findEndOfLine  (contents, linePre1Start-1)
			local linePre2Start = findStartOfLine(contents, linePre1Start-1, false)
			local linePre2End   = findEndOfLine  (contents, linePre2Start-1)
			-- printf("pos %d | lines %d..%d, %d..%d, %d..%d", pos, linePre2Start,linePre2End+1, linePre1Start,linePre1End+1, lineStart,lineEnd+1) -- DEBUG

			-- @Incomplete: Handle multi-byte characters.
			local lengthLine     = lineEnd     - lineStart     + 1
			local lengthLinePre1 = linePre1End - linePre1Start + 1
			local lengthLinePre2 = linePre2End - linePre2Start + 1

			local column       = pos - lineStart + 1
			local columnsToCut = math.max(column-1-!(MAX_VIEW_BEFORE), 0)
			local lastColumn   = column + !(MAX_VIEW_AFTER)

			local toCutAfterLine     = lineEnd        - math.min(pos+!(MAX_VIEW_AFTER), lineEnd)
			local toCutAfterLinePre1 = lengthLinePre1 - math.min(lastColumn, lengthLinePre1) -- @Incomplete: Handle tabs if indentation is different from the main line.
			local toCutAfterLinePre2 = lengthLinePre2 - math.min(lastColumn, lengthLinePre2) -- @Incomplete: Handle tabs if indentation is different from the main line.

			-- @Incomplete: Handle tabs that's aren't part of the indentation better.
			s = F("%s\n>\n%s%s%s>-%s^\n",
				s,
				(linePre2Start < linePre1Start and linePre2Start <= linePre2End) and F("> %s\n", (contents:sub(linePre2Start + columnsToCut, linePre2End - toCutAfterLinePre2):gsub("\t", "    "))) or "",
				(linePre1Start < lineStart     and linePre1Start <= linePre1End) and F("> %s\n", (contents:sub(linePre1Start + columnsToCut, linePre1End - toCutAfterLinePre1):gsub("\t", "    "))) or "",
				(                                  lineStart     <= lineEnd    ) and F("> %s\n", (contents:sub(lineStart     + columnsToCut, lineEnd     - toCutAfterLine    ):gsub("\t", "    "))) or ">\n",
				("-"):rep(pos - (lineStart+columnsToCut) + 3*countSubString(contents, lineStart+columnsToCut, pos-1, "\t", true)),
				nil
			)
		end

		return s
	end

	-- fileError( path, contents, position,   formatString, ... )
	-- fileError( path, nil,      lineNumber, formatString, ... )
	function _G.fileError(path, contents, pos, s, ...)
		errorNoPos(formatFileMessage(path, contents, pos, s, ...))
	end

	-- fileWarning( path, contents, position,   formatString, ... )
	-- fileWarning( path, nil,      lineNumber, formatString, ... )
	function _G.fileWarning(path, contents, pos, s, ...)
		timestampPrintWarning(formatFileMessage(path, contents, pos, s, ...))
	end
end

-- Error with no code position prepended.
-- errorNoPos( message )
-- errorNoPos( formatString, ... )
function _G.errorNoPos(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end
	error(s, 0)
end



function _G.getLineNumber(s, pos)
	return 1 + countSubString(s, 1, pos-1, "\n", true)
end



-- writeOutputFile( category, pathRelative, url, dataString, modificationTime=now, sourcePath )
function _G.writeOutputFile(category, pathRel, url, data, modTime, sourcePath)
	local pathOutputRel = rewriteOutputPath(pathRel)
	if site._writtenOutputFiles[pathOutputRel] then
		errorf("Output file collision for '%s':\n\tSource 1: %s\n\tSource 2: %s", pathOutputRel, site._writtenOutputFiles[pathOutputRel], sourcePath)
	end
	assert(not site._writtenOutputUrls[url])

	local filename = getFilename(pathRel)
	local extLower = getExtension(filename):lower()

	if site._fileProcessors[extLower] then
		!PUSH_CONTEXT "none"
			data = site._fileProcessors[extLower](data)
		!POP_CONTEXT()

		if type(data) ~= "string" then
			errorf("File processor for '%s' files did not return a string.", extLower)
		end
	end

	local path = DIR_OUTPUT.."/"..pathOutputRel
	timestampPrintVerbose("Writing: %s", maybeFullPath(path))

	createDirectory(getDirectory(path))

	local file = assert(io.open(path, "wb"))
	file:write(data)
	file:close()

	if modTime then
		local ok, err = lfs.touch(path, modTime)
		if not ok then
			timestampPrintError("Could not update modification time for '%s'. (%s)", maybeFullPath(path), err)
		end
	end

	table.insert(site._writtenOutputEntries, {path=sourcePath, pathOut=pathOutputRel, url=url})
	table.insert(site._writtenOutputFiles,   pathOutputRel)
	table.insert(site._writtenOutputUrls,    url)
	site._writtenOutputFiles[pathOutputRel] = sourcePath
	site._writtenOutputUrls[url]            = true

	assert(OUTPUT_CATEGORY_SET[category], category)
	site._outputFileCount            = site._outputFileCount            + 1
	site._outputFileCounts[category] = site._outputFileCounts[category] + 1

	site._outputFileByteCount = site._outputFileByteCount + #data
end

-- preserveExistingOutputFile( category, pathRelative, url, sourcePath )
function _G.preserveExistingOutputFile(category, pathRel, url, sourcePath)
	local pathOutputRel = rewriteOutputPath(pathRel)
	if site._writtenOutputFiles[pathOutputRel] then
		errorf("Output file collision for '%s':\n\tSource 1: %s\n\tSource 2: %s", pathOutputRel, site._writtenOutputFiles[pathOutputRel], sourcePath)
	end
	assert(not site._writtenOutputUrls[url])

	local path = DIR_OUTPUT.."/"..pathOutputRel
	timestampPrintVerbose("Preserving: %s", maybeFullPath(path))

	local dataLen, err = lfs.attributes(path, "size")
	if not dataLen then
		timestampPrintError("Could not retrieve size of file '%s'. (%s)", maybeFullPath(path), err)
		dataLen = 0
	end

	table.insert(site._writtenOutputEntries, {path=sourcePath, pathOut=pathOutputRel, url=url})
	table.insert(site._writtenOutputFiles,   pathOutputRel)
	table.insert(site._writtenOutputUrls,    url)
	site._writtenOutputFiles[pathOutputRel] = sourcePath
	site._writtenOutputUrls[url]            = true

	assert(OUTPUT_CATEGORY_SET[category], category)
	site._outputFileCount            = site._outputFileCount            + 1
	site._outputFileCounts[category] = site._outputFileCounts[category] + 1
	site._outputFilePreservedCount   = site._outputFilePreservedCount   + 1

	site._outputFileByteCount = site._outputFileByteCount + dataLen
end



function _G.createDirectory(path)
	if path:find"^/" or path:find"^%a:" then
		errorf(2, "[internal] Absolute paths are disabled. (%s)", path)
	end
	if path:find"//" then
		errorf(2, "Path looks invalid: '%s'", path)
	end

	local pathConstructed = ""

	for folder in path:gmatch"[^/]+" do
		pathConstructed = (pathConstructed == "" and folder or pathConstructed.."/"..folder)
		if not (isDirectory(pathConstructed) or lfs.mkdir(pathConstructed)) then
			errorf("Could not create directory '%s'.", maybeFullPath(pathConstructed))
		end
	end
end

function _G.isDirectoryEmpty(dirPath)
	for filename in lfs.dir(dirPath) do
		if filename ~= "." and filename ~= ".." then  return false  end
	end
	return true
end

function _G.removeEmptyDirectories(dirPath)
	for filename in lfs.dir(dirPath) do
		local path = dirPath.."/"..filename

		if filename ~= "." and filename ~= ".." and isDirectory(path) then
			removeEmptyDirectories(path)
			if isDirectoryEmpty(path) then
				timestampPrintVerbose("Removing empty folder: %s", maybeFullPath(path))
				assert(lfs.rmdir(path))
			end
		end

	end
end



--
-- Note: Print functions log, but log functions do not print.
--

-- log( message )
-- log( formatString, ... )
function _G.log(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if not logFile then
		table.insert(toLog, s)
		return
	end

	for i, s in ipairs(toLog) do
		logFile:write(s, "\n")
		toLog[i] = nil
	end

	logFile:write(s, "\n")
end

do
	local values = {}

	_G.printNoLog = print
	function _G.printfNoLog(s, ...)
		printNoLog(F(s, ...))
	end

	function _G.print(...)
		printNoLog(...)

		local argCount = select("#", ...)
		for i = 1, argCount do
			values[i] = tostring(select(i, ...))
		end

		log(table.concat(values, "\t", 1, argCount))
	end
	function _G.printOnce(...)
		local argCount = select("#", ...)
		for i = 1, argCount do
			values[i] = tostring(select(i, ...))
		end

		local s = table.concat(values, "\t", 1, argCount)

		if oncePrints[s] then  return  end
		oncePrints[s] = true

		printNoLog(...)
		log(s)
	end
end

function _G.printf(s, ...)
	print(F(s, ...))
end
function _G.printfOnce(s, ...)
	printOnce(F(s, ...))
end

-- timestampLog( message )
-- timestampLog( formatString, ... )
function _G.timestampLog(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if s == "" then
		log("")
	else
		log("[%s] %s", os.date"%H:%M:%S", s)
	end
end

-- timestampPrint( message )
-- timestampPrint( formatString, ... )
-- timestampPrintOnce( message )
-- timestampPrintOnce( formatString, ... )
function _G.timestampPrint(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if s == "" then
		print()
	else
		printf("[%s] %s", os.date"%H:%M:%S", s)
	end
end
function _G.timestampPrintOnce(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if oncePrints[s] then  return  end
	oncePrints[s] = true

	printf("[%s] %s", os.date"%H:%M:%S", s)
end

-- timestampPrintVerbose( message )
-- timestampPrintVerbose( formatString, ... )
function _G.timestampPrintVerbose(...)
	if verbosePrint then
		timestampPrint(...)
	else
		timestampLog(...)
	end
end

-- timestampPrintError( message )
-- timestampPrintError( formatString, ... )
function _G.timestampPrintError(s, ...)
	if select("#", ...) > 0 then
		s = F("[%s] ERROR: "..s, os.date"%H:%M:%S", ...)
	else
		s = F("[%s] ERROR: %s",  os.date"%H:%M:%S", s)
	end
	io.stderr:write(s, "\n")
	log(s)
end

-- timestampPrintWarning( message )
-- timestampPrintWarning( formatString, ... )
-- timestampPrintWarningOnce( message )
-- timestampPrintWarningOnce( formatString, ... )
function _G.timestampPrintWarning(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	_G.warningCount = warningCount + 1
	s               = F("[%s] WARNING(%d): %s", os.date"%H:%M:%S", warningCount, s)

	io.stderr:write(s, "\n\n")
	log(s)
end
function _G.timestampPrintWarningOnce(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if oncePrints[s] then  return  end
	oncePrints[s] = true

	_G.warningCount = warningCount + 1
	s               = F("[%s] WARNING(%d): %s", os.date"%H:%M:%S", warningCount, s)

	io.stderr:write(s, "\n\n")
	log(s)
end

-- printObject( value1, ... )
-- Note: Does not write to log.
do
	local stdoutWrite = io.write

	local function toStringBetter(v)
		local s = tostring(v)
		return s:find"^table: "
		       and s:gsub("^table: ", ""):gsub("^0x", ""):gsub("^%w+", string.upper)
		       or  s
	end

	local function compareKeys(a, b)
		return compareNatural(toStringBetter(a), toStringBetter(b))
	end

	local function _printObject(v, printedTables, firstLevel)
		local vType = type(v)

		if printedTables[v] then
			stdoutWrite(toStringBetter(v))

		elseif vType == "table" then
			printedTables[v] = true
			stdoutWrite(toStringBetter(v), (firstLevel and "{\n" or "{ "))

			local indices = {}
			for i = 1, #v do  indices[i] = true  end

			for _, k in ipairs(sort(getKeys(v), compareKeys)) do
				if not indices[k] then
					if firstLevel then  stdoutWrite("\t")  end
					stdoutWrite(toStringBetter(k), "=")
					_printObject(v[k], printedTables, false)
					if firstLevel then  stdoutWrite("\n")  end
				end
			end

			for i = 1, #v do
				if firstLevel then  stdoutWrite("\t")  end
				stdoutWrite(i, "=")
				_printObject(v[i], printedTables, false)
				if firstLevel then  stdoutWrite("\n")  end
			end

			stdoutWrite("}")

		elseif vType == "number" then
			stdoutWrite(tostring(v))

		elseif vType == "string" then
			stdoutWrite('"', v:gsub("%z", "\\0"):gsub("\n", "\\n"), '"')

		else
			stdoutWrite(toStringBetter(v))
		end

		if not firstLevel then  stdoutWrite(" ")  end
	end

	function _G.printObject(...)
		for i = 1, select("#", ...) do
			if i > 1 then  stdoutWrite("\t")  end

			_printObject(select(i, ...), {}, true)
		end
		stdoutWrite("\n")
	end
end

function _G.logErrorTraceback(level, alsoPrint)
	log("stack traceback:")
	if alsoPrint then  io.stderr:write("stack traceback:", "\n")  end

	local stack = {}

	for level = 1+level, 1/0 do
		local info = debug.getinfo(level, "nSl")
		if not info then  break  end

		local sourceName = (info.source:match"^@(.+)" or info.short_src)
		local buffer     = {"\t"}

		table.insert(buffer, F("%s:", sourceName))

		if info.currentline > 0 then
			table.insert(buffer, F("%d:", info.currentline))
		end

		if (info.name or "") ~= "" then
			table.insert(buffer, F(" in '%s'", info.name))
		elseif info.what == "main" then
			table.insert(buffer, " in main chunk")
		elseif info.what == "C" or info.what == "tail" then
			table.insert(buffer, " ?")
		else
			table.insert(buffer, F(" in <%s:%d>", sourceName:gsub("^.*[/\\]", ""), info.linedefined))
		end

		table.insert(stack, table.concat(buffer))
	end

	while stack[#stack] == "\t[C]: ?" do
		stack[#stack] = nil
	end

	for _, s in ipairs(stack) do
		log(s)
		if alsoPrint then  io.stderr:write(s, "\n")  end
	end

	log("")
	if alsoPrint then  io.stderr:write("\n")  end
end



function _G.isFile(path)
	return lfs.attributes(path, "mode") == "file"
end

function _G.isDirectory(path)
	return lfs.attributes(path, "mode") == "directory"
end



_G.F = string.format

function _G.formatBytes(n)
	if     n >= !(1024^4/10) then  return F("%.2f TiB", n*!(1/1024^4))
	elseif n >= !(1024^3/10) then  return F("%.2f GiB", n*!(1/1024^3))
	elseif n >= !(1024^2/10) then  return F("%.2f MiB", n*!(1/1024^2))
	elseif n >= !(1024^1/10) then  return F("%.2f KiB", n*!(1/1024^1))
	else                           return F("%d bytes", n            )  end
end

function _G.formatTemplate(s, values)
	s = s:gsub(":([%a_][%w_]*):", function(k)
		if values[k] == nil then
			timestampPrintWarning("[formatTemplate] No value for :%s:.", k)
		else
			return tostring(values[k])
		end
	end)

	return unindent(s)
end



do
	_G.percentEncode = urlLib.escape

	local URI_PERCENT_CODES_TO_NOT_ENCODE = { -- AKA reserved characters (except non-ASCII characters).
		-- Note: These characters are explicitly unreserved and are thus never encoded
		-- in the first place: A-Z a-z 0-9 - _ . ~

		-- Note: This is similar to encodeURI() in JavaScript, except we also don't
		-- encode '[' and ']' (because of RFC 3986 which added those characters as
		-- reserved for IPv6 support).

		["%21"]="!",["%23"]="#",["%24"]="$",["%26"]="&",["%27"]="'",["%28"]="(",["%29"]=")",["%2a"]="*",
		["%2b"]="+",["%2c"]=",",["%2f"]="/",["%3a"]=":",["%3b"]=";",["%3d"]="=",["%3f"]="?",["%40"]="@",

		-- IPv6.
		["%5b"]="[",["%5d"]="]",

		-- Prevent double-encoding, because lots of URLs in text form everywhere
		-- already have %xx sequences. (We assume URLs don't have literal percent
		-- signs, which might be a problem in rare cases. However, we never return an
		-- incorrectly encoded URL. :EnsureValidPercentEncoding)
		["%25"]="%",

		-- Info:
		--   JavaScript's encodeURI()          does not encode: A-Z a-z 0-9 - _ . ! ~ * ' ( ) ; , / ? : @ & = + $ #
		--   JavaScript's encodeURIComponent() does not encode: A-Z a-z 0-9 - _ . ! ~ * ' ( )
	}

	-- This mostly just encodes non-ASCII characters (but also e.g. spaces).
	function _G.partialEncodeUrl(url)
		--
		-- :EnsureValidPercentEncoding
		-- Make sure all existing percent signs denote encoded characters before we do
		-- anything else. It's possible that this breaks some URLs in extremely rare
		-- cases (if the given URL is a bit ambiguous), but we have to assume properly
		-- percent-encoded characters already exist in many URLs.
		--
		url = url:gsub("%%([^%%]?[^%%]?)", function(hopefullyHex)
			if not hopefullyHex:find"^%x%x$" then
				return "%25"..hopefullyHex
			end
		end)

		return (urlLib.escape(url):gsub("%%%x%x", URI_PERCENT_CODES_TO_NOT_ENCODE))
	end

	function _G.fixRelativeUrl(url)
		url = url:gsub("^/%f[^/]", (site.baseUrl.v:gsub("^%w+://[^/]+", ""))) -- @Speed
		return url
	end

	function _G.fixRelativeUrlAndEncode(url)
		!ARGS "url:string"
		return (partialEncodeUrl(fixRelativeUrl(url)))
	end

	function _G.toAbsoluteAndEncodedUrl(url)
		!ARGS "url:string"
		url = url:gsub("^/%f[^/]", site.baseUrl.v)
		return (partialEncodeUrl(url))
	end

	--[[ TEST  @Cleanup: Include this in testsite (and add more URL encoding tests).
	_G.site      = {baseUrl={v="http://example.com/sub-folder/"}}
	local urlAbs = "http://example.com/some-path/File~With (Stuff_åäö).jpg?key=value&foo=bar#hash"
	local urlRel = "/images/cat.jpg"
	local result = percentEncode(urlAbs)                 ; print("PercentEncode", result) ; assert(result == "http%3a%2f%2fexample.com%2fsome-path%2fFile~With%20%28Stuff_%c3%a5%c3%a4%c3%b6%29.jpg%3fkey%3dvalue%26foo%3dbar%23hash")
	local result = partialEncodeUrl(urlAbs)              ; print("PartialEncode", result) ; assert(result == "http://example.com/some-path/File~With%20(Stuff_%c3%a5%c3%a4%c3%b6).jpg?key=value&foo=bar#hash")
	local result = partialEncodeUrl("cool%20any%%20run") ; print("BadUrl       ", result) ; assert(result == "cool%20any%25%20run")
	local result = fixRelativeUrlAndEncode(urlRel)       ; print("RelativeUrl  ", result) ; assert(result == "/sub-folder/images/cat.jpg")
	local result = toAbsoluteAndEncodedUrl(urlRel)       ; print("AbsoluteUrl  ", result) ; assert(result == "http://example.com/sub-folder/images/cat.jpg")
	os.exit(2)
	--]]
end

function _G.urlize(text)
	!ARGS "text:string"
	text = (
		text
		:gsub("[%p%s]+", "-")
		:gsub("^%-+",    "")
		:gsub("%-+$",    "")
		:lower()
	)
	return text == "" and "-" or text
end

function _G.urlToPrettyText(url)
	!ARGS "url:string"
	return (
		urlLib.unescape(url)
		:gsub("^https?://", "")
		:gsub("^www%.",     "")
		:gsub("/+$",        "")
		:gsub(" ",          "+") -- Because we unescaped all characters.
	)
end



function _G.getGeneratorHtmlMetaTag(hideVersion)
	return
		hideVersion
		and '<meta name="generator" content="LuaWebGen">'
		or  '<meta name="generator" content="LuaWebGen '..WEBGEN_VERSION..'">'
end



function _G.trim(s)
	s = s :gsub("^%s+", "") :gsub("%s+$", "")
	return s
end

function _G.trimNewlines(s)
	s = s :gsub("^\n+", "") :gsub("\n+$", "")
	return s
end



do
	local function formatValue(t, out, isDeep--[[, errLevel]])
		-- Note: We are not serializing - just pretty-printing!
		if isDeep and type(t) == "string" then
			table.insert(out, '"')
			table.insert(out, t)
			table.insert(out, '"')
			return

		elseif type(t) ~= "table" then
			table.insert(out, tostring(t))
			return
		end

		if protectionedObjects[t] then
			local fields = {}

			for k, field in pairs(protectionedObjects[t]) do
				if not k:find"^_" then
					fields[k] = (field.g or NOOP)(field)
				end
			end

			formatValue(fields, out, isDeep--[[, errLevel]])
			return
		end

		local keys = {}
		for k in pairs(t) do
			table.insert(keys, k)
		end
		sortNatural(keys)

		table.insert(out, "{")
		for i, k in ipairs(keys) do
			if i > 1 then  table.insert(out, ", ")  end
			table.insert(out, tostring(k))
			table.insert(out, "=")
			formatValue(t[k], out, true--[[, errLevel]])
		end
		table.insert(out, "}")
	end

	function _G.tostringForTemplates(v)
		local out = {}
		formatValue(v, out, false--[[, 3]])
		return (table.concat(out))
	end
end



-- array = sortNatural( array [, attribute ] )
do
	local function pad(numStr)
		return F("%03d%s", #numStr, numStr)
	end
	function _G.compareNatural(a, b)
		return (tostringForTemplates(a):gsub("%d+", pad) < tostringForTemplates(b):gsub("%d+", pad))
	end

	function _G.sortNatural(t, k)
		if k then
			table.sort(t, function(a, b)
				return compareNatural(a[k], b[k])
			end)
		else
			table.sort(t, compareNatural)
		end
		return t
	end
end



_G.dataParsers        = {}
_G.dataParserIsBinary = {}

-- dataParserIsBinary.html = false
-- function dataParsers.html(dataStr, path) -- Why would anyone use this? Just, why?
-- 	local doc, err = xmlLib.parseHtml(dataStr, maybeFullPath(path))
-- 	if not doc then  errorNoPos(err)  end
-- 	return doc
-- end

dataParserIsBinary.json = false
function dataParsers.json(dataStr, path)
	local v, err = jsonLib.parse(dataStr, maybeFullPath(path))
	if not v then  errorNoPos(err)  end
	return v
end

dataParserIsBinary.lua = false
function dataParsers.lua(dataStr, path)
	local chunk, err = loadstring(dataStr, "@"..maybeFullPath(path))
	if not chunk then  errorf(3, "Error loading Lua data file: %s", err)  end

	setfenv(chunk, scriptEnvironment)

	local dataObj = chunk()
	if dataObj == nil then
		errorf(3, "Lua data file returned nothing. (%s)", maybeFullPath(path))
	end

	return dataObj
end

dataParserIsBinary.toml = false
function dataParsers.toml(dataStr, path)
	local ok, tOrErr = pcall(tomlLib.parse, dataStr, {pathForErrors=maybeFullPath(path)})
	if not ok then  errorNoPos(tOrErr)  end
	return tOrErr
end

dataParserIsBinary.xml = false
function dataParsers.xml(dataStr, path)
	local doc, err = xmlLib.parseXml(dataStr, maybeFullPath(path))
	if not doc then  errorNoPos(err)  end
	return doc
end

dataParserIsBinary.svg  = false ; dataParsers.svg  = dataParsers.xml
-- dataParserIsBinary.htm  = false ; dataParsers.htm  = dataParsers.html
-- dataParserIsBinary.wlua = false ; dataParsers.wlua = dataParsers.lua -- A bit silly, really.

-- dataFolderReader = newDataFolderReader( directory [, isTop=false ] )
function _G.newDataFolderReader(dir, checkDirExistance)
	local dataFolderReader = {}

	setmetatable(dataFolderReader, {
		__index = function(dataFolderReader, k)
			if checkDirExistance then
				checkDirExistance = false

				if not isDirectory(dir) then
					errorf(2, "No data directory.")
				end
			end

			local dataObj

			if type(k) ~= "string" then
				return nil

			elseif k == "." or k == ".." then
				errorf(2, "Bad data key '%s'.", k)

			else
				local found = false

				for ext, dataParser in pairs(dataParsers) do
					local path = F("%s/%s.%s", dir, k, ext)

					if isFile(path) then
						found         = true
						local dataStr = assert((dataParserIsBinary[ext] and getFileContentsBinary or getFileContentsText)(path))

						!PUSH_CONTEXT "none"
							dataObj = dataParser(dataStr, path)
						!POP_CONTEXT()

						if dataObj == nil then
							errorf(2, "Data parser for '%s' files returned nothing. (%s)", ext, maybeFullPath(path))
						end

						break
					end
				end

				if found then
					-- void
				elseif isDirectory(F("%s/%s", dir, k)) then
					dataObj = newDataFolderReader(F("%s/%s", dir, k))
				else
					timestampPrintWarningOnce("Bad data path '%s/%s'.", dir, k)
					return nil
				end
			end

			assert(dataObj ~= nil)
			rawset(dataFolderReader, k, dataObj)
			return dataObj
		end,
	})

	dataReaderPaths[dataFolderReader] = dir
	return dataFolderReader
end

function _G.isDataFolderReader(t)
	return dataReaderPaths[t] ~= nil
end

-- dataFolderReader = preloadData( dataFolderReader )
function _G.preloadData(dataFolderReader)
	if dataIsPreloaded[dataFolderReader] then  return dataFolderReader  end

	for filename in lfs.dir(dataReaderPaths[dataFolderReader]) do
		if not (filename == "." or filename == "..") then
			local path     = dataReaderPaths[dataFolderReader] .. "/" .. filename
			local basename = getBasename(filename)

			if
				not rawget(dataFolderReader, basename)
				and indexOf(DATA_FILE_EXTENSIONS, getExtension(filename))
				and (
					-- Not sure these ignore* checks belong here. Seems like a mistake. 2021-04-27
					(isFile(path)      --[[and not (site._ignoreFiles  [1] and isStringMatchingAnyPattern(filename, site._ignoreFiles  ))]]) or
					(isDirectory(path) --[[and not (site._ignoreFolders[1] and isStringMatchingAnyPattern(filename, site._ignoreFolders))]])
				)
			then
				local _ = dataFolderReader[basename]
			end
		end
	end

	dataIsPreloaded[dataFolderReader] = true
	return dataFolderReader
end



-- scriptFolderReader = newScriptFolderReader( directory )
function _G.newScriptFolderReader(dir)
	local scriptFolderReader = {}

	setmetatable(scriptFolderReader, {
		__index = function(scriptFolderReader, k)
			local scriptObj

			if type(k) ~= "string" then
				return nil

			elseif k == "." or k == ".." then
				errorf(2, "Bad script key '%s'.", k)

			elseif isFile(F("%s/%s.lua", dir, k)) then
				local path = F("%s/%s.lua", dir, k)

				local main_chunk, err = loadLuaFile(path, scriptEnvironment)
				if not main_chunk then  error(err, 2)  end

				scriptObj = main_chunk()
				if type(scriptObj) ~= "function" then
					errorNoPos("%s did not return a function.", maybeFullPath(path))
				end

			elseif isDirectory(F("%s/%s", dir, k)) then
				scriptObj = newScriptFolderReader(F("%s/%s", dir, k))

			else
				errorf(2, "Bad script path '%s/%s'.", dir, k)
			end

			assert(scriptObj ~= nil)
			rawset(scriptFolderReader, k, scriptObj)
			return scriptObj
		end,
	})

	scriptReaderPaths[scriptFolderReader] = dir
	return scriptFolderReader
end

function _G.isScriptFolderReader(t)
	return scriptReaderPaths[t] ~= nil
end

-- scriptFolderReader = preloadScripts( scriptFolderReader )
function _G.preloadScripts(scriptFolderReader)
	if scriptIsPreloaded[scriptFolderReader] then  return scriptFolderReader  end

	for filename in lfs.dir(scriptReaderPaths[scriptFolderReader]) do
		if filename:find"%.lua$" then
			local path     = scriptReaderPaths[scriptFolderReader] .. "/" .. filename
			local basename = getBasename(filename)

			if not rawget(scriptFolderReader, basename) and isFile(path) then
				local _ = scriptFolderReader[basename]
			end
		end
	end

	scriptIsPreloaded[scriptFolderReader] = true
	return scriptFolderReader
end



function _G.getProtectionWrapper(obj, objName)
	!ARGS "obj:table objName:string"

	local wrapper = protectionWrappers[obj]
	if wrapper then  return wrapper  end

	wrapper = setmetatable({}, {
		__index = function(wrapper, k)
			local field = obj[k]

			if field == nil or k:find"^_" then
				errorf(2, "Tried to get non-existent %s field '%s'.", objName, tostring(k))
			elseif not field.g then
				errorf(2, "[internal] No getter for %s.%s", objName, k)
			end

			return (field:g())
		end,

		__newindex = function(wrapper, k, vNew)
			local field = obj[k]

			if field == nil or k:find"^_" then
				errorf(2, "'%s' is not a valid %s field.", tostring(k), objName)
			elseif not field.s or obj._readonly then
				errorf(2, "Cannot update read-only field %s.%s", objName, k)
			end

			local vOld = field.v

			if type(vNew) ~= type(vOld) then
				errorf(
					2, "Expected %s for %s.%s, but got %s. (%s)",
					type(vOld), objName, k, type(vNew), tostring(vNew)
				)
			end

			field:s(vNew)
		end,
	})

	protectionWrappers[obj]      = wrapper
	protectionedObjects[wrapper] = obj

	return wrapper
end



function _G.toNormalPath(osPath)
	local path = osPath:gsub("\\", "/")
	return path
end

function _G.toWindowsPath(path)
	local winPath = path:gsub("/", "\\")
	return winPath
end



function _G.getDirectory(genericPath)
	return (genericPath:gsub("/?[^/]+$", ""))
end

function _G.getFilename(genericPath)
	return genericPath:match"[^/]+$"
end

function _G.getExtension(filename)
	return filename:match"%.([^.]+)$" or ""
end

function _G.getBasename(filename)
	local ext = getExtension(filename)
	if ext == "" then  return filename  end

	return filename:sub(1, #filename-#ext-1)
end



-- generateFromTemplateString( page, template, modificationTime=now, onPageInit=nil )
-- onPageInit = function( wrappedPage )
function _G.generateFromTemplateString(page, template, modTime, onPageInit)
	assert(type(page)     == "table")
	assert(type(template) == "string")

	if page._isGenerated then
		errorf(2, "Page has already generated. (%s)", maybeFullPath(page._path))
	end
	if page._isGenerating or site._pagesGenerating[page._pathOut] then
		errorf(2, "Recursive page generation detected. (You may want to call lock() in '%s')", maybeFullPath(page._path))
	end

	page._isGenerating                   = true
	site._pagesGenerating[page._pathOut] = true

	local pathRel  = page._path
	local filename = getFilename(pathRel)
	local ext      = getExtension(filename)
	local extLower = ext:lower()

	timestampPrintVerbose("--> Processing(start): %s", maybeFullPath(page._path))
	local result

	if page.isPage.v then
		local pageContent = parseAndRunTemplate(page, page._pathForError, template, nil, false, onPageInit, nil)

		page._isLocked = true
		page._readonly = true

		if
			(page.isDraft.v and not includeDrafts          ) or -- Is draft?
			(datetimeToTime(page.publishDate:g()) > nowTime)    -- Is in future?
		then
			timestampPrintVerbose("--> Processing(abort): %s", maybeFullPath(page._path))

			page._isSkipped                  = true
			site._outputFileSkippedPageCount = site._outputFileSkippedPageCount + 1

			page._isGenerating                   = false
			site._pagesGenerating[page._pathOut] = nil
			return
		end

		if not (page.isIndex.v or page.isSpecial.v) and not page._dateHasBeenUpdated then
			-- @UX: Should there be an option to disable this? Maybe an option for suppressing all warnings?
			timestampPrintWarning("%s did not update page.date.", maybeFullPath(page._path))
		end

		page.content.v           = pageContent
		page._contentIsAvailable = true

		if page.layout.v == "" then
			result = pageContent
		else
			local layoutTemplate, layoutPath = getLayoutTemplate(page)
			result                           = parseAndRunTemplate(page, layoutPath, layoutTemplate, "html", true, nil, nil)
		end

	else
		page._isLocked = true
		page._readonly = true

		result = parseAndRunTemplate(page, page._pathForError, template, nil, false, onPageInit, nil)
	end

	timestampPrintVerbose("--> Processing(finish): %s", maybeFullPath(page._path))

	writeOutputFile(page._category, page._pathOut, page.url.v, result, modTime, page._path)
	page._isGenerated = true

	page._isGenerating                   = false
	site._pagesGenerating[page._pathOut] = nil
end

-- generateFromTemplateFile( page )
-- Does nothing for skipped pages, or pages that are currently generating but are safely locked.
function _G.generateFromTemplateFile(page)
	if page._isSkipped then  return  end
	if page._isGenerating and page._isLocked then  return  end -- Allowed recursion.

	local path     = DIR_CONTENT.."/"..page._path
	local template = assert(getFileContentsText(path))
	local modTime  = lfs.attributes(path, "modification")

	if modTime then
		page.date.v = getDatetime(modTime) -- Default value. Also affects dateModified and publishDate if those fields aren't updated by the user.
	end

	generateFromTemplateString(page, template, modTime, nil)
end

function _G.generateRedirection(url, targetUrl, sourcePath)
	!ARGS "url,targetUrl,sourcePath:string"

	if not url:find"^/" then
		errorNoPos("Redirection URLs must begin with '/'. (%s)", url)
	elseif url:find("#", 1, true) then
		errorNoPos("Redirection URLs cannot have fragments. (%s)", url)
	end

	if url:find("?", 1, true) or not url:find"/$" then
		if site._unwrittenRedirects[url] == targetUrl then
			timestampPrintWarning("Duplicate redirect from '%s' to '%s'.", url, targetUrl)
			return
		elseif site._unwrittenRedirects[url] then
			errorNoPos("Duplicate redirect from '%s' (to different targets).", url)
		end

		site._unwrittenRedirects[url] = targetUrl
		return
	end

	-- @Copypaste from above.
	if site._writtenRedirects[url] == targetUrl then
		timestampPrintWarning("Duplicate redirect from '%s' to '%s'.", url, targetUrl)
		return
	elseif site._writtenRedirects[url] then
		errorNoPos("Duplicate redirect from '%s' (to different targets).", url)
	end

	if site._redirectionLayout ~= "" then
		--
		-- We're doing things a bit backwards here with the page's path
		-- because we don't have a real source page file and thus no source
		-- path. We have to trick the system to do what we want. @Cleanup
		--
		-- Example:
		--   If the URL is          /blog/post1/
		--   then we want to write  /blog/post1/index.html
		--   so the path must be    /blog/post1.html
		--
		-- Note that the output path may still get rewritten before the
		-- writing, but that doesn't concern us because URLs are determined
		-- from unrewritten paths.
		--
		local pathRel = url:gsub("/?$", ".html", 1):gsub("^/", "")
		local page    = newPage(pathRel, true)

		page.layout.v            = site._redirectionLayout
		page.redirectionTarget.v = targetUrl

		generateFromTemplateString(page, "", nil, nil) -- The content for this super special page is always empty - we only want to process the layout!

	else
		local contents = formatTemplate(
			[=[
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="utf-8">
						<meta name="robots" content="noindex, follow">
						<meta http-equiv="refresh" content="3; url=:urlAbsPercent:">
						<title>:urlPretty:</title>
					</head>
					<body>
						<p>Page has moved. If you are not redirected automatically,
						click <a href=":urlAbsPercent:">here</a>.</p>
					</body>
				</html>
			]=], {
				urlPretty     = encodeHtmlEntities(urlToPrettyText        (targetUrl)),
				urlAbsPercent = encodeHtmlEntities(toAbsoluteAndEncodedUrl(targetUrl)),
			}
		)

		local pathRel = url:gsub("/?$", "/index.html", 1):gsub("^/", "")
		writeOutputFile("page", pathRel, url, contents, nil, sourcePath)
	end

	site._writtenRedirects[url] = targetUrl
end



function _G.generateNonPages()
	for _, page in ipairs(site._nonPagePages) do
		if not page._isGenerated then
			generateFromTemplateFile(page) -- Note that this template may trigger generation of actual pages at some point before it finishes (e.g. by calling subpages()).
		end
	end
end



function _G.indexOf(t, v)
	for i, item in ipairs(t) do
		if item == v then  return i  end
	end
	return nil
end

function _G.itemWith(t, k, v)
	for i, item in ipairs(t) do
		if item[k] == v then  return item, i  end
	end
	return nil
end

function _G.itemWithAll(t, k, v)
	local items = {}
	for _, item in ipairs(t) do
		if item[k] == v then  table.insert(items, item)  end
	end
	return items
end



-- html = encodeHtmlEntities( text )
_G.encodeHtmlEntities = xmlLib.encodeRequiredEntities

-- html = markdownToHtml( markdown )
_G.markdownToHtml = markdownLib

function _G.doesValueLookLikeHtml(v)
	return type(v) == "string" and v:find!(NOSPACE"^ %s* < [!%a/] .* > %s* $") ~= nil
end



function _G.pack(...)
	return {n=select("#", ...), ...}
end



-- template, path = getLayoutTemplate( page )
function _G.getLayoutTemplate(page)
	local path = F("%s/%s.html", DIR_LAYOUTS, page.layout.v)

	local template = site._layoutTemplates[path]
	if template then  return template, path  end

	local template, err = getFileContentsText(path)
	if not template then
		errorf("%s: Could not load layout '%s'. (%s)", maybeFullPath(page._path), page.layout.v, err)
	end

	site._layoutTemplates[path] = template
	return template, path
end



-- parts = splitString( string, separatorPattern [, startIndex=1, plain=false ] )
function _G.splitString(s, sep, i, plain)
	i = i or 1
	local parts = {}

	while true do
		local i1, i2 = s:find(sep, i, plain)
		if not i1 then  break  end

		table.insert(parts, s:sub(i, i1-1))
		i = i2+1
	end

	table.insert(parts, s:sub(i))
	return parts
end



function _G.datetimeToTime(datetime)
	!ARGS "datetime:string"

	local date = dateLib(datetime)
	local time = (date-dateLib.epoch()):spanseconds()

	return time
end

-- datetime = getDatetime( [ time=now ] )
function _G.getDatetime(time)
	!ARGS "? time:number"

	local date     = dateLib(time or nowTime):tolocal()
	local datetime = date:fmt"${iso}%z" :gsub("..$", ":%0") :gsub("%+00:00$", "Z")

	return datetime
end



function _G.unindent(s)
	local indent = s:match"^\t+"
	if indent then
		s = s
			:gsub("\n"..indent, "\n")
			:sub(#indent+1)
			:gsub("\t+$", "")
	end

	return s
end



local contextMetatable = {__index=_G}

-- context = pushContext( contextName, chunk )
-- chunk   = function( context )
function _G.pushContext(ctxName, chunk)
	local ctx = setmetatable({_name=ctxName, _scriptEnvironmentGlobals={}}, contextMetatable)
	setfenv(chunk, ctx)
	return ctx
end

local function _assertContext(ctx, ctxName, funcContext, errLevel)
	if type(ctxName) == "table" then
		if not (ctx and isAny(ctx._name, unpack(ctxName))) then
			if funcContext then
				errorf(1+errLevel, "[%s] Context is wrong. (Expected '%s', but is '%s')", funcContext, table.concat(ctxName, "' or '"), (ctx and ctx._name or "none"))
			else
				errorf(1+errLevel,      "Context is wrong. (Expected '%s', but is '%s')",              table.concat(ctxName, "' or '"), (ctx and ctx._name or "none"))
			end
		end
	else
		if not (ctx and ctx._name == ctxName) then
			if funcContext then
				errorf(1+errLevel, "[%s] Context is wrong. (Expected '%s', but is '%s')", funcContext, ctxName, (ctx and ctx._name or "none"))
			else
				errorf(1+errLevel,      "Context is wrong. (Expected '%s', but is '%s')",              ctxName, (ctx and ctx._name or "none"))
			end
		end
	end
end

-- assertContext( contextName  [, functionContext, errorLevel=2 ] )
-- assertContext( contextNames [, functionContext, errorLevel=2 ] )
function _G.assertContext(ctxName, funcContext, errLevel)
	errLevel = 1 + (errLevel or 2)
	_assertContext(getContext(), ctxName, funcContext, errLevel)
end

-- context = getContext( [ requiredContextName=any  ] )
-- context = getContext( [ requiredContextNames=any ] )
function _G.getContext(ctxName)
	for level = 3, 1/0 do -- Assume the caller is a webgen function, so start at level 3.
		if not debug.getinfo(level, "") then  break  end

		-- Note: We shouldn't reach an invalid level because pretty much the
		-- whole program runs in a 'none' context. However, if a level is a
		-- tail call then getfenv() will raise an error.
		local ok, ctx = pcall(getfenv, level)
		if not ok then  ctx = nil  end

		if isContext(ctx) then
			if ctxName then  _assertContext(ctx, ctxName, nil, 2)  end
			return ctx
		end
	end

	error("Internal error: There is no context.", 2)
end

function _G.isContext(v)
	return getmetatable(v) == contextMetatable
end



-- thumbnailInfo = createThumbnail( imagePathRelative, thumbWidth [, thumbHeight, errorLevel=1 )
do
	local imageCreatorMethods = {
		["png"]  = "pngStr",
		["jpg"]  = "jpegStr",
		["jpeg"] = "jpegStr",
		["gif"]  = "gifStr",
	}

	function _G.createThumbnail(pathImageRel, thumbW, thumbH, errLevel)
		thumbW   = thumbW or 0
		thumbH   = thumbH or 0
		errLevel = 1 + (errLevel or 1)

		local gd = pcall(require, "gd") and require"gd" or nil

		if not gd then
			error("Failed loading Lua-GD.", errLevel)
		elseif thumbW == 0 and thumbH == 0 then
			error("Thumbnail images must have at least a width or a height.", errLevel)
		end

		local id = F("%s:%dx%d", pathImageRel, thumbW, thumbH)
		if site._thumbnailInfos[id] then
			return site._thumbnailInfos[id]
		end

		local filename  = getFilename(pathImageRel)
		local basename  = getBasename(filename)
		local ext       = getExtension(filename)
		local extLower  = ext:lower()
		local folder    = pathImageRel:sub(1, #pathImageRel-#filename) -- Ending in "/".
		local pathImage = DIR_CONTENT.."/"..pathImageRel

		local image, err = loadImage(pathImageRel)
		if not image then
			error(err, errLevel)
		end

		local imageW, imageH = image:sizeXY()
		assert(imageW > 0)
		assert(imageH > 0)
		local aspectRatio = imageW/imageH

		if thumbW == 0 then
			thumbW = round(thumbH*aspectRatio)
		elseif thumbH == 0 then
			thumbH = round(thumbW/aspectRatio)
		end
		thumbW = math.max(thumbW, 1)
		thumbH = math.max(thumbH, 1)

		local pathThumbRel = F("%s%s.%dx%d.%s", folder, basename, thumbW, thumbH, "jpg")--ext)

		local thumbInfo = {
			path   = pathThumbRel,
			width  = thumbW,
			height = thumbH,
		}

		local pathThumbOutputRel = rewriteOutputPath(pathThumbRel)

		local modTimeImage = lfs.attributes(pathImage, "modification")
		local modTimeThumb = lfs.attributes(DIR_OUTPUT.."/"..pathThumbOutputRel, "modification")

		if modTimeImage and modTimeImage == modTimeThumb and not ignoreModificationTimes then
			-- Note: This will bypass any file processor for JPG files. Not sure if OK. 2018-06-30 @Consistency
			preserveExistingOutputFile("raw", pathThumbRel, "/"..pathThumbRel, pathImageRel)

		else
			local scale = math.min(imageW/thumbW, imageH/thumbH)

			local thumb = gd.createTrueColor(thumbW, thumbH)
			thumb:copyResampled(
				image,
				0, -- dstX
				0, -- dstY
				round((imageW-thumbW*scale)/2), -- srcX
				round((imageH-thumbH*scale)/2), -- srcY
				thumbW, -- dstW
				thumbH, -- dstH
				round(thumbW*scale), -- srcW
				round(thumbH*scale)  -- srcH
			)

			local imageCreatorMethod = "jpegStr"--assert(imageCreatorMethods[extLower], extLower)
			local contents = thumb[imageCreatorMethod](thumb, 75)
			writeOutputFile("raw", pathThumbRel, "/"..pathThumbRel, contents, modTimeImage, pathImageRel)
		end

		site._thumbnailInfos[id] = thumbInfo
		return thumbInfo
	end

end



function _G.round(n)
	return math.floor(n+.5)
end



-- builder = newStringBuilder( )
do
	local mt = {
		__call = function(b, ...)
			local argCount = select("#", ...)
			if argCount == 0 then  return table.concat(b)  end

			local s = (argCount == 1) and tostring(...) or F(...)
			table.insert(b, s)
		end,
	}

	function _G.newStringBuilder()
		return setmetatable({}, mt)
	end
end



function _G.newSite()
	return {
		_readonly = true,

		-- Settings.
		_ignoreFiles                = {--[[ filenamePattern1, ... ]]},
		_ignoreFolders              = {--[[ filenamePattern1, ... ]]},
		_ignorePaths                = {--[[ pathPattern1, ... ]]},

		_fileTypes                  = {["md"]="markdown", ["markdown"]="markdown", ["html"]="html", ["htm"]="html", ["xml"]="xml", ["css"]="othertemplate"},
		_fileProcessors             = {--[[ [extension1]=function(data, sitePath), ... ]]},

		_htaErrors                  = {--[[ [httpStatusCode1]=document1, ... ]]},

		_outputPathFormat           = "%s",
		_rewriteExcludes            = {--[[ pathPattern1, ... ]]},

		_autoLockPages              = false,
		_noTrailingSlash            = false,

		_redirectionLayout          = "",
		--

		-- Other values.
		_layoutTemplates            = {--[[ [path1]=template1, ... ]]},

		_scripts                    = newScriptFolderReader(DIR_SCRIPTS),

		_pages                      = {--[[ page1, ... ]]}, -- Page with isPage==true.
		_nonPagePages               = {--[[ page1, ... ]]}, -- Page with isPage==false.
		_pagesGenerating            = {--[[ [pathRelOut1]=true, ... ]]},

		_writtenOutputEntries       = {--[[ { path=pathRel1, pathOut=pathOutputRel1, url=url1 }, ... ]]},
		_writtenOutputFiles         = {--[[ [pathOutputRel1]=sourcePath1, pathOutputRel1, ... ]]},
		_writtenOutputUrls          = {--[[ [url1]=true,                  url1,           ... ]]},
		_writtenRedirects           = {--[[ [url1]=targetUrl1, ... ]]},
		_unwrittenRedirects         = {--[[ [url1]=targetUrl1, ... ]]}, -- We use this for redirection of special URLs in .htaccess (e.g. URLs with queries).
		_outputFileCount            = 0,
		_outputFileCounts           = {--[[ [category1]=count1, ... ]]},
		_outputFileByteCount        = 0,
		_outputFilePreservedCount   = 0, -- This should only count raw files. @Cleanup: Maybe rename the variable?
		_outputFileSkippedPageCount = 0,

		_thumbnailInfos             = {--[[ [thumbIdString1]={ path=thumbPathRel, width=thumbWidth, height=thumbHeight }, ... ]]},
		--

		title = {
			v = "",
			g = function(field)  return field.v  end,
		},
		description = {
			v = "",
			g = function(field)  return field.v  end,
		},
		baseUrl = {
			v = "",
			g = function(field)  return field.v  end,
		},
		languageCode = {
			v = "",
			g = function(field)  return field.v  end,
		},
		defaultLayout = {
			v = "page",
			g = function(field)  return field.v  end,
		},

		redirections = {
			v = {--[[ [url1]=targetUrl1, ... ]]},
			g = function(field)  return field.v  end,
		},
	}
end

do
	local function removeIndexFilename(pathRel)
		local sitePath = pathToSitePath(pathRel) :gsub("/index%.[^./]+$", "/")
		return (sitePathToPath(sitePath, 2))
	end

	function _G.newPage(pathRel, isRedirection)
		!ARGS "pathRel:string isRedirection:boolean"

		local filename = getFilename(pathRel)
		local ext      = getExtension(filename)
		local extLower = ext:lower()

		if not site._fileTypes[extLower] then
			errorf("Invalid template extension '%s'. (You may want to specify config.types[\"%s\"])", extLower, extLower)
		end

		local isPage  = isAny(site._fileTypes[extLower], "markdown","html")
		local isIndex = isPage  and getBasename(filename) == "index" and not isRedirection
		local isHome  = isIndex and pathRel == filename

		local category = isPage and "page" or "template"

		local permalinkRel = (
			not isPage and pathRel
			or isHome  and ""
			or isIndex and pathRel:sub(1, -#filename-1)
			or pathRel:sub(1, -#ext-2) .. "/"
		)

		local pathRelOut = (not isPage and permalinkRel or permalinkRel.."index.html")

		local isSpecial = (
			not isPage
			or isRedirection
			or attributeWithAny(site._htaErrors,
				-- Doing all these tests may be overkill. :ApacheErrorDocumentFile
				"/"..permalinkRel,
				"/"..pathRelOut,
				"/"..rewriteOutputPath(pathRelOut),
				"/"..removeIndexFilename(rewriteOutputPath(pathRelOut))
			) ~= nil
		)

		local page; page = {
			_readonly = false,

			_category           = category,
			_isGenerating       = false,
			_isGenerated        = false,
			_isSkipped          = false,
			_isLocked           = false, -- @Cleanup: Is this always synced with _readonly? If so, just remove _isLocked.
			_contentIsAvailable = false,
			_dateHasBeenUpdated = false,
			_path               = pathRel,
			_pathOut            = pathRelOut,
			_pathForError       = maybeFullPath(F("%s/%s", DIR_CONTENT, pathRel)),
			_extension          = extLower,

			isPage = {
				v = isPage,
				g = function(field)  return field.v  end,
			},
			isIndex = {
				v = isIndex,
				g = function(field)  return field.v  end,
			},
			isHome = {
				v = isHome,
				g = function(field)  return field.v  end,
			},

			layout = {
				v = site.defaultLayout.v,
				g = function(field)  return field.v  end,
				s = function(field, layoutName)  field.v = layoutName  end,
			},
			title = { -- All pages should update this!
				v = "",
				g = function(field)  return field.v  end,
				s = function(field, title)  field.v = title  end,
			},
			description = {
				v = "",
				g = function(field)  return field.v  end,
				s = function(field, description)  field.v = description  end,
			},
			content = {
				v = "",
				g = function(field)
					if page._contentIsAvailable then
						return field.v
					elseif not page.isPage.v then
						errorf(3, "page.content isn't available for non-page templates. (%s)", page._pathForError)
					else
						errorf(3, "page.content isn't available (probably because the page hasn't finished generating). (%s)", page._pathForError)
					end
				end,
			},

			date = {
				v = getDatetime(0),
				g = function(field)  return field.v  end,
				s = function(field, datetime)  field.v = datetime ; page._dateHasBeenUpdated = true  end,
			},
			dateModified = { -- This field currently isn't used anywhere internally - it just exists for the user's convenience. 2021-05-19
				v = "",
				g = function(field)  return field.v ~= "" and field.v or page.date.v  end,
				s = function(field, datetime)  field.v = datetime  end,
			},
			publishDate = {
				v = "",
				g = function(field)  return field.v ~= "" and field.v or page.date.v  end,
				s = function(field, datetime)  field.v = datetime  end,
			},
			isDraft = {
				v = false,
				g = function(field)  return field.v  end,
				s = function(field, state)  field.v = state  end,
			},
			isSpecial = {
				v = isSpecial,
				g = function(field)  return field.v  end,
				s = function(field, state)  field.v = state  end,
			},

			aliases = {
				v = {},
				g = function(field)  return page._readonly and {unpack(field.v)} or field.v  end,
				s = function(field, aliases)  field.v = aliases  end,
			},

			url = {
				v = "/" .. (site._noTrailingSlash and permalinkRel:gsub("/$", "") or permalinkRel),
				g = function(field)  return field.v  end,
			},
			permalink = {
				v = site.baseUrl.v .. (site._noTrailingSlash and permalinkRel:gsub("/$", "") or permalinkRel),
				g = function(field)  return field.v  end,
			},
			redirectionTarget = {
				v = "",
				g = function(field)  return field.v  end,
			},

			params = {
				v = {},
				g = function(field)  return field.v  end,
			},
		}

		!if DEV and 1==0 then
			printf("%-30s  %-1s  %s", pathRel, (not isPage and "" or isHome and "H" or isIndex and "I" or "P"), page.permalink.v)
		!end

		return page
	end
end



function _G.pathToSitePath(pathRel)
	if pathRel:find"^/" then
		errorf(2, "Path is not valid: %s", pathRel)
	end
	return "/"..pathRel
end

-- sitePathToPath( sitePath, errorLevel=1 )
function _G.sitePathToPath(sitePath, errLevel)
	if not sitePath:find"^/" then
		errLevel = 1 + (errLevel or 1)
		errorf(errLevel, "Path is not a valid site path - they must start with '/': %s", sitePath)
	end
	return (sitePath:gsub("^/", ""))
end



-- Return any data as a Lua code string.
-- luaString = serializeLua( value )
do
	local SIMPLE_TYPES = {["boolean"]=true,["nil"]=true,["number"]=true}
	local KEYWORDS = {
		["and"]=true,["break"]=true,["do"]=true,["else"]=true,["elseif"]=true,
		["end"]=true,["false"]=true,["for"]=true,["function"]=true,["if"]=true,
		["in"]=true,["local"]=true,["nil"]=true,["not"]=true,["or"]=true,["repeat"]=true,
		["return"]=true,["then"]=true,["true"]=true,["until"]=true,["while"]=true,
	}

	local function _serializeLua(out, data)
		local dataType = type(data)

		if dataType == "table" then
			local first   = true
			local i       = 0
			local indices = {}

			local insert = table.insert
			insert(out, " { ")

			while true do
				i = i+1

				if data[i] == nil then
					i = i+1
					if data[i] == nil then  break  end

					if not first then  insert(out, ",")  end
					insert(out, "nil")
					first = false
				end

				if not first then  insert(out, ",")  end
				first = false

				_serializeLua(out, data[i])
				indices[i] = true
			end

			for k, v in pairs(data) do
				if not indices[k] then
					if not first then  insert(out, ",")  end
					first = false

					if not KEYWORDS[k] and type(k) == "string" and k:find"^[a-zA-Z_][a-zA-Z0-9_]*$" then
						insert(out, k)
					else
						insert(out, "[")
						_serializeLua(out, k)
						insert(out, "]")
					end

					insert(out, "=")
					_serializeLua(out, v)
				end
			end

			insert(out, " } ")

		elseif dataType == "string" then
			table.insert(out, F("%q", data))

		elseif SIMPLE_TYPES[dataType] then
			table.insert(out, tostring(data))

		else
			errorf("Cannot serialize value type '%s'. (%s)", dataType, tostring(data))
		end

		return out
	end

	function _G.serializeLua(data)
		return (table.concat(_serializeLua({}, data)))
	end

end



function _G.getKeys(t)
	local keys = {}
	for k in pairs(t) do  table.insert(keys, k)  end
	return keys
end



function _G.urlExists(url)
	-- @Robustness: A URL may not exist yet, but will soon. Should we only allow calling this in config.validate (and maybe config.after)?
	if not url:find"^/" then
		errorf(2, "Local URLs must begin with '/'. (%s)", url)
	end
	return site._writtenOutputUrls[url] == true
end



-- bool = isAny( valueToCompare, value1, ... )
function _G.isAny(v, ...)
	for i = 1, select("#", ...) do
		if v == select(i, ...) then  return true  end
	end
	return false
end



function _G.rewriteOutputPath(pathRel)
	local sitePath = pathToSitePath(pathRel)

	for _, pat in ipairs(site._rewriteExcludes) do
		if sitePath:find(pat) then  return pathRel  end
	end

	if type(site._outputPathFormat) == "function" then
		local sitePathNew
		!PUSH_CONTEXT "none"
			local rewriteOutputPath_callback = site._outputPathFormat -- :BetterTraceback
			sitePathNew                      = rewriteOutputPath_callback(sitePath)
		!POP_CONTEXT()

		if type(sitePathNew) ~= "string" then
			errorf("config.rewriteOutputPath() did not return a string. (%s)", sitePath)
		elseif sitePathNew == "" then
			errorf("config.rewriteOutputPath() returned an empty string. (%s)", sitePath)
		end

		return (sitePathToPath(sitePathNew, 2))

	else
		return (sitePathToPath(F(site._outputPathFormat, sitePath), 2))
	end
end



-- removeItem( array, value1, ... )
-- @Incomplete: Change into this: anythingGotRemoved = removeItem( array, value1, ... )
function _G.removeItem(t, ...)
	for i = 1, select("#", ...) do
		local iToRemove = indexOf(t, select(i, ...))

		if iToRemove then  table.remove(t, iToRemove)  end
	end
end



-- Same as string.gsub(), but "%" has no meaning in the substitution.
function _G.gsubPlainSub(s, pat, repl)
	return s:gsub(pat, (repl:gsub("%%", "%%%%")))
end

do
	-- for position, isMatch, capture1, ... in gmatchAndBetween( string, pattern )
	-- If isMatch is false then capture1 is the string between the last match and the next. (This string will never be empty.)
	function _G.gmatchAndBetween(s, pat)
		local nextPos = 1
		local i1, i2  = nil

		return function()
			if nextPos > #s then  return  end

			local pos = nextPos

			if not i1 then
				i1, i2 = s:find(pat, pos)
				i1     = i1 or #s+1
			end

			if i1 == pos then
				nextPos = math.max(i2, pos) + 1
				i1      = nil
				return pos, true, s:match(pat, pos)
			else
				nextPos = i1
				-- Cache i1 for the next call.
				return pos, false, s:sub(pos, nextPos-1)
			end
		end
	end

	--[[ TEST
	!local FOR    = "local i = 0 ; for"
	!local ASSERT = "i = i+1 ; assert(i < 10)"

	!!(FOR) pos, isMatch, s in gmatchAndBetween("Hello foofoo! How's the foobar?", "foo") do
		print("1>", pos, isMatch, s)
		!!(ASSERT)
	end
	!!(FOR) pos, isMatch, s in gmatchAndBetween("foo", "foo") do
		print("2>", pos, isMatch, s)
		!!(ASSERT)
	end
	!!(FOR) pos, isMatch, s in gmatchAndBetween("f", "foo") do
		print("3>", pos, isMatch, s)
		!!(ASSERT)
	end
	!!(FOR) pos, isMatch, s in gmatchAndBetween("", "foo") do
		print("4>", pos, isMatch, s)
		assert(false)
	end
	!!(FOR) pos, isMatch, s in gmatchAndBetween("foo", "f?") do
		print("5>", pos, isMatch, s)
		!!(ASSERT)
	end

	print("DONE")
	os.exit(2)
	--]]
end



function _G.htaccessRewriteEscapeTestString(s)
	s = s:gsub('[$%%\\"]', "\\%0")

	return s
end

function _G.htaccessRewriteEscapeCondPattern(s, isStart)
	s = s:gsub('[$%%\\".+*?^()[%]]', "\\%0")

	if isStart then  s = s:gsub("^[-!=<>]", "\\%0")  end

	return s
end

function _G.htaccessRewriteEscapeRuleSubstitution(s, isWhole)
	if isWhole and s == "-" then  return "\\-"  end

	return (s:gsub('[$%%\\"]', "\\%0"))
end



-- Compute the difference in seconds between local time and UTC. (Normal time.)
-- http://lua-users.org/wiki/TimeZone
function _G.getTimezone()
	return os.difftime(nowTime, os.time(os.date("!*t", nowTime)))
end

-- Return a timezone string in ISO 8601:2000 standard form (+hhmm or -hhmm).
function _G.getTimezoneOffsetString(tz)
	local h, m = math.modf(tz/3600)
	return F("%+.4d", 100*h+60*m)
end

-- Return the timezone offset in seconds, as it was on the given time. (DST obeyed.)
-- timezoneOffset = getTimezoneOffset( [ time=now ] )
function _G.getTimezoneOffset(time)
	time            = time or nowTime
	local dateUtc   = os.date("!*t", time)
	local dateLocal = os.date("*t",  time)
	dateLocal.isdst = false -- This is the trick.
	return os.difftime(os.time(dateLocal), os.time(dateUtc))
end



function _G.isArgs(...)
	return select("#", ...) > 0
end



function _G.cleanupPath(someKindOfPath)
	local path = toNormalPath(someKindOfPath)

	repeat
		local count
		path, count = path:gsub("/[^/]+/%.%./", "/", 1) -- Not completely fool proof! We may need to properly parse the path, I think. @Robustness
	until count == 0

	return path
end



function _G.ipairsr(t)
	!ARGS "t:table"
	return iprev, t, #t+1
end

function _G.iprev(t, i)
	i = i-1
	local v = t[i]
	if v ~= nil then  return i, v  end
end



function _G.pairsSorted(t)
	local keys = sortNatural(getKeys(t))
	local i    = 0

	return function()
		i = i+1
		local k = keys[i]
		if k ~= nil then  return k, t[k]  end
	end
end



function _G.attributeWith(t, v)
	for k, item in pairs(t) do
		if item == v then  return k  end
	end
	return nil
end

function _G.attributeWithAny(t, ...)
	for k, item in pairs(t) do
		if isAny(item, ...) then  return k  end
	end
	return nil
end



function _G.sort(t, ...)
	table.sort(t, ...)
	return t
end



do
	local initted = false
	local gd, imageLoaders

	local function init()
		if initted then  return  end

		initted = true
		gd      = pcall(require, "gd") and require"gd" or nil

		if not gd then
			error("Failed loading Lua-GD.", 3)
		end

		imageLoaders = {
			["png"]  = gd.createFromPng,
			["jpg"]  = gd.createFromJpeg,
			["jpeg"] = gd.createFromJpeg,
			["gif"]  = gd.createFromGif,
		}
	end

	function _G.loadImage(pathImageRel)
		init()

		local filename  = getFilename(pathImageRel)
		local extLower  = getExtension(filename):lower()
		local pathImage = DIR_CONTENT.."/"..pathImageRel

		if not isFile(pathImage) then
			return nil, F("File does not exist: %s", maybeFullPath(pathImage))
		end

		local imageLoader = imageLoaders[extLower]
		if not imageLoader then
			return nil, F("Unknown image file format '%s'.", extLower)
		end

		local image = imageLoader(pathImage)
		if not image then
			return nil, F("Could not load image '%s'. Maybe the image is corrupted?", maybeFullPath(pathImage))
		end

		return image
	end
end

-- Returns nil and a message on error.
function _G.getImageDimensions(pathImageRel, mustBeFast)
	-- @Speed: Cache the result.

	-- Try the faster method using our own file decoder.
	local extLower = getExtension(pathImageRel):lower()

	if extLower == "jpg" or extLower == "jpeg" then
		local w, h = imageLib.jpegGetDimensions(DIR_CONTENT.."/"..pathImageRel)
		if w then  return w, h  end

	elseif extLower == "png" then
		local w, h = imageLib.pngGetDimensions(DIR_CONTENT.."/"..pathImageRel)
		if w then  return w, h  end
	end

	if mustBeFast then
		return nil, F("Could not determine the dimensions of '%s'.", maybeFullPath(DIR_CONTENT.."/"..pathImageRel))
	end

	-- Try the much slower method using GD.
	local image, err = loadImage(pathImageRel)
	if not image then  return nil, err  end

	return image:sizeXY()
end



do
	local initted = false
	local socket

	local function init()
		if initted then  return  end
		initted = true
		socket  = pcall(require, "socket.core") and require"socket.core" or nil
	end

	function _G.getTimeBetter()
		init()
		return socket and socket.gettime() or os.time()
	end

	function _G.sleep(duration)
		init()
		if socket then
			socket.sleep(duration)
		else
			local endTime = getTimeBetter() + duration
			repeat until getTimeBetter() >= endTime -- Should we do some better operation to waste time?
		end
	end
end



function _G.getCwd()
	return (toNormalPath(lfs.currentdir()))
end



--[[ Unused.
-- count = countString( haystack, needle [, plain=false ] )
function _G.countString(s, needle, plain)
	local count = 0
	local pos   = 1

	while true do
		local _, i2 = s:find(needle, pos, plain)
		if not i2 then  return count  end

		count = count + 1
		pos   = i2    + 1
	end
end
--]]

-- count = countSubString( haystack, startPosition, endPosition, needle [, plain=false ] )
function _G.countSubString(s, pos, posEnd, needle, plain)
	local count = 0

	while true do
		local _, i2 = s:find(needle, pos, plain)
		if not i2 or i2 > posEnd then  return count  end

		count = count + 1
		pos   = i2    + 1
	end
end



-- insertMultiple( array, value1, ... )
function insertMultiple(t, ...)
	for i = 1, select("#", ...) do
		table.insert(t, (select(i, ...)))
	end
end



function _G.maybeFullPath(path)
	return
		useFullPaths and not (
			path:find"^[/\\]"    or
			path:find"^%a:[/\\]" or
			path:find"^<" -- Placeholder path for when no real path is available.
		)
		and getCwd().."/"..path
		or  path
end



-- chunk = loadLuaFile( path [, environment ] )
-- Returns nil and a message on error.
function _G.loadLuaFile(path, env)
	local contents, err = getFileContentsBinary(path)
	if not contents then  return nil, err  end

	local chunk, err = loadstring(contents, "@"..maybeFullPath(path)) -- We use loadstring() instead of loadfile() because we want to use maybeFullPath() for the chunk name.
	if not chunk then  return nil, err  end

	if env then  setfenv(chunk, env)  end
	return chunk
end



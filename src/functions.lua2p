--[[============================================================
--=
--=  Global Functions
--=
--=-------------------------------------------------------------
--=
--=  LuaWebGen - static website generator in Lua!
--=  - Written by Marcus 'ReFreezed' Thunstr√∂m
--=  - MIT License (See LICENSE.txt)
--=
--==============================================================

	assertArg
	attributeWith, attributeWithAny
	cleanupPath
	countStrings
	createDirectory, isDirectoryEmpty, removeEmptyDirectories
	createThumbnail
	datetimeToTime, getDatetime
	encodeHtmlEntities
	error, errorf, fileError, errorLine
	F, formatBytes, formatTemplate
	generateFromTemplate, generateFromTemplateFile, generateRedirection
	generatorMeta
	getCwd
	getDirectory, getFilename, getExtension, getBasename
	getFileContents
	getKeys
	getLayoutTemplate
	getLineNumber
	getProtectionWrapper
	getTimeBetter, sleep
	getTimezone, getTimezoneOffsetString, getTimezoneOffset
	gsubPlainSub
	htaccessRewriteEscapeTestString, htaccessRewriteEscapeCondPattern, htaccessRewriteEscapeRuleSubstitution
	indexOf, itemWith, itemWithAll
	ipairsr, iprev
	isAny
	isArgs
	isFile, isDirectory
	isStringMatchingAnyPattern
	loadImage, getImageDimensions
	markdownToHtml
	newDataFolderReader, isDataFolderReader, preloadData
	newPage
	newStringBuilder
	pack
	pairsSorted
	parseAndRunTemplate
	pathToSitePath, sitePathToPath
	printNoLog, printfNoLog, log, print, printOnce, printf, printfOnce, timestampPrint, timestampPrintOnce, timestampPrintVerbose, timestampPrintError, timestampPrintWarning, timestampPrintWarningOnce, printobj
	pushContext, popContext, assertContext, getContext
	removeItem
	rewriteOutputPath
	round
	serializeLua
	sort
	sortNatural, compareNatural
	splitString
	toNormalPath, toWindowsPath
	tostringForTemplates
	toUrl, toUrlAbsolute, urlize, toPrettyUrl
	traverseDirectory, traverseFiles
	trim, trimNewlines
	unindent
	urlExists
	writeOutputFile, preserveExistingOutputFile
	xpcallErrorHandler, makeError, makeErrorf, isErrorObject

--============================================================]]

local templateMetaprogramCache = {}



function _G.traverseDirectory(dirPath, ignoreFolders, cb, _pathRelStart)
	_pathRelStart = _pathRelStart or #dirPath+2

	for name in lfs.dir(dirPath) do
		local path = dirPath.."/"..name

		if name ~= "." and name ~= ".." then
			local mode = lfs.attributes(path, "mode")

			if mode == "file" then
				local pathRel = path:sub(_pathRelStart)
				local abort   = cb(path, pathRel, name, "file")
				if abort then  return true  end

			elseif mode == "directory" and not (ignoreFolders and isStringMatchingAnyPattern(name, ignoreFolders)) then
				local pathRel = path:sub(_pathRelStart)
				local abort   = cb(path, pathRel, name, "directory")
				if abort then  return true  end

				local abort = traverseDirectory(path, ignoreFolders, cb, _pathRelStart)
				if abort then  return true  end
			end

		end
	end

end

function _G.traverseFiles(dirPath, ignoreFolders, cb, _pathRelStart)
	_pathRelStart = _pathRelStart or #dirPath+2

	for name in lfs.dir(dirPath) do
		local path = dirPath.."/"..name

		if name ~= "." and name ~= ".." then
			local mode = lfs.attributes(path, "mode")

			if mode == "file" then
				local pathRel  = path:sub(_pathRelStart)
				local extLower = getExtension(name):lower()
				local abort    = cb(path, pathRel, name, extLower)
				if abort then  return true  end

			elseif mode == "directory" and not (ignoreFolders and isStringMatchingAnyPattern(name, ignoreFolders)) then
				local abort = traverseFiles(path, ignoreFolders, cb, _pathRelStart)
				if abort then  return true  end
			end

		end
	end

end



function _G.isStringMatchingAnyPattern(s, patterns)
	for _, pat in ipairs(patterns) do
		if s:find(pat) then  return true  end
	end
	return false
end



function _G.getFileContents(path)
	local file, err = io.open(path, "rb")
	if not file then  return nil, err  end

	local contents = file:read("*all")
	file:close()
	return contents
end



do
	-- isValueExpression = insertLuaForEchoingIfExpression( luaOutputBuffer, luaCode )
	local function insertLuaForEchoingIfExpression(out, luaCode)
		local doBlock = F("do  local v = (%s\n)  if type(v) == 'string' and v:find'^%%s*<[!%%a].*>%%s*$' then  echoRaw(v)  elseif v ~= nil then  echo(v)  end end ", luaCode)
		if not loadstring(doBlock) then  return false  end

		table.insert(out, doBlock)
		return true
	end

	local BRACKET_ENDS = {
		["("] = ")",
		["{"] = "}",
		["["] = "]",
	}

	local function findEndOfLuaCodeBlock(path, template, blockStart, pos)
		!local PRINT_PROGRESS = DEV and 1==0
		!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: >>>>>>>>", path, pos, getLineNumber(template, pos))`  end

		local bracketBalance        = 0
		local bracketStartPositions = {}
		local bracketEndCharacters  = {}

		while true do
			-- @Speed? Positions can sometimes be cached between iterations.
			local posBlockEnd     = bracketBalance == 0 and template:find("}}", pos, true) or nil
			local posComment      = template:find("--",     pos, true)
			local posStringShort  = template:find("[\"']",  pos, false)
			local posStringLong   = template:find("%[=*%[", pos, false)
			local posBracketStart = template:find("[({%[]", pos, false)
			local posBracketEnd   = template:find("[)}%]]", pos, false)

			local posNext = math.min(
				(posBlockEnd     or 1/0),
				(posComment      or 1/0),
				(posStringShort  or 1/0),
				(posStringLong   or 1/0),
				(posBracketStart or 1/0),
				(posBracketEnd   or 1/0)
			)

			if posNext == posBlockEnd then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: <<<<<<<<", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBlockEnd - 1
				return pos

			elseif posNext == posComment then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Comment", path, posNext, getLineNumber(template, posNext))`  end
				pos                   = posComment
				local longStringLevel = template:match("^%[(=*)%[", pos+2)

				if longStringLevel then
					pos         = pos + 4 + #longStringLevel -- Eat "--[=[".
					local _, i2 = template:find("%]"..longStringLevel.."%]", pos)

					if not i2 then
						fileError(path, template, pos, "Incomplete long comment. (Code block starting at line %d)", getLineNumber(template, blockStart))
					end

					pos = i2+1

				else
					pos     = pos + 2 -- Eat "--".
					local i = template:find("\n", pos, true)
					pos     = i and i+1 or pos
				end

			elseif posNext == posStringShort then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: String", path, posNext, getLineNumber(template, posNext))`  end
				pos = posStringShort + 1

				local pat = "(["..template:sub(posStringShort, posStringShort).."\\])"

				while true do
					local i, _, c = template:find(pat, pos)
					if not i then
						fileError(path, template, posStringShort, "Missing end quote for string. (Code block starting at line %d)", getLineNumber(template, blockStart))
					end
					pos = i + 1
					if c == "\\" then
						pos = pos + 1 -- It's fine to always skip one character, even if the escape sequence is something like "\173". Any errors will be checked later by loadstring().
					else
						break
					end
				end

			elseif posNext == posStringLong then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: String (long)", path, posNext, getLineNumber(template, posNext))`  end
				pos                   = posStringLong
				local longStringLevel = template:match("^%[(=*)%[", pos)

				pos         = pos + 2 + #longStringLevel -- Eat "[=[".
				local _, i2 = template:find("%]"..longStringLevel.."%]", pos)

				if not i2 then
					fileError(path, template, pos, "Incomplete long string. (Code block starting at line %d)", getLineNumber(template, blockStart))
				end

				pos = i2 + 1

			elseif posNext == posBracketStart then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Bracket start", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBracketStart

				bracketBalance                        = bracketBalance + 1
				bracketStartPositions[bracketBalance] = pos
				bracketEndCharacters[bracketBalance]  = BRACKET_ENDS[template:sub(pos, pos)]

				pos = pos + 1

			elseif posNext == posBracketEnd then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Bracket end", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBracketEnd

				if bracketBalance == 0 then
					fileError(
						path, template, pos,
						"Unexpected '%s'. Too many end brackets. (Code block starting at line %d)",
						template:sub(pos, pos), getLineNumber(template, blockStart)
					)
				end

				local bracketEndChar = bracketEndCharacters[bracketBalance]

				if template:sub(pos, pos) ~= bracketEndChar then
					fileError(
						path, template, pos,
						"Expected '%s' to end bracket starting at line %d, but got '%s'. (Code block starting at line %d)",
						bracketEndChar,
						getLineNumber(template, bracketStartPositions[bracketBalance]),
						template:sub(pos, pos),
						getLineNumber(template, blockStart)
					)
				end

				bracketStartPositions[bracketBalance] = nil
				bracketEndCharacters[bracketBalance]  = nil
				bracketBalance                        = bracketBalance - 1

				pos = pos + 1

			else
				if bracketBalance > 0 then
					fileError(
						path, template, bracketStartPositions[bracketBalance],
						"Missing '%s'. Unbalanced brackets in code. (Code block starting at line %d)",
						bracketEndCharacters[bracketBalance], getLineNumber(template, blockStart)
					)
				end

				fileError(path, template, pos, "Missing end of code block. (Code block starting at line %d)", getLineNumber(template, blockStart))
			end
		end

		assert(false)
	end

	local function addLineNumberIndicator(out, ln)
		table.insert(out, "\n-- @LINE")
		table.insert(out, ln)
		table.insert(out, "\n")
	end

	-- endBlockStart, endBlockEnd = templateToLua( luaOutputBuffer, path, template, position, levelOfTemplateifiedControlStructure )
	local function templateToLua(out, path, template, pos, level)
		!local PATTERN_IDENT       = "[%a_][%w_]*"
		!local PATTERN_IDENT_BEGIN = "%f[%w_]"
		!local PATTERN_IDENT_END   = "%f[^%w_]"

		local posAtStartOfParsing = pos

		while pos <= #template do
			local blockStart = template:find("{{", pos, true)
			if not blockStart then  break  end

			if blockStart > pos then
				local plainSegment = template:sub(pos, blockStart-1)
				local luaStatement = F("echoRaw(%q)", plainSegment) --:gsub("\\\n", "\\n")
				table.insert(out, luaStatement)
			end

			local autoLock = (autoLockPages and blockStart == 1)

			pos = blockStart
			pos = pos + 2 -- Eat "{{".

			local ln = getLineNumber(template, pos)
			addLineNumberIndicator(out, ln)

			local blockEnd = findEndOfLuaCodeBlock(path, template, blockStart, pos) + 2
			local block    = template:sub(blockStart+2, blockEnd-2) -- Without "{{" and "}}".
			-- print("BLOCK: "..trim(block))

			----------------------------------------------------------------

			-- Match custom keywords first so we don't confuse those with normal Lua identifiers later.

			-- fori [<] item in <array> (...) end
			-- fori [<] <array> (...) end
			if block:find!("^ *fori"..PATTERN_IDENT_END) then
				local             reverse, ident, expr = block:match!(NOSPACE("^ %s* fori %s* (< ) %s* ("..PATTERN_IDENT..") %s+ in "..PATTERN_IDENT_END.." %s* (%S.*)"))
				if not expr then           ident, expr = block:match!(NOSPACE("^ %s* fori %s+          ("..PATTERN_IDENT..") %s+ in "..PATTERN_IDENT_END.." %s* (%S.*)"))
				if not expr then  reverse,        expr = block:match!(NOSPACE("^ %s* fori %s* (<?) %s*                                                          (%S.*)"))
				if not expr then
					fileError(path, template, pos, "Invalid 'fori' statement.")
				end end end

				reverse = (reverse == "<")

				if not loadstring("_=("..expr.."\n)") then
					fileError(path, template, pos, "Invalid value expression for 'fori' loop: %s", trim(expr)) -- @UX: Better error message.
				end

				table.insert(out, "for i, ")
				table.insert(out, (ident or "it"))
				table.insert(out, " in ")
				table.insert(out, (reverse and "ipairsr" or "ipairs"))
				table.insert(out, "(")
				table.insert(out, expr)
				table.insert(out, "\n) do ")

				local innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, blockEnd+1, level+1)
				local innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

				if not innerEndBlock:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, innerEndBlockStart,
						"Expected 'end' for 'fori' loop starting at line %d.",
						getLineNumber(template, pos)
					)
				end

				table.insert(out, "end ")
				blockEnd = innerEndBlockEnd

			-- for index [, item, ... ] in <expression> (...) end
			-- for index = <from>, <to> [, <step> ] (...) end
			elseif
				block:find!("^ *for%s+"..PATTERN_IDENT.."%s*[,=]") or
				block:find!("^ *for%s+"..PATTERN_IDENT.."%s+in"..PATTERN_IDENT_END)
			then
				table.insert(out, block)
				table.insert(out, "\ndo ")

				local innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, blockEnd+1, level+1)
				local innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

				if not innerEndBlock:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, innerEndBlockStart,
						"Expected 'end' for 'for' loop starting at line %d.",
						getLineNumber(template, pos)
					)
				end

				table.insert(out, "\nend ")
				blockEnd = innerEndBlockEnd

			-- for [<] <to> (...) end
			elseif block:find!("^ *for"..PATTERN_IDENT_END) then
				-- for < <to>
				if block:find"^ *for%s*<" then
					local expr = block:gsub("for%s*<", "", 1)

					if not loadstring("_=("..expr.."\n)") then
						fileError(path, template, pos, "Invalid value expression for simplified 'for' loop: %s", trim(expr)) -- @UX: Better error message.
					end

					table.insert(out, "for i = (")
					table.insert(out, expr)
					table.insert(out, "\n")
					addLineNumberIndicator(out, ln+countStrings(expr, "\n", true))
					table.insert(out, "), 1, -1 do ")

				-- for <to>
				else
					local expr = block:gsub("for", "", 1)

					if not loadstring("_=("..expr.."\n)") then
						fileError(path, template, pos, "Invalid value expression for simplified 'for' loop: %s", trim(expr)) -- @UX: Better error message.
					end

					table.insert(out, "for i = 1, (")
					table.insert(out, expr)
					table.insert(out, "\n")
					addLineNumberIndicator(out, ln+countStrings(expr, "\n", true))
					table.insert(out, ") do ")
				end

				local innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, blockEnd+1, level+1)
				local innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

				if not innerEndBlock:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, innerEndBlockStart,
						"Expected 'end' for 'for' loop starting at line %d.",
						getLineNumber(template, pos)
					)
				end

				table.insert(out, "\nend ")
				blockEnd = innerEndBlockEnd

			-- do (...) end
			elseif block:find!("^ *do"..PATTERN_IDENT_END) then
				table.insert(out, "do ")

				local innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, blockEnd+1, level+1)
				local innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

				if not innerEndBlock:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, innerEndBlockStart,
						"Expected 'end' for 'do' starting at line %d.",
						getLineNumber(template, pos)
					)
				end

				table.insert(out, "\nend ")
				blockEnd = innerEndBlockEnd

			-- if <condition> (...) end
			elseif block:find!("^ *if"..PATTERN_IDENT_END) then
				table.insert(out, block)
				table.insert(out, "\nthen ")

				local innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, blockEnd+1, level+1)
				local innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

				addLineNumberIndicator(out, getLineNumber(template, innerEndBlockStart))

				while innerEndBlock:find!("^ *elseif"..PATTERN_IDENT_END) do
					table.insert(out, innerEndBlock)
					table.insert(out, "\nthen ")

					innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, innerEndBlockEnd+1, level+1)
					innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

					addLineNumberIndicator(out, getLineNumber(template, innerEndBlockStart))
				end

				if innerEndBlock:find!("^ *else"..PATTERN_IDENT_END) then
					table.insert(out, "else ")

					innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, innerEndBlockEnd+1, level+1)
					innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

					addLineNumberIndicator(out, getLineNumber(template, innerEndBlockStart))
				end

				if not innerEndBlock:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, innerEndBlockStart,
						"Expected 'end' for 'if' starting at line %d.",
						getLineNumber(template, pos)
					)
				end

				table.insert(out, "end ")
				blockEnd = innerEndBlockEnd

			-- while <condition> (...) end
			elseif block:find!("^ *while"..PATTERN_IDENT_END) then
				table.insert(out, block)
				table.insert(out, "\ndo ")

				local innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, blockEnd+1, level+1)
				local innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

				if not innerEndBlock:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, innerEndBlockStart,
						"Expected 'end' for 'while' loop starting at line %d.",
						getLineNumber(template, pos)
					)
				end

				table.insert(out, "end ")
				blockEnd = innerEndBlockEnd

			-- repeat (...) until <condition>
			elseif block:find!("^ *repeat"..PATTERN_IDENT_END) then
				-- @Incomplete: Make sure there's no garbage afterwards.
				table.insert(out, "repeat ")

				local innerEndBlockStart, innerEndBlockEnd = templateToLua(out, path, template, blockEnd+1, level+1)
				local innerEndBlock                        = template:sub(innerEndBlockStart+2, innerEndBlockEnd-2)

				if not innerEndBlock:find!("^ *until" ..PATTERN_IDENT_END) then
					fileError(
						path, template, innerEndBlockStart,
						"Expected 'until' for 'repeat' loop starting at line %d.",
						getLineNumber(template, pos)
					)
				end

				addLineNumberIndicator(out, getLineNumber(template, innerEndBlockStart))
				table.insert(out, innerEndBlock)
				table.insert(out, "\n")
				blockEnd = innerEndBlockEnd

			-- End block + elseif.
			elseif
				block:find!("^ *end"   ..PATTERN_IDENT_END) or
				block:find!("^ *until" ..PATTERN_IDENT_END) or
				block:find!("^ *else"  ..PATTERN_IDENT_END) or
				block:find!("^ *elseif"..PATTERN_IDENT_END)
			then
				if level == 1 then
					fileError(path, template, pos, "Unexpected templateified '%s'.", (block:match"%a+"))
				end
				return blockStart, blockEnd

			-- URL short-form.
			elseif block:find"^ */" or block:find"^ *%a+:/" then
				table.insert(out, F("echo(url%q)", trim(block)))

			-- Value expression.
			elseif insertLuaForEchoingIfExpression(out, block) then
				if block:find"^%s*function%s*%(" then -- We do allow echoing functions, but this specifically is probably an error made by the user.
					fileError(path, template, blockStart, "Invalid value expression.")
				end

			-- Any other Lua code.
			else
				table.insert(out, block)
				table.insert(out, "\n")
			end

			----------------------------------------------------------------

			if autoLock then
				table.insert(out, "lock()")
			end

			pos = blockEnd + 1
		end

		if level > 1 then
			fileError(path, template, posAtStartOfParsing, "Templateified control structure doesn't have an end.")
		end

		if pos <= #template then
			local plainSegment = template:sub(pos)
			local luaStatement = F("echoRaw(%q)", plainSegment) --:gsub("\\\n", "\\n")
			table.insert(out, luaStatement)
		end

		return #template+1, #template -- These return values should never actually be used if everything is working correctly.
	end

	local function _parseAndRunTemplate(page, path, template, useCache, enableHtmlEncoding)
		useCache      = true -- We need all these for correcting file numbers in error messages! @Cleanup
		local luaCode = useCache and templateMetaprogramCache[path] or nil

		if not luaCode then
			local luaBuffer = {}
			templateToLua(luaBuffer, path, template, 1, 1)

			luaCode = table.concat(luaBuffer)
			if useCache then  templateMetaprogramCache[path] = luaCode  end

			!if DEV and 1==0 then
				print("-- LUA "..path.." --")
				print(luaCode)
				print("-- /LUA --")
			!end
		end

		local chunk, err = loadstring(luaCode, "@"..path)
		if not chunk then  errorLine(err)  end

		setfenv(chunk, scriptEnvironment)

		local ctx                            = pushContext("template")
		ctx.page                             = page
		ctx._scriptEnvironmentGlobals.page   = getProtectionWrapper(page, "page")
		ctx._scriptEnvironmentGlobals.params = page.params.v
		ctx._scriptEnvironmentGlobals.P      = page.params.v
		ctx.out                              = {}
		ctx.enableHtmlEncoding               = enableHtmlEncoding

		local ok, errObj = xpcall(chunk, xpcallErrorHandler)

		popContext("template")

		if not ok then  error(errObj)  end

		local templateResult = (table.concat(ctx.out)
			:gsub("[ \t]+\n", "\n"  ) -- :Beautify
			:gsub("\n\n\n+",  "\n\n") -- :Beautify  @UX Not sure if this line is actually good.
		)

		return templateResult
	end

	-- stringResult = parseAndRunTemplate( page, path, template, fileType=fromPage, useCache )
	function _G.parseAndRunTemplate(page, path, template, fileType, useCache)
		fileType = (fileType or fileTypes[page._extension])

		!local PRINT_RESULT = DEV and 1==0
		local result

		if fileType == "markdown" then
			result = _parseAndRunTemplate(page, path, template, useCache, true)
			result = markdownToHtml(result)
			result = trimNewlines(result).."\n" -- :Beautify
			!if PRINT_RESULT then  __LUA` print"-- HTML --" print(result) print"-- /HTML --" `  end

		elseif fileType == "html" then
			result = _parseAndRunTemplate(page, path, template, useCache, true)
			result = trimNewlines(result).."\n" -- :Beautify
			!if PRINT_RESULT then  __LUA` print"-- HTML --" print(result) print"-- /HTML --" `  end

		else
			result = _parseAndRunTemplate(page, path, template, useCache, false)
			result = trimNewlines(result).."\n" -- :Beautify
			!if PRINT_RESULT then  __LUA` print"-- result --" print(result) print"-- /result --" `  end
		end

		return result
	end

end



local _error = error

-- error( message [, level=1 ] )
function _G.error(err, level)
	level = (level or 1) + 1
	if isErrorObject(err) then  _error(err, level)  end

	err = tostring(err)

	local info = debug.getinfo(level, "Sl")
	if info then
		local sourceName = info.source:find"^@" and info.source:sub(2) or info.short_src
		err              = sourceName .. (info.currentline > 0 and ":"..info.currentline or "") .. ": " .. err
	end

	local errObj = makeError(err, level)
	_error(errObj, level)
end

-- errorf( [ level=1, ] formatString, ... )
function _G.errorf(levelOrS, ...)
	if type(levelOrS) == "number" then
		error(F(...), levelOrS+1)
	else
		error(F(levelOrS, ...), 2)
	end
end

-- fileError( path, contents, position,   formatString, ... )
-- fileError( path, nil,      lineNumber, formatString, ... )
function _G.fileError(path, contents, pos, s, ...)
	local ln = contents and getLineNumber(contents, pos) or pos
	if type(s) ~= "string" then
		s = F("%s:%d: %s", path, ln, tostring(s))
	else
		s = F("%s:%d: "..s, path, ln, ...)
	end
	errorLine(s)
end

-- errorLine( message )
-- errorLine( formatString, ... )
function _G.errorLine(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end
	_error(makeError(s, 0))
end



function _G.getLineNumber(s, pos)
	local lineCount = 1
	for posCurrent in s:gmatch"()\n" do -- @Speed
		if posCurrent < pos then
			lineCount = lineCount+1
		else
			break
		end
	end
	return lineCount
end



-- writeOutputFile( category, pathRelative, url, dataString [ modificationTime ] )
function _G.writeOutputFile(category, pathRel, url, data, modTime)
	local pathOutputRel = rewriteOutputPath(pathRel)
	if writtenOutputFiles[pathOutputRel] then
		errorf("Duplicate output file '%s'.", pathOutputRel)
	end
	assert(not writtenOutputUrls[url])

	local filename = getFilename(pathRel)
	local extLower = getExtension(filename):lower()

	if fileProcessors[extLower] then
		pushContext("config")
		data = fileProcessors[extLower](data, pathToSitePath(pathRel))
		popContext("config")

		if type(data) ~= "string" then
			errorf("File processor for '%s' files did not return a string.", extLower)
		end
	end

	local path = DIR_OUTPUT.."/"..pathOutputRel
	timestampPrintVerbose("Writing: %s", path)

	createDirectory(getDirectory(path))

	local file = assert(io.open(path, "wb"))
	file:write(data)
	file:close()

	if modTime then
		local ok, err = lfs.touch(path, modTime)
		if not ok then
			timestampPrintError("Could not update modification time for '%s'. (%s)", path, err)
		end
	end

	table.insert(writtenOutputFiles, pathOutputRel)
	writtenOutputFiles[pathOutputRel] = true
	writtenOutputUrls[url] = true

	assert(OUTPUT_CATEGORY_SET[category], category)
	_G.outputFileCount         = outputFileCount            + 1
	outputFileCounts[category] = outputFileCounts[category] + 1

	_G.outputFileByteCount = outputFileByteCount + #data
end

-- preserveExistingOutputFile( category, pathRelative, url )
function _G.preserveExistingOutputFile(category, pathRel, url)
	local pathOutputRel = rewriteOutputPath(pathRel)
	if writtenOutputFiles[pathOutputRel] then
		errorf("Duplicate output file '%s'.", pathOutputRel)
	end
	assert(not writtenOutputUrls[url])

	local path = DIR_OUTPUT.."/"..pathOutputRel
	timestampPrintVerbose("Preserving: %s", path)

	local dataLen, err = lfs.attributes(path, "size")
	if not dataLen then
		timestampPrintError("Could not retrieve size of file '%s'. (%s)", path, err)
		dataLen = 0
	end

	table.insert(writtenOutputFiles, pathOutputRel)
	writtenOutputFiles[pathOutputRel] = true
	writtenOutputUrls[url] = true

	assert(OUTPUT_CATEGORY_SET[category], category)
	_G.outputFileCount          = outputFileCount            + 1
	outputFileCounts[category]  = outputFileCounts[category] + 1
	_G.outputFilePreservedCount = outputFilePreservedCount   + 1

	_G.outputFileByteCount = outputFileByteCount + dataLen
end



function _G.createDirectory(path)
	if path:find"^/" or path:find"^%a:" then
		errorf(2, "[internal] Absolute paths are disabled. (%s)", path)
	end
	if path:find"//" then
		errorf(2, "Path looks invalid: '%s'", path)
	end

	local pathConstructed = ""

	for folder in path:gmatch"[^/]+" do
		pathConstructed = (pathConstructed == "" and folder or pathConstructed.."/"..folder)
		if not (isDirectory(pathConstructed) or lfs.mkdir(pathConstructed)) then
			errorf("Could not create directory '%s'.", pathConstructed)
		end
	end
end

function _G.isDirectoryEmpty(dirPath)
	for name in lfs.dir(dirPath) do
		if name ~= "." and name ~= ".." then  return false  end
	end
	return true
end

function _G.removeEmptyDirectories(dirPath)
	for name in lfs.dir(dirPath) do
		local path = dirPath.."/"..name

		if name ~= "." and name ~= ".." and isDirectory(path) then
			removeEmptyDirectories(path)
			if isDirectoryEmpty(path) then
				timestampPrintVerbose("Removing empty folder: %s", path)
				assert(lfs.rmdir(path))
			end
		end

	end
end



--
-- Note: Print functions log, but log functions do not print.
--

-- log( string )
-- log( formatString, ... )
function _G.log(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if not logFile then
		table.insert(toLog, s)
		return
	end

	for i, s in ipairs(toLog) do
		logFile:write(s, "\n")
		toLog[i] = nil
	end

	logFile:write(s, "\n")
end

do
	local values = {}

	_G.printNoLog = print
	function _G.printfNoLog(s, ...)
		printNoLog(F(s, ...))
	end

	function _G.print(...)
		printNoLog(...)

		local argCount = select("#", ...)
		for i = 1, argCount do
			values[i] = tostring(select(i, ...))
		end

		log(table.concat(values, "\t", 1, argCount))
	end
	function _G.printOnce(...)
		local argCount = select("#", ...)
		for i = 1, argCount do
			values[i] = tostring(select(i, ...))
		end

		local s = table.concat(values, "\t", 1, argCount)

		if oncePrints[s] then  return  end
		oncePrints[s] = true

		printNoLog(...)
		log(s)
	end
end

function _G.printf(s, ...)
	print(F(s, ...))
end
function _G.printfOnce(s, ...)
	printOnce(F(s, ...))
end

-- timestampLog( string )
-- timestampLog( formatString, ... )
function _G.timestampLog(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end
	log("[%s] %s", os.date"%H:%M:%S", s)
end

-- timestampPrint( string )
-- timestampPrint( formatString, ... )
-- timestampPrintOnce( string )
-- timestampPrintOnce( formatString, ... )
function _G.timestampPrint(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	printf("[%s] %s", os.date"%H:%M:%S", s)
end
function _G.timestampPrintOnce(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if oncePrints[s] then  return  end
	oncePrints[s] = true

	printf("[%s] %s", os.date"%H:%M:%S", s)
end

-- timestampPrintVerbose( string )
-- timestampPrintVerbose( formatString, ... )
function _G.timestampPrintVerbose(...)
	if verbosePrint then
		timestampPrint(...)
	else
		timestampLog(...)
	end
end

-- timestampPrintError( string )
-- timestampPrintError( formatString, ... )
function _G.timestampPrintError(s, ...)
	if select("#", ...) > 0 then
		s = F("[%s] ERROR: "..s, os.date"%H:%M:%S", ...)
	else
		s = F("[%s] ERROR: %s",  os.date"%H:%M:%S", s)
	end
	io.stderr:write(s, "\n")
	log(s)
end

-- timestampPrintWarning( string )
-- timestampPrintWarning( formatString, ... )
-- timestampPrintWarningOnce( string )
-- timestampPrintWarningOnce( formatString, ... )
function _G.timestampPrintWarning(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	_G.warningCount = warningCount + 1
	s               = F("[%s] WARNING(%d): %s", os.date"%H:%M:%S", warningCount, s)

	io.stderr:write(s, "\n")
	log(s)
end
function _G.timestampPrintWarningOnce(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if oncePrints[s] then  return  end
	oncePrints[s] = true

	_G.warningCount = warningCount + 1
	s               = F("[%s] WARNING(%d): %s", os.date"%H:%M:%S", warningCount, s)

	io.stderr:write(s, "\n")
	log(s)
end

-- printobj( ... )
-- Note: Does not write to log.
do
	local stdoutWrite = io.write

	local function toStringBetter(v)
		return (tostring(v):gsub("^table: ", ""))
	end

	local function compareKeys(a, b)
		return compareNatural(toStringBetter(a), toStringBetter(b))
	end

	local function _printobj(v, tables)
		local vType = type(v)

		if vType == "table" then
			if tables[v] then
				stdoutWrite(toStringBetter(v), " ")
				return
			end

			stdoutWrite(toStringBetter(v), "{ ")
			tables[v] = true

			local indices = {}
			for i = 1, #v do  indices[i] = true  end

			for _, k in ipairs(sort(getKeys(v), compareKeys)) do
				if not indices[k] then
					stdoutWrite(toStringBetter(k), "=")
					_printobj(v[k], tables)
				end
			end

			for i = 1, #v do
				stdoutWrite(i, "=")
				_printobj(v[i], tables)
			end

			stdoutWrite("} ")

		elseif vType == "number" then
			stdoutWrite(F("%g ", v))

		elseif vType == "string" then
			stdoutWrite('"', v:gsub("%z", "\\0"):gsub("\n", "\\n"), '" ')

		else
			stdoutWrite(toStringBetter(v), " ")
		end

	end

	function _G.printobj(...)
		for i = 1, select("#", ...) do
			if i > 1 then  stdoutWrite("\t")  end

			_printobj(select(i, ...), {})
		end
		stdoutWrite("\n")
	end
end



function _G.isFile(path)
	return lfs.attributes(path, "mode") == "file"
end

function _G.isDirectory(path)
	return lfs.attributes(path, "mode") == "directory"
end



_G.F = string.format

function _G.formatBytes(n)
	if     n >= !(1024^4/10) then  return F("%.2f TiB", n*!(1/1024^4))
	elseif n >= !(1024^3/10) then  return F("%.2f GiB", n*!(1/1024^3))
	elseif n >= !(1024^2/10) then  return F("%.2f MiB", n*!(1/1024^2))
	elseif n >= !(1024^1/10) then  return F("%.2f KiB", n*!(1/1024^1))
	else                           return F("%d bytes", n            )  end
end

function _G.formatTemplate(s, values)
	s = s:gsub(":([%a_][%w_]*):", function(k)
		if values[k] == nil then
			timestampPrintWarning("[formatTemplate] No value for :%s:.", k)
		else
			return tostring(values[k])
		end
	end)

	return unindent(s)
end



do
	local URI_PERCENT_CODES_TO_NOT_ENCODE = {
		["%2d"]="-",["%2e"]=".",["%7e"]="~",--["???"]="_",
		["%21"]="!",["%23"]="#",["%24"]="$",["%26"]="&",["%27"]="'",["%28"]="(",["%29"]=")",["%2a"]="*",["%2b"]="+",
		["%2c"]=",",["%2f"]="/",["%3a"]=":",["%3b"]=";",["%3d"]="=",["%3f"]="?",["%40"]="@",["%5b"]="[",["%5d"]="]",
	}

	function _G.toUrl(url)
		if type(url) ~= "string" then
			errorf(2, "Bad type of 'url' argument. (Got %s)", type(url))
		end

		url = urlLib.escape(url)
		url = url:gsub("%%[0-9a-f][0-9a-f]", URI_PERCENT_CODES_TO_NOT_ENCODE)

		return url
	end

	-- print(toUrl("http://www.example.com/some-path/File~With (Stuff_√•√§√∂).jpg?key=value&foo=bar#hash")) -- TEST
end

function _G.toUrlAbsolute(url)
	url = url:gsub("^/%f[^/]", site.baseUrl.v)
	return (toUrl(url))
end

function _G.urlize(text)
	text = text
		:lower()
		:gsub("[%p ]+", "-")
		:gsub("^%-+", "")
		:gsub("%-+$", "")

	return text == "" and "-" or text
end

function _G.toPrettyUrl(url)
	return (url
		:gsub("^https?://", "")
		:gsub("^www%.", "")
		:gsub("/+$", "")
	)
end



function _G.generatorMeta(hideVersion)
	return
		hideVersion
		and '<meta name="generator" content="LuaWebGen">'
		or  '<meta name="generator" content="LuaWebGen '..WEBGEN_VERSION..'">'
end



function _G.trim(s)
	s = s :gsub("^%s+", "") :gsub("%s+$", "")
	return s
end

function _G.trimNewlines(s)
	s = s :gsub("^\n+", "") :gsub("\n+$", "")
	return s
end



do
	local function formatValue(t, out, isDeep--[[, errLevel]])
		if isDeep and type(t) == "string" then
			table.insert(out, '"')
			table.insert(out, t)
			table.insert(out, '"')
			return

		-- elseif type(t) == "function" or type(t) == "thread" or type(t) == "userdata" then
		-- 	errorf(errLevel, "Cannot serialize values of type '%s'.", type(t))

		elseif type(t) ~= "table" then
			table.insert(out, tostring(t))
			return
		end

		local obj = protectionedObjects[t]
		if obj then
			local fields = {}

			for k, field in pairs(obj) do
				if not k:find"^_" then
					fields[k] = (field.g or NOOP)(field)
				end
			end

			return (formatValue(fields, out, isDeep--[[, errLevel]]))
		end

		local keys = {}
		for k in pairs(t) do
			table.insert(keys, k)
		end
		sortNatural(keys)

		table.insert(out, "{")
		for i, k in ipairs(keys) do
			if i > 1 then  table.insert(out, ", ")  end
			table.insert(out, tostring(k))
			table.insert(out, "=")
			formatValue(t[k], out, true--[[, errLevel]])
		end
		table.insert(out, "}")
	end

	function _G.tostringForTemplates(v)
		local out = {}
		formatValue(v, out, false--[[, 3]])
		return (table.concat(out))
	end
end



-- array = sortNatural( array [, attribute ] )
do
	local function pad(numStr)
		return F("%03d%s", #numStr, numStr)
	end
	function _G.compareNatural(a, b)
		return (tostringForTemplates(a):gsub("%d+", pad) < tostringForTemplates(b):gsub("%d+", pad))
	end

	function _G.sortNatural(t, k)
		if k then
			table.sort(t, function(a, b)
				return compareNatural(a[k], b[k])
			end)
		else
			table.sort(t, compareNatural)
		end
		return t
	end
end



-- dataFolderReader = newDataFolderReader( path [, isTop=false ] )
function _G.newDataFolderReader(path, checkDirExistance)
	local dataFolderReader = {}

	setmetatable(dataFolderReader, {
		__index = function(dataFolderReader, k)
			if checkDirExistance then
				checkDirExistance = false

				if not isDirectory(path) then
					errorf(2, "No data directory.")
				end
			end

			local dataObj

			if type(k) ~= "string" then
				return nil

			elseif k == "." or k == ".." then
				errorf(2, "Bad data key '%s'.", k)

			elseif isFile(F("%s/%s.lua", path, k)) then
				local filePath   = F("%s/%s.lua", path, k)
				local chunk, err = loadfile(filePath)
				if not chunk then  errorf(2, "Error loading Lua data file '%s': %s", filePath, err)  end

				setfenv(chunk, scriptEnvironment)

				pushContext("none")
				dataObj = chunk()
				popContext("none")

				if dataObj == nil then
					errorf(2, "Lua data file returned nothing. (%s)", filePath)
				end

			elseif isFile(F("%s/%s.toml", path, k)) then
				local filePath = F("%s/%s.toml", path, k)
				local contents = assert(getFileContents(filePath))
				dataObj        = assert(tomlLib.parse(contents))

			elseif isFile(F("%s/%s.xml", path, k)) then
				local filePath = F("%s/%s.xml", path, k)
				local contents = assert(getFileContents(filePath))
				dataObj        = assert(xmlLib.parse(contents, false))

			elseif isDirectory(F("%s/%s", path, k)) then
				dataObj = newDataFolderReader(F("%s/%s", path, k))

			else
				timestampPrintWarningOnce("Bad data path '%s/%s'.", path, k)
				return nil
			end

			assert(dataObj ~= nil)
			rawset(dataFolderReader, k, dataObj)
			return dataObj
		end,
	})

	dataReaderPaths[dataFolderReader] = path
	return dataFolderReader
end

function _G.isDataFolderReader(t)
	return dataReaderPaths[t] ~= nil
end

function _G.preloadData(dataFolderReader)
	if dataIsPreloaded[dataFolderReader] then  return dataFolderReader  end

	for name in lfs.dir(dataReaderPaths[dataFolderReader]) do
		local path     = dataReaderPaths[dataFolderReader].."/"..name
		local basename = getBasename(name)

		if
			not rawget(dataFolderReader, basename) and name ~= "." and name ~= ".." and (
				(isFile(path)      and not isStringMatchingAnyPattern(name, ignoreFiles  )) or
				(isDirectory(path) and not isStringMatchingAnyPattern(name, ignoreFolders))
			)
		then
			if indexOf(DATA_FILE_EXTENSIONS, getExtension(name)) then
				local _ = dataFolderReader[basename]
			end
		end
	end

	dataIsPreloaded[dataFolderReader] = true
	return dataFolderReader
end



function _G.getProtectionWrapper(obj, objName)
	assertArg(1, obj,     "table")
	assertArg(2, objName, "string")

	local wrapper = protectionWrappers[obj]
	if wrapper then  return wrapper  end

	wrapper = setmetatable({}, {
		__index = function(wrapper, k)
			local field = obj[k]

			if field == nil or k:find"^_" then
				errorf(2, "Tried to get non-existent %s field '%s'.", objName, tostring(k))
			elseif not field.g then
				errorf(2, "[internal] No getter for %s.%s", objName, k)
			end

			return field:g()
		end,

		__newindex = function(wrapper, k, vNew)
			local field = obj[k]

			if field == nil or k:find"^_" then
				errorf(2, "'%s' is not a valid %s field.", tostring(k), objName)
			elseif not field.s or obj._readonly then
				errorf(2, "Cannot update read-only field %s.%s", objName, k)
			end

			local vOld = field.v

			if type(vNew) ~= type(vOld) then
				errorf(
					2, "Expected %s for %s.%s, but got %s. (%s)",
					type(vOld), objName, k, type(vNew), tostring(vNew)
				)
			end

			field:s(vNew)
		end,
	})

	protectionWrappers[obj]      = wrapper
	protectionedObjects[wrapper] = obj

	return wrapper
end



function _G.toNormalPath(osPath)
	local path = osPath:gsub("\\", "/")
	return path
end

function _G.toWindowsPath(path)
	local winPath = path:gsub("/", "\\")
	return winPath
end



function _G.getDirectory(genericPath)
	return (genericPath:gsub("/?[^/]+$", ""))
end

function _G.getFilename(genericPath)
	return genericPath:match"[^/]+$"
end

function _G.getExtension(filename)
	return filename:match"%.([^.]+)$" or ""
end

function _G.getBasename(filename)
	local ext = getExtension(filename)
	if ext == "" then  return filename  end

	return filename:sub(1, #filename-#ext-1)
end



-- generateFromTemplate( page, template [, modificationTime ] )
function _G.generateFromTemplate(page, template, modTime)
	assert(type(page)     == "table")
	assert(type(template) == "string")

	if page._isGenerated then
		errorf(2, "Page has already generated. (%s)", page._path)
	end
	if page._isGenerating or pagesGenerating[page._pathOut] then
		errorf(2, "Recursive page generation detected. (You may want to call lock() in '%s')", page._path)
	end

	page._isGenerating = true
	pagesGenerating[page._pathOut] = true

	local pathRel  = page._path
	local filename = getFilename(pathRel)
	local ext      = getExtension(filename)
	local extLower = ext:lower()

	local result

	if page.isPage.v then
		local pageContent = parseAndRunTemplate(page, page._pathForError, template, nil, false)

		if
			(page.isDraft.v and not includeDrafts            ) or -- Is draft?
			(datetimeToTime(page.publishDate:g()) > os.time())    -- Is in future?
		then
			page._isSkipped               = true
			_G.outputFileSkippedPageCount = outputFileSkippedPageCount + 1

			pagesGenerating[page._pathOut] = nil
			page._isGenerating = false
			page._readonly     = true
			return
		end

		page.content.v = pageContent

		local layoutTemplate, layoutPath = getLayoutTemplate(page)
		result                           = parseAndRunTemplate(page, layoutPath, layoutTemplate, "html", true)

		page.content.v = "" -- We don't need this anymore.

	else
		result = parseAndRunTemplate(page, page._pathForError, template, nil, false)
	end

	writeOutputFile(page._category, page._pathOut, page.url.v, result, modTime)
	page._isGenerated = true

	pagesGenerating[page._pathOut] = nil
	page._isGenerating = false
	page._readonly     = true
end

function _G.generateFromTemplateFile(page)
	if page._isSkipped then  return  end
	if page._isGenerating and page._isLocked then  return  end -- Allowed recursion.

	local path     = DIR_CONTENT.."/"..page._path
	local template = assert(getFileContents(path))
	local modTime  = lfs.attributes(path, "modification")

	if modTime then
		page.date.v = getDatetime(modTime) -- Default value.
	end

	generateFromTemplate(page, template, modTime)
end

function _G.generateRedirection(url, targetUrl)
	assertArg(1, url,       "string")
	assertArg(2, targetUrl, "string")

	if not url:find"^/" then
		errorf(2, "Redirection URLs must begin with a '/'. (%s)", url)
	end

	if url:find"?" or not url:find"/$" then
		if unwrittenRedirects[url] == targetUrl then
			errorf(2, "Duplicate redirect from '%s' to '%s'.", url, targetUrl)
		elseif unwrittenRedirects[url] then
			errorf(2, "Duplicate redirect from '%s' (to different targets).", url)
		end

		unwrittenRedirects[url] = targetUrl
		return
	end

	if writtenRedirects[url] == targetUrl then
		errorf(2, "Duplicate redirect from '%s' to '%s'.", url, targetUrl)
	elseif writtenRedirects[url] then
		errorf(2, "Duplicate redirect from '%s' (to different targets).", url)
	end

	local pathRel  = url:gsub("/?$", "/index.html", 1):gsub("^/", "")
	local contents = formatTemplate(
		[=[
			<!DOCTYPE html>
			<html>
				<head>
					<meta charset="utf-8">
					<meta name="robots" content="noindex">
					<meta http-equiv="refresh" content="0; url=:urlPercent:">
					<title>:url:</title>
					<link rel="canonical" href=":urlPercent:">
				</head>
				<body>
					<p>Page has moved. If you are not redirected automatically,
					click <a href=":urlPercent:">here</a>.</p>
				</body>
			</html>
		]=], {
			url        = encodeHtmlEntities(              targetUrl ),
			urlPercent = encodeHtmlEntities(toUrlAbsolute(targetUrl)),
		}
	)

	writeOutputFile("page", pathRel, url, contents)
	writtenRedirects[url] = targetUrl
end



-- value = assertArg( [ functionName=auto, ] argumentNumber, value, expectedValueType1, ... [, depth=2 ] )
do
	local function _assertArg(fName, n, v, ...)
		local vType       = type(v)
		local varargCount = select("#", ...)
		local lastArg     = select(varargCount, ...)
		local hasDepthArg = (type(lastArg) == "number")
		local typeCount   = varargCount+(hasDepthArg and -1 or 0)

		for i = 1, typeCount do
			if vType == select(i, ...) then  return v  end
		end

		local depth = 2 + (hasDepthArg and lastArg or 2)

		if not fName then
			fName = debug.traceback("", depth-1):match": in function '(.-)'" or "?"
		end

		local expects = table.concat({...}, " or ", 1, typeCount)

		errorf(depth, "bad argument #%d to '%s' (%s expected, got %s)", n, fName, expects, vType)
	end

	function _G.assertArg(fNameOrArgNum, ...)
		if type(fNameOrArgNum) == "string" then
			return (_assertArg(fNameOrArgNum, ...))
		else
			return (_assertArg(nil, fNameOrArgNum, ...))
		end
	end
end



function _G.indexOf(t, v)
	for i, item in ipairs(t) do
		if item == v then  return i  end
	end
	return nil
end

function _G.itemWith(t, k, v)
	for i, item in ipairs(t) do
		if item[k] == v then  return item, i  end
	end
	return nil
end

function _G.itemWithAll(t, k, v)
	local items = {}
	for _, item in ipairs(t) do
		if item[k] == v then  table.insert(items, item)  end
	end
	return items
end



do
	local ENTITIES = {
		["&"] = "&amp;",
		["<"] = "&lt;",
		[">"] = "&gt;",
		['"'] = "&quot;",
		["'"] = "&#39;",
	}

	function _G.encodeHtmlEntities(s)
		return (s:gsub("[&<>\"']", ENTITIES))
	end
end



function _G.markdownToHtml(md)
	return markdownLib(md)
end



function _G.pack(...)
	return {n=select("#", ...), ...}
end



-- template, path = getLayoutTemplate( page )
function _G.getLayoutTemplate(page)
	local path = F("%s/%s.html", DIR_LAYOUTS, page.layout.v)

	local template = layoutTemplates[path]
	if template then  return template, path  end

	local template, err = getFileContents(path)
	if not template then
		errorf("%s: Could not load layout '%s'. (%s)", page._path, page.layout.v, err)
	end

	layoutTemplates[path] = template
	return template, path
end



-- parts = splitString( string, separatorPattern [, startIndex=1, plain=false ] )
function _G.splitString(s, sep, i, plain)
	i = i or 1
	local parts = {}

	while true do
		local i1, i2 = s:find(sep, i, plain)
		if not i1 then  break  end

		table.insert(parts, s:sub(i, i1-1))
		i = i2+1
	end

	table.insert(parts, s:sub(i))
	return parts
end



function _G.datetimeToTime(datetime)
	assertArg(1, datetime, "string")

	local date = dateLib(datetime)
	local time = (date-dateLib.epoch()):spanseconds()

	return time
end

-- datetime = getDatetime( [ time=now ] )
function _G.getDatetime(time)
	assertArg(1, time, "number","nil")

	local date     = dateLib(time or os.time()):tolocal()
	local datetime = date:fmt"${iso}%z" :gsub("..$", ":%0") :gsub("%+00:00$", "Z")

	return datetime
end



function _G.unindent(s)
	local indent = s:match"^\t+"
	if indent then
		s = s
			:gsub("\n"..indent, "\n")
			:sub(#indent+1)
			:gsub("\t+$", "")
	end

	return s
end



function _G.pushContext(ctxName)
	local ctx = {_name=ctxName, _scriptEnvironmentGlobals={}}
	table.insert(contextStack, ctx)
	return ctx
end

function _G.popContext(ctxName)
	assertContext(ctxName)
	table.remove(contextStack)
end

-- assertContext( contextName [, functionContext, errorLevel=2 ] )
function _G.assertContext(ctxName, funcContext, errLevel)
	local ctx = contextStack[#contextStack]
	if not ctx or ctx._name ~= ctxName then
		errLevel = (errLevel or 2) + 1
		if funcContext then
			errorf(errLevel, "[%s] Context is wrong. (Expected '%s', but is '%s')", funcContext, ctxName, (ctx and ctx._name or "none"))
		else
			errorf(errLevel,      "Context is wrong. (Expected '%s', but is '%s')",              ctxName, (ctx and ctx._name or "none"))
		end
	end
end

-- context = getContext( [ requiredContextName=any ] )
function _G.getContext(ctxName)
	if ctxName then  assertContext(ctxName)  end
	return contextStack[#contextStack] or error("There is no context.", 2)
end



-- thumbnailInfo = createThumbnail( imagePathRelative, thumbWidth [, thumbHeight, errorLevel=1 )
do
	local imageCreatorMethods = {
		["png"]  = "pngStr",
		["jpg"]  = "jpegStr",
		["jpeg"] = "jpegStr",
		["gif"]  = "gifStr",
	}

	function _G.createThumbnail(pathImageRel, thumbW, thumbH, errLevel)
		thumbW   = thumbW or 0
		thumbH   = thumbH or 0
		errLevel = (errLevel or 1)+1

		local gd = pcall(require, "gd") and require"gd" or nil

		if not gd then
			error("Failed loading Lua-GD.", errLevel)
		elseif thumbW == 0 and thumbH == 0 then
			error("Thumbnail images must have at least a width or a height.", errLevel)
		end

		local id = F("%s:%dx%d", pathImageRel, thumbW, thumbH)
		if thumbnailInfos[id] then
			return thumbnailInfos[id]
		end

		local filename  = getFilename(pathImageRel)
		local basename  = getBasename(filename)
		local ext       = getExtension(filename)
		local extLower  = ext:lower()
		local folder    = pathImageRel:sub(1, #pathImageRel-#filename) -- Ending in "/".
		local pathImage = DIR_CONTENT.."/"..pathImageRel

		local image, err = loadImage(pathImageRel)
		if not image then
			error(err, errLevel)
		end

		local imageW, imageH = image:sizeXY()
		assert(imageW > 0)
		assert(imageH > 0)
		local aspectRatio = imageW/imageH

		if thumbW == 0 then
			thumbW = round(thumbH*aspectRatio)
		elseif thumbH == 0 then
			thumbH = round(thumbW/aspectRatio)
		end
		thumbW = math.max(thumbW, 1)
		thumbH = math.max(thumbH, 1)

		local pathThumbRel = F("%s%s.%dx%d.%s", folder, basename, thumbW, thumbH, "jpg")--ext)

		local thumbInfo = {
			path   = pathThumbRel,
			width  = thumbW,
			height = thumbH,
		}

		local pathThumbOutputRel = rewriteOutputPath(pathThumbRel)

		local modTimeImage = lfs.attributes(pathImage, "modification")
		local modTimeThumb = lfs.attributes(DIR_OUTPUT.."/"..pathThumbOutputRel, "modification")

		if modTimeImage and modTimeImage == modTimeThumb and not ignoreModificationTimes then
			-- @Note: This will bypass any file processor for JPG files. Not sure if OK. 2018-06-30
			preserveExistingOutputFile("raw", pathThumbRel, "/"..pathThumbRel)

		else
			local scale = math.min(imageW/thumbW, imageH/thumbH)

			local thumb = gd.createTrueColor(thumbW, thumbH)
			thumb:copyResampled(
				image,
				0, -- dstX
				0, -- dstY
				round((imageW-thumbW*scale)/2), -- srcX
				round((imageH-thumbH*scale)/2), -- srcY
				thumbW, -- dstW
				thumbH, -- dstH
				round(thumbW*scale), -- srcW
				round(thumbH*scale)  -- srcH
			)

			local imageCreatorMethod = "jpegStr"--assert(imageCreatorMethods[extLower], extLower)
			local contents = thumb[imageCreatorMethod](thumb, 75)
			writeOutputFile("raw", pathThumbRel, "/"..pathThumbRel, contents, modTimeImage)
		end

		thumbnailInfos[id] = thumbInfo
		return thumbInfo
	end

end



function _G.round(n)
	return math.floor(n+.5)
end



-- builder = newStringBuilder( )
do
	local mt = {
		__call = function(b, ...)
			local argCount = select("#", ...)
			if argCount == 0 then  return table.concat(b)  end

			local s = (argCount == 1) and tostring(...) or F(...)
			table.insert(b, s)
		end,
	}

	function _G.newStringBuilder()
		return setmetatable({}, mt)
	end
end



do
	local function removeIndexFilename(pathRel)
		local sitePath = pathToSitePath(pathRel) :gsub("/index%.%w+$", "/")
		return sitePathToPath(sitePath)
	end

	function _G.newPage(pathRel)
		assertArg(1, pathRel, "string")

		local filename = getFilename(pathRel)
		local ext      = getExtension(filename)
		local extLower = ext:lower()

		if not fileTypes[extLower] then
			errorf("Invalid template extension '%s'. (You may want to specify config.types[\"%s\"])", extLower, extLower)
		end

		local isPage  = isAny(fileTypes[extLower], "markdown", "html")
		local isIndex = isPage  and getBasename(filename) == "index"
		local isHome  = isIndex and pathRel == filename

		local category = isPage and "page" or "template"

		local permalinkRel = (
			not isPage and pathRel
			or isHome  and ""
			or isIndex and pathRel:sub(1, -#filename-1)
			or pathRel:sub(1, -#ext-2).."/"
		)

		local pathRelOut
			=  (not isPage and permalinkRel)
			or (permalinkRel == "" and "" or permalinkRel).."index.html"

		local isSpecial =
			not isPage
			or attributeWithAny(
				htaErrors,
				"/"..permalinkRel,
				"/"..pathRelOut,
				"/"..rewriteOutputPath(pathRelOut),
				"/"..removeIndexFilename(rewriteOutputPath(pathRelOut))
			) ~= nil

		local page; page = {
			_readonly = false,

			_category     = category,
			_isGenerating = false,
			_isGenerated  = false,
			_isSkipped    = false,
			_isLocked     = false,
			_path         = pathRel,
			_pathOut      = pathRelOut,
			_pathForError = F("%s/%s", DIR_CONTENT, pathRel),
			_extension    = extLower,

			isPage = {
				v = isPage,
				g = function(field)  return field.v  end,
			},
			isIndex = {
				v = isIndex,
				g = function(field)  return field.v  end,
			},
			isHome = {
				v = isHome,
				g = function(field)  return field.v  end,
			},

			layout = {
				v = site.defaultLayout.v,
				g = function(field)  return field.v  end,
				s = function(field, layoutName)  field.v = layoutName  end,
			},
			title = {
				v = "",
				g = function(field)  return field.v  end,
				s = function(field, title)  field.v = title  end,
			},
			content = {
				v = "",
				g = function(field)  return field.v  end,
			},

			date = {
				v = getDatetime(0),
				g = function(field)  return field.v  end,
				s = function(field, datetime)  field.v = datetime  end,
			},
			publishDate = {
				v = "",
				g = function(field)  return field.v ~= "" and field.v or page.date.v  end,
				s = function(field, datetime)
					assertContext("template", "publishDate", 3)
					assertArg(1, datetime, "string")
					field.v = datetime
				end,
			},
			isDraft = {
				v = false,
				g = function(field)  return field.v  end,
				s = function(field, state)  field.v = state  end,
			},
			isSpecial = {
				v = isSpecial,
				g = function(field)  return field.v  end,
				s = function(field, state)  field.v = state  end,
			},

			aliases = {
				v = {},
				g = function(field)  return page._readonly and {unpack(field.v)} or field.v  end,
				s = function(field, aliases)  field.v = aliases  end,
			},

			url = {
				v = "/"..permalinkRel,
				g = function(field)  return field.v  end,
			},
			permalink = {
				v = site.baseUrl.v..(noTrailingSlash and permalinkRel:gsub("/$", "") or permalinkRel),
				g = function(field)  return field.v  end,
			},
			rssLink = {
				v = "", -- @Incomplete @Doc
				g = function(field)  return field.v  end,
			},

			params = {
				v = {},
				g = function(field)  return field.v  end,
			},
		}
		-- print(pathRel, (not isPage and " " or isHome and "H" or isIndex and "I" or "P"), page.permalink.v)

		return page
	end

end



function _G.pathToSitePath(pathRel)
	if pathRel:find"^/" then
		errorf(2, "Path is not valid: %s", pathRel)
	end
	return "/"..pathRel
end

function _G.sitePathToPath(sitePath)
	if not sitePath:find"^/" then
		errorf(2, "Path is not a valid site path - they must start with '/': %s", sitePath)
	end
	return (sitePath:gsub("^/", ""))
end



-- Return any data as a Lua code string.
-- luaString = serializeLua( value )
do
	local SIMPLE_TYPES = {["boolean"]=true,["nil"]=true,["number"]=true}
	local KEYWORDS = {
		["and"]=true,["break"]=true,["do"]=true,["else"]=true,["elseif"]=true,
		["end"]=true,["false"]=true,["for"]=true,["function"]=true,["if"]=true,
		["in"]=true,["local"]=true,["nil"]=true,["not"]=true,["or"]=true,["repeat"]=true,
		["return"]=true,["then"]=true,["true"]=true,["until"]=true,["while"]=true,
	}

	local function _serializeLua(out, data)
		local dataType = type(data)

		if dataType == "table" then
			local first   = true
			local i       = 0
			local indices = {}

			local insert = table.insert
			insert(out, " { ")

			while true do
				i = i+1

				if data[i] == nil then
					i = i+1
					if data[i] == nil then  break  end

					if not first then  insert(out, ",")  end
					insert(out, "nil")
					first = false
				end

				if not first then  insert(out, ",")  end
				first = false

				_serializeLua(out, data[i])
				indices[i] = true
			end

			for k, v in pairs(data) do
				if not indices[k] then
					if not first then  insert(out, ",")  end
					first = false

					if not KEYWORDS[k] and type(k) == "string" and k:find"^[a-zA-Z_][a-zA-Z0-9_]*$" then
						insert(out, k)
					else
						insert(out, "[")
						_serializeLua(out, k)
						insert(out, "]")
					end

					insert(out, "=")
					_serializeLua(out, v)
				end
			end

			insert(out, " } ")

		elseif dataType == "string" then
			table.insert(out, F("%q", data))

		elseif SIMPLE_TYPES[dataType] then
			table.insert(out, tostring(data))

		else
			errorf("Cannot serialize value type '%s'. (%s)", dataType, tostring(data))
		end

		return out
	end

	function _G.serializeLua(data)
		return (table.concat(_serializeLua({}, data)))
	end

end



function _G.getKeys(t)
	local keys = {}
	for k in pairs(t) do  table.insert(keys, k)  end
	return keys
end



function _G.urlExists(url)
	if not url:find"^/" then
		errorf(2, "Local URLs must begin with a '/'. (%s)", url)
	end

	return writtenOutputUrls[url] == true
end



-- bool = isAny( valueToCompare, value1, ... )
-- bool = isAny( valueToCompare, arrayOfValues )
function _G.isAny(v, ...)
	local len = select("#", ...)

	if len == 1 and type(...) == "table" then
		for _, item in ipairs(...) do
			if v == item then  return true  end
		end

	else
		for i = 1, len do
			if v == select(i, ...) then  return true  end
		end
	end

	return false
end



function _G.rewriteOutputPath(pathRel)
	local sitePath = pathToSitePath(pathRel)

	for _, pat in ipairs(rewriteExcludes) do
		if sitePath:find(pat) then  return pathRel  end
	end

	if type(outputPathFormat) == "function" then
		local sitePathNew = outputPathFormat(sitePath)

		if type(sitePathNew) ~= "string" then
			errorf("config.rewriteOutputPath() did not return a string. (%s)", sitePath)
		elseif sitePathNew == "" then
			errorf("config.rewriteOutputPath() returned an empty string. (%s)", sitePath)
		end

		return (sitePathToPath(sitePathNew))

	else
		return (sitePathToPath(F(outputPathFormat, sitePath)))
	end
end



-- removeItem( array, value1, ... )
function _G.removeItem(t, ...)
	for i = 1, select("#", ...) do
		local iToRemove = indexOf(t, select(i, ...))

		if iToRemove then  table.remove(t, iToRemove)  end
	end
end



-- Same as string.gsub(), but "%" has no meaning in the substitution.
function _G.gsubPlainSub(s, pat, repl)
	return s:gsub(pat, (repl:gsub("%%", "%%%%")))
end



-- string = htaccessRewriteEscapeTestString( string )
function _G.htaccessRewriteEscapeTestString(s)
	s = s:gsub('[$%%\\"]', "\\%0")

	return s
end

-- string = htaccessRewriteEscapeCondPattern( string [, isWhole=false ] )
function _G.htaccessRewriteEscapeCondPattern(s, isWhole)
	s = s:gsub('[$%%\\".+*?^()[%]]', "\\%0")

	if isWhole then  s = s:gsub("^[!=<>]", "\\%0")  end

	return s
end

-- string = htaccessRewriteEscapeRuleSubstitution( string [, isWhole=false ] )
function _G.htaccessRewriteEscapeRuleSubstitution(s, isWhole)
	if isWhole and s == "-" then  return "\\-"  end

	return (s:gsub('[$%%\\"]', "\\%0"))
end



-- Compute the difference in seconds between local time and UTC. (Normal time.)
-- http://lua-users.org/wiki/TimeZone
function _G.getTimezone()
	local now = os.time()
	return os.difftime(now, os.time(os.date("!*t", now)))
end

-- Return a timezone string in ISO 8601:2000 standard form (+hhmm or -hhmm).
function _G.getTimezoneOffsetString(tz)
	local h, m = math.modf(tz/3600)
	return F("%+.4d", 100*h+60*m)
end

-- Return the timezone offset in seconds, as it was on the given time. (DST obeyed.)
-- timezoneOffset = getTimezoneOffset( [ time=now ] )
function _G.getTimezoneOffset(time)
	time = time or os.time()
	local dateUtc   = os.date("!*t", time)
	local dateLocal = os.date("*t",  time)
	dateLocal.isdst = false -- This is the trick.
	return os.difftime(os.time(dateLocal), os.time(dateUtc))
end



function _G.isArgs(...)
	return select("#", ...) > 0
end



do
	local errMt = {
		__tostring = function(errObj)
			return
				errObj.stack[1]
				and F(
					"ERROR: %s\nstack traceback:\n\t%s\n",
					errObj.message, table.concat(errObj.stack, "\n\t")
				)
				or F("ERROR: %s\n", errObj.message)
		end,
	}

	function _G.xpcallErrorHandler(err)
		return isErrorObject(err) and err or makeError(tostring(err), 2)
	end

	local function fixLineNumbers(s)
		s = s:gsub("([^\n]*)\n?", function(sLine)
			if sLine == "" then  return  end

			local path, lnPos, lnStr = sLine:match"(%S*%.[%w_]+):()(%d+): " -- Not robust at all, but should work in most cases, at least for internally constructed error messages.

			local luaCode = templateMetaprogramCache[path]
			if not luaCode then  return  end

			local ln           = tonumber(lnStr)
			local lnInTemplate = 0

			for line in luaCode:gmatch"([^\n]*)\n?" do
				ln                = ln - 1
				local mappedLnStr = line:match"^%-%- @LINE(%d+)$"
				lnInTemplate      = (mappedLnStr and tonumber(mappedLnStr)-1 or lnInTemplate+1)

				if ln == 0 then  break  end
			end

			sLine = sLine:sub(1, lnPos-1) .. lnInTemplate .. sLine:sub(lnPos+#lnStr)
			return sLine
		end)

		return s
	end

	function _G.makeError(message, level)
		assertArg(1, message, "string")
		assertArg(2, level,   "number","nil")

		level       = (level == 0) and 0 or (level or 1)
		local stack = {}

		if level > 0 then
			while level < 1/0 do
				level = level + 1

				local info = debug.getinfo(level, "nSl")
				if not info then  break  end

				local isFile     = info.source:find"^@" ~= nil
				local sourceName = cleanupPath(isFile and info.source:sub(2) or info.short_src)

				if isFile then
					sourceName = cleanupPath(sourceName)
				end

				local b = newStringBuilder()
				b("%s:", sourceName)

				if info.currentline > 0 then
					b("%d:", info.currentline)
				end

				if info.name then
					b(" in '%s'", info.name)
				elseif info.what == "main" then
					b(" in main chunk")
				elseif info.what == "C" or info.what == "tail" then
					b(" ?")
				else
					b(" in <%s:%d>", getFilename(sourceName), info.linedefined)
				end

				table.insert(stack, fixLineNumbers(b()))
			end

			while stack[#stack] == "[C]: ?" do
				stack[#stack] = nil
			end
		end

		message = fixLineNumbers(message:gsub("^.-:%d+: ", cleanupPath))

		local errObj = setmetatable({message=message, stack=stack}, errMt)
		return errObj
	end

	function _G.makeErrorf(level, s, ...)
		if type(level) == "number" then
			return (makeError(F(s, ...), level+1))
		else
			return (makeError(F(level, s, ...), 2))
		end
	end

	function _G.isErrorObject(v)
		return type(v) == "table" and getmetatable(v) == errMt
	end
end



function _G.cleanupPath(someKindOfPath)
	local path = toNormalPath(someKindOfPath)

	repeat
		local count
		path, count = path:gsub("/[^/]+/%.%./", "/", 1) -- Not completely fool proof! @Robustness
	until count == 0

	return path
end



function _G.ipairsr(t)
	return iprev, t, #t+1
end

function _G.iprev(t, i)
	i = i-1
	local v = t[i]
	if v ~= nil then  return i, v  end
end



function _G.pairsSorted(t)
	local keys = sortNatural(getKeys(t))
	local i    = 0

	return function()
		i = i+1
		local k = keys[i]
		if k ~= nil then  return k, t[k]  end
	end
end



function _G.attributeWith(t, v)
	for k, item in pairs(t) do
		if item == v then  return k  end
	end
	return nil
end

function _G.attributeWithAny(t, ...)
	for k, item in pairs(t) do
		if isAny(item, ...) then  return k  end
	end
	return nil
end



function _G.sort(t, ...)
	table.sort(t, ...)
	return t
end



do
	local initted = false
	local gd, imageLoaders

	local function init()
		if initted then  return  end

		initted = true
		gd      = pcall(require, "gd") and require"gd" or nil

		if not gd then
			error("Failed loading Lua-GD.")
		end

		imageLoaders = {
			["png"]  = gd.createFromPng,
			["jpg"]  = gd.createFromJpeg,
			["jpeg"] = gd.createFromJpeg,
			["gif"]  = gd.createFromGif,
		}
	end

	function _G.loadImage(pathImageRel)
		init()

		local filename  = getFilename(pathImageRel)
		local extLower  = getExtension(filename):lower()
		local pathImage = DIR_CONTENT.."/"..pathImageRel

		if not isFile(pathImage) then
			return nil, F("File does not exist: %s", pathImage)
		end

		local imageLoader = imageLoaders[extLower]
		if not imageLoader then
			return nil, F("Unknown image file format '%'.", extLower)
		end

		local image = imageLoader(pathImage)
		if not image then
			return nil, F("Could not load image '%s'. Maybe the image is corrupted?", pathImage)
		end

		return image
	end
end

function _G.getImageDimensions(pathImageRel)
	local image, err = loadImage(pathImageRel)
	if not image then  return nil, err  end

	return image:sizeXY()
end



do
	local initted = false
	local socket

	local function init()
		if initted then  return  end
		initted = true
		socket  = pcall(require, "socket.core") and require"socket.core" or nil
	end

	function _G.getTimeBetter()
		init()
		return socket and socket.gettime() or os.time()
	end

	function _G.sleep(duration)
		init()
		if socket then
			socket.sleep(duration)
		else
			local endTime = getTimeBetter() + duration
			repeat until getTimeBetter() >= endTime -- @Incomplete: Do something to waste time?
		end
	end
end



function _G.getCwd()
	return (toNormalPath(lfs.currentdir()))
end



-- count = countStrings( string, needle [, plain=false ] )
function _G.countStrings(s, needle, plain)
	local count = 0
	local pos   = 1

	while true do
		local _, i2 = s:find(needle, pos, plain)
		if not i2 then  return count  end
		pos = i2 + 1
	end
end



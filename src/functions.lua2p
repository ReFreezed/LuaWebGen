--[[============================================================
--=
--=  Global Functions
--=
--=-------------------------------------------------------------
--=
--=  LuaWebGen - static website generator in Lua!
--=  - Written by Marcus 'ReFreezed' Thunstr√∂m
--=  - MIT License (See LICENSE.txt)
--=
--==============================================================

	assertArg
	attributeWith, attributeWithAny
	cleanupPath
	countStrings, countSubStrings
	createDirectory, isDirectoryEmpty, removeEmptyDirectories
	createThumbnail
	datetimeToTime, getDatetime
	encodeHtmlEntities
	error, errorf, fileError, errorLine
	F, formatBytes, formatTemplate
	generateFromTemplate, generateFromTemplateFile, generateRedirection
	generatorMeta
	getCwd
	getDirectory, getFilename, getExtension, getBasename
	getFileContentsBinary, getFileContentsText
	getKeys
	getLayoutTemplate
	getLineNumber
	getProtectionWrapper
	getTimeBetter, sleep
	getTimezone, getTimezoneOffsetString, getTimezoneOffset
	gsubPlainSub
	htaccessRewriteEscapeTestString, htaccessRewriteEscapeCondPattern, htaccessRewriteEscapeRuleSubstitution
	indexOf, itemWith, itemWithAll
	ipairsr, iprev
	isAny
	isArgs
	isFile, isDirectory
	isStringMatchingAnyPattern
	loadImage, getImageDimensions
	markdownToHtml
	newDataFolderReader, isDataFolderReader, preloadData
	newPage
	newStringBuilder
	pack
	pairsSorted
	parseAndRunTemplate
	pathToSitePath, sitePathToPath
	printNoLog, printfNoLog, log, print, printOnce, printf, printfOnce, timestampPrint, timestampPrintOnce, timestampPrintVerbose, timestampPrintError, timestampPrintWarning, timestampPrintWarningOnce, printObject
	pushContext, popContext, assertContext, getContext
	removeItem
	rewriteOutputPath
	round
	serializeLua
	sort
	sortNatural, compareNatural
	splitString
	toNormalPath, toWindowsPath
	tostringForTemplates
	toUrl, toUrlAbsolute, urlize, toPrettyUrl
	traverseDirectory, traverseFiles
	trim, trimNewlines
	unindent
	urlExists
	writeOutputFile, preserveExistingOutputFile
	xpcallErrorHandler, makeError, makeErrorf, isErrorObject

--============================================================]]

!local PRINT_METAPROGRAMS = DEV and 1==0

local templateMetaprogramCache = {}



function _G.traverseDirectory(dirPath, ignoreFolders, cb, _pathRelStart)
	_pathRelStart = _pathRelStart or #dirPath+2

	for filename in lfs.dir(dirPath) do
		local path = dirPath.."/"..filename

		if filename ~= "." and filename ~= ".." then
			local mode = lfs.attributes(path, "mode")

			if mode == "file" then
				local pathRel = path:sub(_pathRelStart)
				local abort   = cb(path, pathRel, filename, "file")
				if abort then  return true  end

			elseif mode == "directory" and not (ignoreFolders and isStringMatchingAnyPattern(filename, ignoreFolders)) then
				local pathRel = path:sub(_pathRelStart)
				local abort   = cb(path, pathRel, filename, "directory")
				if abort then  return true  end

				local abort = traverseDirectory(path, ignoreFolders, cb, _pathRelStart)
				if abort then  return true  end
			end

		end
	end

end

function _G.traverseFiles(dirPath, ignoreFolders, cb, _pathRelStart)
	_pathRelStart = _pathRelStart or #dirPath+2

	for filename in lfs.dir(dirPath) do
		local path = dirPath.."/"..filename

		if filename ~= "." and filename ~= ".." then
			local mode = lfs.attributes(path, "mode")

			if mode == "file" then
				local pathRel  = path:sub(_pathRelStart)
				local extLower = getExtension(filename):lower()
				local abort    = cb(path, pathRel, filename, extLower)
				if abort then  return true  end

			elseif mode == "directory" and not (ignoreFolders and isStringMatchingAnyPattern(filename, ignoreFolders)) then
				local abort = traverseFiles(path, ignoreFolders, cb, _pathRelStart)
				if abort then  return true  end
			end

		end
	end

end



function _G.isStringMatchingAnyPattern(s, patterns)
	for _, pat in ipairs(patterns) do
		if s:find(pat) then  return true  end
	end
	return false
end



function _G.getFileContentsBinary(path)
	local file, err = io.open(path, "rb")
	if not file then  return nil, err  end

	local contents = file:read"*a"
	file:close()

	return contents
end

function _G.getFileContentsText(path)
	local file, err = io.open(path, "r")
	if not file then  return nil, err  end

	local contents = file:read"*a"
	file:close()

	if contents:find("\r", 1, true) then
		contents = contents:gsub("\n?\r\n?", "\n")
	end

	return contents
end



do
	-- isValueExpression = insertLuaForEchoingIfExpression( luaOutputBuffer, luaCode )
	local function insertLuaForEchoingIfExpression(out, luaCode)
		-- Note: echo() and echoRaw() do the same thing in e.g. CSS files, so we
		-- can output the same code here no matter what file is being processed.
		-- It is a thing we can optimize though. @Speed
		local doBlock = F("do  local v = (%s)  if type__(v) == 'string' and v:find'^%%s*<[!%%a/].*>%%s*$' then  echoRaw__(v)  elseif v ~= nil then  echo__(v)  end end ", luaCode)
		if not loadstring(doBlock) then  return false  end

		table.insert(out, doBlock)
		return true
	end

	local BRACKET_ENDS = {
		["("] = ")",
		["{"] = "}",
		["["] = "]",
	}

	local function findEndOfBlockContents(path, template, pos)
		!local PRINT_PROGRESS = DEV and 1==0
		!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: >>>>>>>>", path, pos, getLineNumber(template, pos))`  end

		local blockContentsI1 = pos

		local bracketBalance        = 0
		local bracketStartPositions = {}
		local bracketEndCharacters  = {}

		while true do
			--
			-- Note: We don't need to match every Lua token - only those that could
			-- intercept our search for the "}}" at the end of the code block.
			--
			-- @Speed? Positions can sometimes be cached between iterations.
			--
			local posBlockEnd     = bracketBalance == 0 and template:find("%*?}}", pos) or nil
			local posComment      = template:find("--",     pos, true)
			local posStringShort  = template:find("[\"']",  pos, false)
			local posStringLong   = template:find("%[=*%[", pos, false)
			local posBracketStart = template:find("[({%[]", pos, false)
			local posBracketEnd   = template:find("[)}%]]", pos, false)

			local posNext = math.min(
				(posBlockEnd     or 1/0),
				(posComment      or 1/0),
				(posStringShort  or 1/0),
				(posStringLong   or 1/0),
				(posBracketStart or 1/0),
				(posBracketEnd   or 1/0)
			)

			if posNext == posBlockEnd then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: <<<<<<<<", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBlockEnd - 1
				return pos

			elseif posNext == posComment then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Comment", path, posNext, getLineNumber(template, posNext))`  end
				pos                   = posComment
				local longStringLevel = template:match("^%[(=*)%[", pos+2)

				if longStringLevel then
					pos         = pos + 4 + #longStringLevel -- Eat "--[=[".
					local _, i2 = template:find("%]"..longStringLevel.."%]", pos)

					if not i2 then
						fileError(
							path, template, pos,
							"Incomplete long comment. (Code block starting at line %d)",
							getLineNumber(template, blockContentsI1)
						)
					end

					pos = i2+1

				else
					pos     = pos + 2 -- Eat "--".
					local i = template:find("\n", pos, true)
					pos     = i and i+1 or pos
				end

			elseif posNext == posStringShort then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: String", path, posNext, getLineNumber(template, posNext))`  end
				pos = posStringShort + 1

				local pat = "(["..template:sub(posStringShort, posStringShort).."\\])"

				while true do
					local i, _, c = template:find(pat, pos)
					if not i then
						fileError(
							path, template, posStringShort,
							"Missing end quote for string. (Code block starting at line %d)",
							getLineNumber(template, blockContentsI1)
						)
					end
					pos = i + 1
					if c == "\\" then
						pos = pos + 1 -- It's fine to always skip one character, even if the escape sequence is something like "\173". Any errors will be checked later by loadstring().
					else
						break
					end
				end

			elseif posNext == posStringLong then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: String (long)", path, posNext, getLineNumber(template, posNext))`  end
				pos                   = posStringLong
				local longStringLevel = template:match("^%[(=*)%[", pos)

				pos         = pos + 2 + #longStringLevel -- Eat "[=[".
				local _, i2 = template:find("%]"..longStringLevel.."%]", pos)

				if not i2 then
					fileError(
						path, template, pos,
						"Incomplete long string. (Code block starting at line %d)",
						getLineNumber(template, blockContentsI1)
					)
				end

				pos = i2 + 1

			elseif posNext == posBracketStart then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Bracket start", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBracketStart

				bracketBalance                        = bracketBalance + 1
				bracketStartPositions[bracketBalance] = pos
				bracketEndCharacters[bracketBalance]  = BRACKET_ENDS[template:sub(pos, pos)]

				pos = pos + 1

			elseif posNext == posBracketEnd then
				!if PRINT_PROGRESS then  __LUA`printf("%s(%d):%d: Bracket end", path, posNext, getLineNumber(template, posNext))`  end
				pos = posBracketEnd

				if bracketBalance == 0 then
					fileError(
						path, template, pos,
						"Unexpected '%s'. Too many end brackets. (Code block starting at line %d)",
						template:sub(pos, pos), getLineNumber(template, blockContentsI1)
					)
				end

				local bracketEndChar = bracketEndCharacters[bracketBalance]

				if template:sub(pos, pos) ~= bracketEndChar then
					fileError(
						path, template, pos,
						"Expected '%s' to end bracket starting at line %d, but got '%s'. (Code block starting at line %d)",
						bracketEndChar,
						getLineNumber(template, bracketStartPositions[bracketBalance]),
						template:sub(pos, pos),
						getLineNumber(template, blockContentsI1)
					)
				end

				bracketStartPositions[bracketBalance] = nil
				bracketEndCharacters[bracketBalance]  = nil
				bracketBalance                        = bracketBalance - 1

				pos = pos + 1

			else
				if bracketBalance > 0 then
					fileError(
						path, template, bracketStartPositions[bracketBalance],
						"Missing '%s'. Unbalanced brackets in code. (Code block starting at line %d)",
						bracketEndCharacters[bracketBalance], getLineNumber(template, blockContentsI1)
					)
				end

				fileError(
					path, template, pos,
					"Missing end of code block. (Code block starting at line %d)",
					getLineNumber(template, blockContentsI1)
				)
			end
		end

		assert(false)
	end

	-- endBlockI1, endBlockI2, endBlockContents = templateToLua( luaOutputBuffer, path, template, position, templateifiedControlStructureLevel, templateifiedControlStructurePosition )
	local function templateToLua(out, path, template, pos, tcsLevel, tcsPos)
		!local PATTERN_IDENT       = "[%a_][%w_]*"
		!local PATTERN_IDENT_BEGIN = "%f[%w_]"
		!local PATTERN_IDENT_END   = "%f[^%w_]"

		while pos <= #template do
			local blockI1Trimmed, blockI1, doTrim, blockContentsI1 = template:match(!(NOSPACE"() %s* () {{ (%*?) ()"), pos)
			if not blockI1 then  break  end

			local autoLock = (autoLockPages and blockI1Trimmed == 1)
			doTrim         = (doTrim == "*")
			local echoI2   = (doTrim and blockI1Trimmed or blockI1) - 1

			if doTrim and blockI1 > blockI1Trimmed then
				table.insert(out, ("\n"):rep(countSubStrings(template, blockI1Trimmed, blockI1-1, "\n", true))) -- :TrimBlocks
			end

			if pos <= echoI2 then
				local plainSegment = template:sub(pos, echoI2)
				table.insert(out, "echoRaw__'") -- Note: Templates will probably have more double quotes than single, that's why we use single quotes here - for nicer metaprogram output. :TemplateOutputQuotes
				table.insert(out, (plainSegment:gsub("[\\'\n]", "\\%0")))
				table.insert(out, "'")
			end

			pos = blockContentsI1

			table.insert(out, "do end ") -- Statement divider.

			local blockContentsI2 = findEndOfBlockContents(path, template, pos)
			local blockContents   = template:sub(blockContentsI1, blockContentsI2)
			pos                   = blockContentsI2 + 1

			!if DEV and 1==0 then
				print("BLOCK: "..trim(blockContents))
			!end

			doTrim, pos = template:match(!(NOSPACE"^(%*?) }} ()"), pos)
			doTrim      = (doTrim == "*")

			!local TRIM_POS_AFTER_BLOCK = `
			if doTrim then
				local posAfterBlock;posAfterBlock, pos = template:match("^()%s*()", pos)
				if pos > posAfterBlock then
					table.insert(out, ("\n"):rep(countSubStrings(template, posAfterBlock, pos, "\n", true))) -- :TrimBlocks
				end
			end
			`

			----------------------------------------------------------------

			-- Match custom keywords first so we don't confuse those with normal Lua identifiers later.

			-- fori [<] item in <array> (...) end
			-- fori [<] <array> (...) end
			if blockContents:find!("^ *fori"..PATTERN_IDENT_END) then
				local             reverse, ident, expr = blockContents:match!(NOSPACE("^ %s* fori %s* (< ) %s* ("..PATTERN_IDENT..") %s+ in "..PATTERN_IDENT_END.." %s* (%S.*)"))
				if not expr then           ident, expr = blockContents:match!(NOSPACE("^ %s* fori %s+          ("..PATTERN_IDENT..") %s+ in "..PATTERN_IDENT_END.." %s* (%S.*)"))
				if not expr then  reverse,        expr = blockContents:match!(NOSPACE("^ %s* fori %s* (<?) %s*                                                          (%S.*)"))
				if not expr then
					fileError(path, template, blockI1, "Invalid 'fori' statement.")
				end end end

				reverse = (reverse == "<")

				if not loadstring("_=("..expr..")") then
					fileError(path, template, blockI1, "Invalid value expression for 'fori' loop: %s", trim(expr)) -- @UX: Better error message.
				end

				table.insert(out, "for i, ")
				table.insert(out, (ident or "it"))
				table.insert(out, " in ")
				table.insert(out, (reverse and "foriReverse__" or "fori__"))
				table.insert(out, "(")
				table.insert(out, expr)
				table.insert(out, ") do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'fori' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, "end ")
				pos = scopeEndBlockI2 + 1

			-- for index [, item, ... ] in <expression> (...) end
			-- for index = <from>, <to> [, <step> ] (...) end
			elseif
				blockContents:find!("^ *for%s+"..PATTERN_IDENT.."%s*[,=]") or
				blockContents:find!("^ *for%s+"..PATTERN_IDENT.."%s+in"..PATTERN_IDENT_END)
			then
				table.insert(out, blockContents) -- @Robustness: Surround value in parenthesis, when possible.
				table.insert(out, " do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'for' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, " end ")
				pos = scopeEndBlockI2 + 1

			-- for [<] <to> (...) end
			elseif blockContents:find!("^ *for"..PATTERN_IDENT_END) then
				-- for < <to>
				if blockContents:find"^ *for%s*<" then
					local expr = blockContents:gsub("for%s*<", "", 1)

					if not loadstring("_=("..expr..")") then
						fileError(path, template, blockI1, "Invalid value expression for simplified 'for' loop: %s", trim(expr)) -- @UX: Better error message.
					end

					table.insert(out, "for i = (")
					table.insert(out, expr)
					table.insert(out, "), 1, -1 do ")

				-- for <to>
				else
					local expr = blockContents:gsub("for", "", 1)

					if not loadstring("_=("..expr..")") then
						fileError(path, template, blockI1, "Invalid value expression for simplified 'for' loop: %s", trim(expr)) -- @UX: Better error message.
					end

					table.insert(out, "for i = 1, (")
					table.insert(out, expr)
					table.insert(out, ") do ")
				end

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'for' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, " end ")
				pos = scopeEndBlockI2 + 1

			-- do (...) end
			elseif blockContents:find!("^ *do"..PATTERN_IDENT_END) then
				-- @Polish: Make sure there's no garbage at the end of blockContents.
				table.insert(out, "do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'do' starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, " end ")
				pos = scopeEndBlockI2 + 1

			-- if <condition> (...) end
			elseif blockContents:find!("^ *if"..PATTERN_IDENT_END) then
				table.insert(out, blockContents) -- @Robustness: Surround value in parenthesis.
				table.insert(out, " then ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				while scopeEndBlockContents:find!("^ *elseif"..PATTERN_IDENT_END) do
					table.insert(out, scopeEndBlockContents)
					table.insert(out, " then ")

					scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, scopeEndBlockI2+1, tcsLevel+1, scopeEndBlockI1)
				end

				if scopeEndBlockContents:find!("^ *else"..PATTERN_IDENT_END) then
					table.insert(out, "else ")

					scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, scopeEndBlockI2+1, tcsLevel+1, scopeEndBlockI1)
				end

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'if' starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, "end ")
				pos = scopeEndBlockI2 + 1

			-- while <condition> (...) end
			elseif blockContents:find!("^ *while"..PATTERN_IDENT_END) then
				table.insert(out, blockContents) -- @Robustness: Surround value in parenthesis.
				table.insert(out, " do ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *end"..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'end' for 'while' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, "end ")
				pos = scopeEndBlockI2 + 1

			-- repeat (...) until <condition>
			elseif blockContents:find!("^ *repeat"..PATTERN_IDENT_END) then
				-- @Polish: Make sure there's no garbage at the end of blockContents.
				table.insert(out, "repeat ")

				!!(TRIM_POS_AFTER_BLOCK)
				local scopeEndBlockI1, scopeEndBlockI2, scopeEndBlockContents = templateToLua(out, path, template, pos, tcsLevel+1, blockI1)

				if not scopeEndBlockContents:find!("^ *until" ..PATTERN_IDENT_END) then
					fileError(
						path, template, scopeEndBlockI1,
						"Expected 'until' for 'repeat' loop starting at line %d.",
						getLineNumber(template, blockI1)
					)
				end

				table.insert(out, scopeEndBlockContents)
				table.insert(out, " ")
				pos = scopeEndBlockI2 + 1

			-- End block + elseif.
			elseif
				blockContents:find!("^ *end"   ..PATTERN_IDENT_END) or
				blockContents:find!("^ *until" ..PATTERN_IDENT_END) or
				blockContents:find!("^ *else"  ..PATTERN_IDENT_END) or
				blockContents:find!("^ *elseif"..PATTERN_IDENT_END)
			then
				-- @Polish: Make sure there's no garbage at the end of blockContents.
				if tcsLevel == 1 then
					fileError(path, template, blockI1, "Unexpected templateified '%s'.", blockContents:match"%a+")
				end
				!!(TRIM_POS_AFTER_BLOCK)
				local blockI2 = pos - 1
				return blockI1, blockI2, blockContents

			-- URL short-form.
			elseif blockContents:find"^ */" or blockContents:find"^ *%a+:/" then
				table.insert(out, F("echo__(url__%q)", trim(blockContents)))
				-- @Incomplete: Fix line numbers if blockContents has newlines (which is probably rare).
				!!(TRIM_POS_AFTER_BLOCK)

			-- Value expression.
			elseif insertLuaForEchoingIfExpression(out, blockContents) then
				if blockContents:find"^%s*function%s*%(" then -- We do allow echoing functions, but this specifically is probably an error made by the user.
					fileError(path, template, blockI1, "Invalid value expression.")
				end
				!!(TRIM_POS_AFTER_BLOCK)

			-- Any other Lua code.
			else
				table.insert(out, blockContents)
				table.insert(out, " ")
				!!(TRIM_POS_AFTER_BLOCK)
			end

			----------------------------------------------------------------

			table.insert(out, "do end ") -- Statement divider.

			if autoLock then
				table.insert(out, "lock__()")
			end
		end

		if pos <= #template then
			local plainSegment = template:sub(pos)
			table.insert(out, "echoRaw__'") -- :TemplateOutputQuotes
			table.insert(out, (plainSegment:gsub("[\\'\n]", "\\%0")))
			table.insert(out, "'")
		end

		if tcsLevel > 1 then
			fileError(path, template, tcsPos, "Templateified control structure doesn't have an end.")
		end

		return #template+1, #template, "", false -- These return values should never actually be used if everything is working correctly.
	end

	local function _parseAndRunTemplate(page, path, template, useCache, enableHtmlEncoding)
		local luaCode = useCache and templateMetaprogramCache[path] or nil

		if not luaCode then
			local luaBuffer = {}
			templateToLua(luaBuffer, path, template, 1, 1, 1)

			luaCode = table.concat(luaBuffer)
			if useCache then  templateMetaprogramCache[path] = luaCode  end

			if outputMetaprograms then
				local metaPath = "temp/meta/" .. path:gsub("/", "__") .. ".lua"
				timestampPrintVerbose("Writing: %s", metaPath)

				createDirectory("temp/meta")

				local file     = assert(io.open(metaPath, "wb"))
				file:write(luaCode)
				file:close()
			end

			!if PRINT_METAPROGRAMS then
				-- if path:find"test" then
					print("-- LUA "..path.." --")
					print(luaCode)
					print("-- /LUA --")
				-- end
			!end
		end

		local chunk, err = loadstring(luaCode, "@"..path)
		if not chunk then  errorLine(err)  end

		setfenv(chunk, scriptEnvironment)

		local ctx                            = pushContext("template")
		ctx.page                             = page
		ctx._scriptEnvironmentGlobals.page   = getProtectionWrapper(page, "page")
		ctx._scriptEnvironmentGlobals.params = page.params.v
		ctx._scriptEnvironmentGlobals.P      = page.params.v
		ctx.out                              = {}
		ctx.enableHtmlEncoding               = enableHtmlEncoding

		local ok, errObj = xpcall(chunk, xpcallErrorHandler)

		popContext("template")

		if not ok then  error(errObj)  end

		local templateResult = (table.concat(ctx.out)
			:gsub("[ \t]+\n", "\n"  ) -- :Beautify spaces at the end of lines.
			:gsub("\n\n\n+",  "\n\n") -- :Beautify empty lines.  @Robustness: Not sure this is actually good. Might mess up <pre> tag contents.
		)

		return templateResult
	end

	-- stringResult = parseAndRunTemplate( page, path, template, fileType=fromPage, useCache )
	function _G.parseAndRunTemplate(page, path, template, fileType, useCache)
		if template == "" then  return ""  end

		fileType = (fileType or fileTypes[page._extension])

		!local PRINT_RESULT = DEV and 1==0
		local result

		if fileType == "markdown" then
			result = _parseAndRunTemplate(page, path, template, useCache, true)
			result = markdownToHtml(result)
			result = trimNewlines(result).."\n" -- :Beautify
			!if PRINT_RESULT then  __LUA` print"-- HTML --" print(result) print"-- /HTML --" `  end

		elseif fileType == "html" then
			result = _parseAndRunTemplate(page, path, template, useCache, true)
			result = trimNewlines(result).."\n" -- :Beautify
			!if PRINT_RESULT then  __LUA` print"-- HTML --" print(result) print"-- /HTML --" `  end

		else
			result = _parseAndRunTemplate(page, path, template, useCache, false)
			result = trimNewlines(result).."\n" -- :Beautify
			!if PRINT_RESULT then  __LUA` print"-- result --" print(result) print"-- /result --" `  end
		end

		return result
	end

end



local _error = error

-- error( message [, level=1 ] )
function _G.error(err, level)
	level = (level or 1) + 1
	if isErrorObject(err) then  _error(err, level)  end

	err = tostring(err)

	local info = debug.getinfo(level, "Sl")
	if info then
		local sourceName = info.source:find"^@" and info.source:sub(2) or info.short_src
		err              = sourceName .. (info.currentline > 0 and ":"..info.currentline or "") .. ": " .. err
	end

	local errObj = makeError(err, level)
	_error(errObj, level)
end

-- errorf( [ level=1, ] formatString, ... )
function _G.errorf(levelOrS, ...)
	if type(levelOrS) == "number" then
		error(F(...), levelOrS+1)
	else
		error(F(levelOrS, ...), 2)
	end
end

-- fileError( path, contents, position,   formatString, ... )
-- fileError( path, nil,      lineNumber, formatString, ... )
function _G.fileError(path, contents, pos, s, ...)
	local ln = contents and getLineNumber(contents, pos) or pos
	if type(s) ~= "string" then
		s = F("%s:%d: %s", path, ln, tostring(s))
	else
		s = F("%s:%d: "..s, path, ln, ...)
	end
	errorLine(s)
end

-- errorLine( message )
-- errorLine( formatString, ... )
function _G.errorLine(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end
	_error(makeError(s, 0))
end



function _G.getLineNumber(s, pos)
	return 1 + countSubStrings(s, 1, pos-1, "\n", true)
end



-- writeOutputFile( category, pathRelative, url, dataString, modificationTime=now, sourcePath )
function _G.writeOutputFile(category, pathRel, url, data, modTime, sourcePath)
	local pathOutputRel = rewriteOutputPath(pathRel)
	if writtenOutputFiles[pathOutputRel] then
		errorf("Duplicate output file '%s'.", pathOutputRel)
	end
	assert(not writtenOutputUrls[url])

	local filename = getFilename(pathRel)
	local extLower = getExtension(filename):lower()

	if fileProcessors[extLower] then
		pushContext("config")
		data = fileProcessors[extLower](data)
		popContext("config")

		if type(data) ~= "string" then
			errorf("File processor for '%s' files did not return a string.", extLower)
		end
	end

	local path = DIR_OUTPUT.."/"..pathOutputRel
	timestampPrintVerbose("Writing: %s", path)

	createDirectory(getDirectory(path))

	local file = assert(io.open(path, "wb"))
	file:write(data)
	file:close()

	if modTime then
		local ok, err = lfs.touch(path, modTime)
		if not ok then
			timestampPrintError("Could not update modification time for '%s'. (%s)", path, err)
		end
	end

	table.insert(writtenOutputEntries, {path=sourcePath, pathOut=pathOutputRel, url=url})
	table.insert(writtenOutputFiles,   pathOutputRel)
	table.insert(writtenOutputUrls,    url)
	writtenOutputFiles[pathOutputRel] = true
	writtenOutputUrls[url]            = true

	assert(OUTPUT_CATEGORY_SET[category], category)
	_G.outputFileCount         = outputFileCount            + 1
	outputFileCounts[category] = outputFileCounts[category] + 1

	_G.outputFileByteCount = outputFileByteCount + #data
end

-- preserveExistingOutputFile( category, pathRelative, url, sourcePath )
function _G.preserveExistingOutputFile(category, pathRel, url, sourcePath)
	local pathOutputRel = rewriteOutputPath(pathRel)
	if writtenOutputFiles[pathOutputRel] then
		errorf("Duplicate output file '%s'.", pathOutputRel)
	end
	assert(not writtenOutputUrls[url])

	local path = DIR_OUTPUT.."/"..pathOutputRel
	timestampPrintVerbose("Preserving: %s", path)

	local dataLen, err = lfs.attributes(path, "size")
	if not dataLen then
		timestampPrintError("Could not retrieve size of file '%s'. (%s)", path, err)
		dataLen = 0
	end

	table.insert(writtenOutputEntries, {path=sourcePath, pathOut=pathOutputRel, url=url})
	table.insert(writtenOutputFiles,   pathOutputRel)
	table.insert(writtenOutputUrls,    url)
	writtenOutputFiles[pathOutputRel] = true
	writtenOutputUrls[url]            = true

	assert(OUTPUT_CATEGORY_SET[category], category)
	_G.outputFileCount          = outputFileCount            + 1
	outputFileCounts[category]  = outputFileCounts[category] + 1
	_G.outputFilePreservedCount = outputFilePreservedCount   + 1

	_G.outputFileByteCount = outputFileByteCount + dataLen
end



function _G.createDirectory(path)
	if path:find"^/" or path:find"^%a:" then
		errorf(2, "[internal] Absolute paths are disabled. (%s)", path)
	end
	if path:find"//" then
		errorf(2, "Path looks invalid: '%s'", path)
	end

	local pathConstructed = ""

	for folder in path:gmatch"[^/]+" do
		pathConstructed = (pathConstructed == "" and folder or pathConstructed.."/"..folder)
		if not (isDirectory(pathConstructed) or lfs.mkdir(pathConstructed)) then
			errorf("Could not create directory '%s'.", pathConstructed)
		end
	end
end

function _G.isDirectoryEmpty(dirPath)
	for filename in lfs.dir(dirPath) do
		if filename ~= "." and filename ~= ".." then  return false  end
	end
	return true
end

function _G.removeEmptyDirectories(dirPath)
	for filename in lfs.dir(dirPath) do
		local path = dirPath.."/"..filename

		if filename ~= "." and filename ~= ".." and isDirectory(path) then
			removeEmptyDirectories(path)
			if isDirectoryEmpty(path) then
				timestampPrintVerbose("Removing empty folder: %s", path)
				assert(lfs.rmdir(path))
			end
		end

	end
end



--
-- Note: Print functions log, but log functions do not print.
--

-- log( string )
-- log( formatString, ... )
function _G.log(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if not logFile then
		table.insert(toLog, s)
		return
	end

	for i, s in ipairs(toLog) do
		logFile:write(s, "\n")
		toLog[i] = nil
	end

	logFile:write(s, "\n")
end

do
	local values = {}

	_G.printNoLog = print
	function _G.printfNoLog(s, ...)
		printNoLog(F(s, ...))
	end

	function _G.print(...)
		printNoLog(...)

		local argCount = select("#", ...)
		for i = 1, argCount do
			values[i] = tostring(select(i, ...))
		end

		log(table.concat(values, "\t", 1, argCount))
	end
	function _G.printOnce(...)
		local argCount = select("#", ...)
		for i = 1, argCount do
			values[i] = tostring(select(i, ...))
		end

		local s = table.concat(values, "\t", 1, argCount)

		if oncePrints[s] then  return  end
		oncePrints[s] = true

		printNoLog(...)
		log(s)
	end
end

function _G.printf(s, ...)
	print(F(s, ...))
end
function _G.printfOnce(s, ...)
	printOnce(F(s, ...))
end

-- timestampLog( string )
-- timestampLog( formatString, ... )
function _G.timestampLog(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end
	log("[%s] %s", os.date"%H:%M:%S", s)
end

-- timestampPrint( string )
-- timestampPrint( formatString, ... )
-- timestampPrintOnce( string )
-- timestampPrintOnce( formatString, ... )
function _G.timestampPrint(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	printf("[%s] %s", os.date"%H:%M:%S", s)
end
function _G.timestampPrintOnce(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if oncePrints[s] then  return  end
	oncePrints[s] = true

	printf("[%s] %s", os.date"%H:%M:%S", s)
end

-- timestampPrintVerbose( string )
-- timestampPrintVerbose( formatString, ... )
function _G.timestampPrintVerbose(...)
	if verbosePrint then
		timestampPrint(...)
	else
		timestampLog(...)
	end
end

-- timestampPrintError( string )
-- timestampPrintError( formatString, ... )
function _G.timestampPrintError(s, ...)
	if select("#", ...) > 0 then
		s = F("[%s] ERROR: "..s, os.date"%H:%M:%S", ...)
	else
		s = F("[%s] ERROR: %s",  os.date"%H:%M:%S", s)
	end
	io.stderr:write(s, "\n")
	log(s)
end

-- timestampPrintWarning( string )
-- timestampPrintWarning( formatString, ... )
-- timestampPrintWarningOnce( string )
-- timestampPrintWarningOnce( formatString, ... )
function _G.timestampPrintWarning(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	_G.warningCount = warningCount + 1
	s               = F("[%s] WARNING(%d): %s", os.date"%H:%M:%S", warningCount, s)

	io.stderr:write(s, "\n")
	log(s)
end
function _G.timestampPrintWarningOnce(s, ...)
	if select("#", ...) > 0 then  s = F(s, ...)  end

	if oncePrints[s] then  return  end
	oncePrints[s] = true

	_G.warningCount = warningCount + 1
	s               = F("[%s] WARNING(%d): %s", os.date"%H:%M:%S", warningCount, s)

	io.stderr:write(s, "\n")
	log(s)
end

-- printObject( value1, ... )
-- Note: Does not write to log.
do
	local stdoutWrite = io.write

	local function toStringBetter(v)
		local s = tostring(v)
		return s:find"^table: "
		       and s:gsub("^table: ", ""):gsub("^0x", ""):gsub("^%w+", string.upper)
		       or  s
	end

	local function compareKeys(a, b)
		return compareNatural(toStringBetter(a), toStringBetter(b))
	end

	local function _printObject(v, printedTables, firstLevel)
		local vType = type(v)

		if printedTables[v] then
			stdoutWrite(toStringBetter(v))

		elseif vType == "table" then
			printedTables[v] = true
			stdoutWrite(toStringBetter(v), (firstLevel and "{\n" or "{ "))

			local indices = {}
			for i = 1, #v do  indices[i] = true  end

			for _, k in ipairs(sort(getKeys(v), compareKeys)) do
				if not indices[k] then
					if firstLevel then  stdoutWrite("\t")  end
					stdoutWrite(toStringBetter(k), "=")
					_printObject(v[k], printedTables, false)
					if firstLevel then  stdoutWrite("\n")  end
				end
			end

			for i = 1, #v do
				if firstLevel then  stdoutWrite("\t")  end
				stdoutWrite(i, "=")
				_printObject(v[i], printedTables, false)
				if firstLevel then  stdoutWrite("\n")  end
			end

			stdoutWrite("}")

		elseif vType == "number" then
			stdoutWrite(tostring(v))

		elseif vType == "string" then
			stdoutWrite('"', v:gsub("%z", "\\0"):gsub("\n", "\\n"), '"')

		else
			stdoutWrite(toStringBetter(v))
		end

		if not firstLevel then  stdoutWrite(" ")  end
	end

	function _G.printObject(...)
		for i = 1, select("#", ...) do
			if i > 1 then  stdoutWrite("\t")  end

			_printObject(select(i, ...), {}, true)
		end
		stdoutWrite("\n")
	end
end



function _G.isFile(path)
	return lfs.attributes(path, "mode") == "file"
end

function _G.isDirectory(path)
	return lfs.attributes(path, "mode") == "directory"
end



_G.F = string.format

function _G.formatBytes(n)
	if     n >= !(1024^4/10) then  return F("%.2f TiB", n*!(1/1024^4))
	elseif n >= !(1024^3/10) then  return F("%.2f GiB", n*!(1/1024^3))
	elseif n >= !(1024^2/10) then  return F("%.2f MiB", n*!(1/1024^2))
	elseif n >= !(1024^1/10) then  return F("%.2f KiB", n*!(1/1024^1))
	else                           return F("%d bytes", n            )  end
end

function _G.formatTemplate(s, values)
	s = s:gsub(":([%a_][%w_]*):", function(k)
		if values[k] == nil then
			timestampPrintWarning("[formatTemplate] No value for :%s:.", k)
		else
			return tostring(values[k])
		end
	end)

	return unindent(s)
end



do
	local URI_PERCENT_CODES_TO_NOT_ENCODE = {
		["%2d"]="-",["%2e"]=".",["%7e"]="~",--["???"]="_",
		["%21"]="!",["%23"]="#",["%24"]="$",["%26"]="&",["%27"]="'",["%28"]="(",["%29"]=")",["%2a"]="*",["%2b"]="+",
		["%2c"]=",",["%2f"]="/",["%3a"]=":",["%3b"]=";",["%3d"]="=",["%3f"]="?",["%40"]="@",["%5b"]="[",["%5d"]="]",
	}

	function _G.toUrl(url)
		if type(url) ~= "string" then
			errorf(2, "Bad type of 'url' argument. (Got %s)", type(url))
		end

		url = urlLib.escape(url)
		url = url:gsub("%%[0-9a-f][0-9a-f]", URI_PERCENT_CODES_TO_NOT_ENCODE)

		return url
	end

	-- print(toUrl("http://www.example.com/some-path/File~With (Stuff_√•√§√∂).jpg?key=value&foo=bar#hash")) -- TEST
end

function _G.toUrlAbsolute(url)
	url = url:gsub("^/%f[^/]", site.baseUrl.v)
	return (toUrl(url))
end

function _G.urlize(text)
	text = text
		:lower()
		:gsub("[%p ]+", "-")
		:gsub("^%-+", "")
		:gsub("%-+$", "")

	return text == "" and "-" or text
end

function _G.toPrettyUrl(url)
	return (url
		:gsub("^https?://", "")
		:gsub("^www%.", "")
		:gsub("/+$", "")
	)
end



function _G.generatorMeta(hideVersion)
	return
		hideVersion
		and '<meta name="generator" content="LuaWebGen">'
		or  '<meta name="generator" content="LuaWebGen '..WEBGEN_VERSION..'">'
end



function _G.trim(s)
	s = s :gsub("^%s+", "") :gsub("%s+$", "")
	return s
end

function _G.trimNewlines(s)
	s = s :gsub("^\n+", "") :gsub("\n+$", "")
	return s
end



do
	local function formatValue(t, out, isDeep--[[, errLevel]])
		-- Note: We are not serializing - just pretty-printing!
		if isDeep and type(t) == "string" then
			table.insert(out, '"')
			table.insert(out, t)
			table.insert(out, '"')
			return

		elseif type(t) ~= "table" then
			table.insert(out, tostring(t))
			return
		end

		local obj = protectionedObjects[t]
		if obj then
			local fields = {}

			for k, field in pairs(obj) do
				if not k:find"^_" then
					fields[k] = (field.g or NOOP)(field)
				end
			end

			return (formatValue(fields, out, isDeep--[[, errLevel]]))
		end

		local keys = {}
		for k in pairs(t) do
			table.insert(keys, k)
		end
		sortNatural(keys)

		table.insert(out, "{")
		for i, k in ipairs(keys) do
			if i > 1 then  table.insert(out, ", ")  end
			table.insert(out, tostring(k))
			table.insert(out, "=")
			formatValue(t[k], out, true--[[, errLevel]])
		end
		table.insert(out, "}")
	end

	function _G.tostringForTemplates(v)
		local out = {}
		formatValue(v, out, false--[[, 3]])
		return (table.concat(out))
	end
end



-- array = sortNatural( array [, attribute ] )
do
	local function pad(numStr)
		return F("%03d%s", #numStr, numStr)
	end
	function _G.compareNatural(a, b)
		return (tostringForTemplates(a):gsub("%d+", pad) < tostringForTemplates(b):gsub("%d+", pad))
	end

	function _G.sortNatural(t, k)
		if k then
			table.sort(t, function(a, b)
				return compareNatural(a[k], b[k])
			end)
		else
			table.sort(t, compareNatural)
		end
		return t
	end
end



-- dataFolderReader = newDataFolderReader( path [, isTop=false ] )
function _G.newDataFolderReader(path, checkDirExistance)
	local dataFolderReader = {}

	setmetatable(dataFolderReader, {
		__index = function(dataFolderReader, k)
			if checkDirExistance then
				checkDirExistance = false

				if not isDirectory(path) then
					errorf(2, "No data directory.")
				end
			end

			local dataObj

			if type(k) ~= "string" then
				return nil

			elseif k == "." or k == ".." then
				errorf(2, "Bad data key '%s'.", k)

			elseif isFile(F("%s/%s.lua", path, k)) then
				local filePath   = F("%s/%s.lua", path, k)
				local chunk, err = loadfile(filePath)
				if not chunk then  errorf(2, "Error loading Lua data file '%s': %s", filePath, err)  end

				setfenv(chunk, scriptEnvironment)

				pushContext("none")
				dataObj = chunk()
				popContext("none")

				if dataObj == nil then
					errorf(2, "Lua data file returned nothing. (%s)", filePath)
				end

			elseif isFile(F("%s/%s.toml", path, k)) then
				local filePath = F("%s/%s.toml", path, k)
				local contents = assert(getFileContentsText(filePath))
				dataObj        = assert(tomlLib.parse(contents))

			elseif isFile(F("%s/%s.xml", path, k)) then
				local filePath = F("%s/%s.xml", path, k)
				local contents = assert(getFileContentsText(filePath))
				dataObj        = assert(xmlLib.parse(contents, false))

			elseif isDirectory(F("%s/%s", path, k)) then
				dataObj = newDataFolderReader(F("%s/%s", path, k))

			else
				timestampPrintWarningOnce("Bad data path '%s/%s'.", path, k)
				return nil
			end

			assert(dataObj ~= nil)
			rawset(dataFolderReader, k, dataObj)
			return dataObj
		end,
	})

	dataReaderPaths[dataFolderReader] = path
	return dataFolderReader
end

function _G.isDataFolderReader(t)
	return dataReaderPaths[t] ~= nil
end

function _G.preloadData(dataFolderReader)
	if dataIsPreloaded[dataFolderReader] then  return dataFolderReader  end

	for filename in lfs.dir(dataReaderPaths[dataFolderReader]) do
		if not (filename == "." or filename == "..") then
			local path     = dataReaderPaths[dataFolderReader] .. "/" .. filename
			local basename = getBasename(filename)

			if
				not rawget(dataFolderReader, basename)
				and indexOf(DATA_FILE_EXTENSIONS, getExtension(filename))
				and (
					-- Not sure these ignore* checks belong here. Seems like a mistake. 2021-04-27
					(isFile(path)      --[[and not (ignoreFiles  [1] and isStringMatchingAnyPattern(filename, ignoreFiles  ))]]) or
					(isDirectory(path) --[[and not (ignoreFolders[1] and isStringMatchingAnyPattern(filename, ignoreFolders))]])
				)
			then
				local _ = dataFolderReader[basename]
			end
		end
	end

	dataIsPreloaded[dataFolderReader] = true
	return dataFolderReader
end



function _G.getProtectionWrapper(obj, objName)
	assertArg(1, obj,     "table")
	assertArg(2, objName, "string")

	local wrapper = protectionWrappers[obj]
	if wrapper then  return wrapper  end

	wrapper = setmetatable({}, {
		__index = function(wrapper, k)
			local field = obj[k]

			if field == nil or k:find"^_" then
				errorf(2, "Tried to get non-existent %s field '%s'.", objName, tostring(k))
			elseif not field.g then
				errorf(2, "[internal] No getter for %s.%s", objName, k)
			end

			return field:g()
		end,

		__newindex = function(wrapper, k, vNew)
			local field = obj[k]

			if field == nil or k:find"^_" then
				errorf(2, "'%s' is not a valid %s field.", tostring(k), objName)
			elseif not field.s or obj._readonly then
				errorf(2, "Cannot update read-only field %s.%s", objName, k)
			end

			local vOld = field.v

			if type(vNew) ~= type(vOld) then
				errorf(
					2, "Expected %s for %s.%s, but got %s. (%s)",
					type(vOld), objName, k, type(vNew), tostring(vNew)
				)
			end

			field:s(vNew)
		end,
	})

	protectionWrappers[obj]      = wrapper
	protectionedObjects[wrapper] = obj

	return wrapper
end



function _G.toNormalPath(osPath)
	local path = osPath:gsub("\\", "/")
	return path
end

function _G.toWindowsPath(path)
	local winPath = path:gsub("/", "\\")
	return winPath
end



function _G.getDirectory(genericPath)
	return (genericPath:gsub("/?[^/]+$", ""))
end

function _G.getFilename(genericPath)
	return genericPath:match"[^/]+$"
end

function _G.getExtension(filename)
	return filename:match"%.([^.]+)$" or ""
end

function _G.getBasename(filename)
	local ext = getExtension(filename)
	if ext == "" then  return filename  end

	return filename:sub(1, #filename-#ext-1)
end



-- generateFromTemplate( page, template, modificationTime=now )
function _G.generateFromTemplate(page, template, modTime)
	assert(type(page)     == "table")
	assert(type(template) == "string")

	if page._isGenerated then
		errorf(2, "Page has already generated. (%s)", page._path)
	end
	if page._isGenerating or pagesGenerating[page._pathOut] then
		errorf(2, "Recursive page generation detected. (You may want to call lock() in '%s')", page._path)
	end

	page._isGenerating             = true
	pagesGenerating[page._pathOut] = true

	local pathRel  = page._path
	local filename = getFilename(pathRel)
	local ext      = getExtension(filename)
	local extLower = ext:lower()

	local result

	if page.isPage.v then
		local pageContent = parseAndRunTemplate(page, page._pathForError, template, nil, false)

		page._isLocked = true
		page._readonly = true

		if
			(page.isDraft.v and not includeDrafts            ) or -- Is draft?
			(datetimeToTime(page.publishDate:g()) > os.time())    -- Is in future?
		then
			page._isSkipped               = true
			_G.outputFileSkippedPageCount = outputFileSkippedPageCount + 1

			page._isGenerating             = false
			pagesGenerating[page._pathOut] = nil
			return
		end

		if page.layout.v == "" then
			result = pageContent

		else
			page.content.v = pageContent

			local layoutTemplate, layoutPath = getLayoutTemplate(page)
			result                           = parseAndRunTemplate(page, layoutPath, layoutTemplate, "html", true)

			page.content.v = "" -- We don't need this anymore.
		end

	else
		page._isLocked = true
		page._readonly = true

		result = parseAndRunTemplate(page, page._pathForError, template, nil, false)
	end

	writeOutputFile(page._category, page._pathOut, page.url.v, result, modTime, page._path)
	page._isGenerated = true

	page._isGenerating             = false
	pagesGenerating[page._pathOut] = nil
end

function _G.generateFromTemplateFile(page)
	if page._isSkipped then  return  end
	if page._isGenerating and page._isLocked then  return  end -- Allowed recursion.

	local path     = DIR_CONTENT.."/"..page._path
	local template = assert(getFileContentsText(path))
	local modTime  = lfs.attributes(path, "modification")

	if modTime then
		page.date.v = getDatetime(modTime) -- Default value.
	end

	generateFromTemplate(page, template, modTime)
end

function _G.generateRedirection(url, targetUrl, sourcePath)
	assertArg(1, url,       "string")
	assertArg(2, targetUrl, "string")

	if not url:find"^/" then
		errorLine("Redirection URLs must begin with '/'. (%s)", url)
	elseif url:find("#", 1, true) then
		errorLine("Redirection URLs cannot have fragments. (%s)", url)
	end

	if url:find("?", 1, true) or not url:find"/$" then
		if unwrittenRedirects[url] == targetUrl then
			timestampPrintWarning("Duplicate redirect from '%s' to '%s'.", url, targetUrl)
			return
		elseif unwrittenRedirects[url] then
			errorLine("Duplicate redirect from '%s' (to different targets).", url)
		end

		unwrittenRedirects[url] = targetUrl
		return
	end

	-- @Copypaste from above.
	if writtenRedirects[url] == targetUrl then
		timestampPrintWarning("Duplicate redirect from '%s' to '%s'.", url, targetUrl)
		return
	elseif writtenRedirects[url] then
		errorLine("Duplicate redirect from '%s' (to different targets).", url)
	end

	if redirectionLayout ~= "" then
		--
		-- We're doing things a bit backwards here with the page's path
		-- because we don't have a real source page file and thus no source
		-- path. We have to trick the system to do what we want. @Cleanup
		--
		-- Example:
		--   If the URL is          /blog/post1/
		--   then we want to write  /blog/post1/index.html
		--   so the path must be    /blog/post1.html
		--
		-- Note that the output path may still get rewritten before the
		-- writing, but that doesn't concern us because URLs are determined
		-- from unrewritten paths.
		--
		local pathRel = url:gsub("/?$", ".html", 1):gsub("^/", "")
		local page    = newPage(pathRel, true)

		page.layout.v            = redirectionLayout
		page.redirectionTarget.v = targetUrl

		generateFromTemplate(page, "", nil) -- The content for this super special page is always empty - we only want to process the layout!

	else
		local contents = formatTemplate(
			[=[
				<!DOCTYPE html>
				<html>
					<head>
						<meta charset="utf-8">
						<meta name="robots" content="noindex, follow">
						<meta http-equiv="refresh" content="3; url=:urlAbsPercent:">
						<title>:url:</title>
					</head>
					<body>
						<p>Page has moved. If you are not redirected automatically,
						click <a href=":urlAbsPercent:">here</a>.</p>
					</body>
				</html>
			]=], {
				url           = encodeHtmlEntities(              toUrlAbsolute(targetUrl) ),
				urlAbsPercent = encodeHtmlEntities(toUrlAbsolute(toUrlAbsolute(targetUrl))),
			}
		)

		local pathRel = url:gsub("/?$", "/index.html", 1):gsub("^/", "")
		writeOutputFile("page", pathRel, url, contents, nil, sourcePath)
	end

	writtenRedirects[url] = targetUrl
end



-- value = assertArg( [ functionName=auto, ] argumentNumber, value, expectedValueType1, ... [, depth=2 ] )
do
	local function _assertArg(fName, n, v, ...)
		local vType       = type(v)
		local varargCount = select("#", ...)
		local lastArg     = select(varargCount, ...)
		local hasDepthArg = (type(lastArg) == "number")
		local typeCount   = varargCount+(hasDepthArg and -1 or 0)

		for i = 1, typeCount do
			if vType == select(i, ...) then  return v  end
		end

		local depth = 2 + (hasDepthArg and lastArg or 2)

		if not fName then
			fName = debug.traceback("", depth-1):match": in function '(.-)'" or "?"
		end

		local expects = table.concat({...}, " or ", 1, typeCount)

		errorf(depth, "bad argument #%d to '%s' (%s expected, got %s)", n, fName, expects, vType)
	end

	function _G.assertArg(fNameOrArgNum, ...)
		if type(fNameOrArgNum) == "string" then
			return (_assertArg(fNameOrArgNum, ...))
		else
			return (_assertArg(nil, fNameOrArgNum, ...))
		end
	end
end



function _G.indexOf(t, v)
	for i, item in ipairs(t) do
		if item == v then  return i  end
	end
	return nil
end

function _G.itemWith(t, k, v)
	for i, item in ipairs(t) do
		if item[k] == v then  return item, i  end
	end
	return nil
end

function _G.itemWithAll(t, k, v)
	local items = {}
	for _, item in ipairs(t) do
		if item[k] == v then  table.insert(items, item)  end
	end
	return items
end



do
	local ENTITIES = {
		["&"] = "&amp;",
		["<"] = "&lt;",
		[">"] = "&gt;",
		['"'] = "&quot;",
		["'"] = "&#39;",
	}

	function _G.encodeHtmlEntities(s)
		return (s:gsub("[&<>\"']", ENTITIES))
	end
end



function _G.markdownToHtml(md)
	return markdownLib(md)
end



function _G.pack(...)
	return {n=select("#", ...), ...}
end



-- template, path = getLayoutTemplate( page )
function _G.getLayoutTemplate(page)
	local path = F("%s/%s.html", DIR_LAYOUTS, page.layout.v)

	local template = layoutTemplates[path]
	if template then  return template, path  end

	local template, err = getFileContentsText(path)
	if not template then
		errorf("%s: Could not load layout '%s'. (%s)", page._path, page.layout.v, err)
	end

	layoutTemplates[path] = template
	return template, path
end



-- parts = splitString( string, separatorPattern [, startIndex=1, plain=false ] )
function _G.splitString(s, sep, i, plain)
	i = i or 1
	local parts = {}

	while true do
		local i1, i2 = s:find(sep, i, plain)
		if not i1 then  break  end

		table.insert(parts, s:sub(i, i1-1))
		i = i2+1
	end

	table.insert(parts, s:sub(i))
	return parts
end



function _G.datetimeToTime(datetime)
	assertArg(1, datetime, "string")

	local date = dateLib(datetime)
	local time = (date-dateLib.epoch()):spanseconds()

	return time
end

-- datetime = getDatetime( [ time=now ] )
function _G.getDatetime(time)
	assertArg(1, time, "number","nil")

	local date     = dateLib(time or os.time()):tolocal()
	local datetime = date:fmt"${iso}%z" :gsub("..$", ":%0") :gsub("%+00:00$", "Z")

	return datetime
end



function _G.unindent(s)
	local indent = s:match"^\t+"
	if indent then
		s = s
			:gsub("\n"..indent, "\n")
			:sub(#indent+1)
			:gsub("\t+$", "")
	end

	return s
end



function _G.pushContext(ctxName)
	local ctx = {_name=ctxName, _scriptEnvironmentGlobals={}}
	table.insert(contextStack, ctx)
	return ctx
end

function _G.popContext(ctxName)
	assertContext(ctxName)
	table.remove(contextStack)
end

-- assertContext( contextName  [, functionContext, errorLevel=2 ] )
-- assertContext( contextNames [, functionContext, errorLevel=2 ] )
function _G.assertContext(ctxName, funcContext, errLevel)
	local ctx = contextStack[#contextStack]

	if type(ctxName) == "table" then
		if not (ctx and isAny(ctx._name, unpack(ctxName))) then
			errLevel = (errLevel or 2) + 1
			if funcContext then
				errorf(errLevel, "[%s] Context is wrong. (Expected '%s', but is '%s')", funcContext, table.concat(ctxName, "' or '"), (ctx and ctx._name or "none"))
			else
				errorf(errLevel,      "Context is wrong. (Expected '%s', but is '%s')",              table.concat(ctxName, "' or '"), (ctx and ctx._name or "none"))
			end
		end
	else
		if not (ctx and ctx._name == ctxName) then
			errLevel = (errLevel or 2) + 1
			if funcContext then
				errorf(errLevel, "[%s] Context is wrong. (Expected '%s', but is '%s')", funcContext, ctxName, (ctx and ctx._name or "none"))
			else
				errorf(errLevel,      "Context is wrong. (Expected '%s', but is '%s')",              ctxName, (ctx and ctx._name or "none"))
			end
		end
	end
end

-- context = getContext( [ requiredContextName=any  ] )
-- context = getContext( [ requiredContextNames=any ] )
function _G.getContext(ctxName)
	if ctxName then  assertContext(ctxName)  end
	return contextStack[#contextStack] or error("There is no context.", 2)
end



-- thumbnailInfo = createThumbnail( imagePathRelative, thumbWidth [, thumbHeight, errorLevel=1 )
do
	local imageCreatorMethods = {
		["png"]  = "pngStr",
		["jpg"]  = "jpegStr",
		["jpeg"] = "jpegStr",
		["gif"]  = "gifStr",
	}

	function _G.createThumbnail(pathImageRel, thumbW, thumbH, errLevel)
		thumbW   = thumbW or 0
		thumbH   = thumbH or 0
		errLevel = (errLevel or 1)+1

		local gd = pcall(require, "gd") and require"gd" or nil

		if not gd then
			error("Failed loading Lua-GD.", errLevel)
		elseif thumbW == 0 and thumbH == 0 then
			error("Thumbnail images must have at least a width or a height.", errLevel)
		end

		local id = F("%s:%dx%d", pathImageRel, thumbW, thumbH)
		if thumbnailInfos[id] then
			return thumbnailInfos[id]
		end

		local filename  = getFilename(pathImageRel)
		local basename  = getBasename(filename)
		local ext       = getExtension(filename)
		local extLower  = ext:lower()
		local folder    = pathImageRel:sub(1, #pathImageRel-#filename) -- Ending in "/".
		local pathImage = DIR_CONTENT.."/"..pathImageRel

		local image, err = loadImage(pathImageRel)
		if not image then
			error(err, errLevel)
		end

		local imageW, imageH = image:sizeXY()
		assert(imageW > 0)
		assert(imageH > 0)
		local aspectRatio = imageW/imageH

		if thumbW == 0 then
			thumbW = round(thumbH*aspectRatio)
		elseif thumbH == 0 then
			thumbH = round(thumbW/aspectRatio)
		end
		thumbW = math.max(thumbW, 1)
		thumbH = math.max(thumbH, 1)

		local pathThumbRel = F("%s%s.%dx%d.%s", folder, basename, thumbW, thumbH, "jpg")--ext)

		local thumbInfo = {
			path   = pathThumbRel,
			width  = thumbW,
			height = thumbH,
		}

		local pathThumbOutputRel = rewriteOutputPath(pathThumbRel)

		local modTimeImage = lfs.attributes(pathImage, "modification")
		local modTimeThumb = lfs.attributes(DIR_OUTPUT.."/"..pathThumbOutputRel, "modification")

		if modTimeImage and modTimeImage == modTimeThumb and not ignoreModificationTimes then
			-- Note: This will bypass any file processor for JPG files. Not sure if OK. 2018-06-30 @Consistency
			preserveExistingOutputFile("raw", pathThumbRel, "/"..pathThumbRel, pathImageRel)

		else
			local scale = math.min(imageW/thumbW, imageH/thumbH)

			local thumb = gd.createTrueColor(thumbW, thumbH)
			thumb:copyResampled(
				image,
				0, -- dstX
				0, -- dstY
				round((imageW-thumbW*scale)/2), -- srcX
				round((imageH-thumbH*scale)/2), -- srcY
				thumbW, -- dstW
				thumbH, -- dstH
				round(thumbW*scale), -- srcW
				round(thumbH*scale)  -- srcH
			)

			local imageCreatorMethod = "jpegStr"--assert(imageCreatorMethods[extLower], extLower)
			local contents = thumb[imageCreatorMethod](thumb, 75)
			writeOutputFile("raw", pathThumbRel, "/"..pathThumbRel, contents, modTimeImage, pathImageRel)
		end

		thumbnailInfos[id] = thumbInfo
		return thumbInfo
	end

end



function _G.round(n)
	return math.floor(n+.5)
end



-- builder = newStringBuilder( )
do
	local mt = {
		__call = function(b, ...)
			local argCount = select("#", ...)
			if argCount == 0 then  return table.concat(b)  end

			local s = (argCount == 1) and tostring(...) or F(...)
			table.insert(b, s)
		end,
	}

	function _G.newStringBuilder()
		return setmetatable({}, mt)
	end
end



do
	local function removeIndexFilename(pathRel)
		local sitePath = pathToSitePath(pathRel) :gsub("/index%.%w+$", "/")
		return sitePathToPath(sitePath)
	end

	function _G.newPage(pathRel, isRedirection)
		assertArg(1, pathRel,       "string")
		assertArg(2, isRedirection, "boolean")

		local filename = getFilename(pathRel)
		local ext      = getExtension(filename)
		local extLower = ext:lower()

		if not fileTypes[extLower] then
			errorf("Invalid template extension '%s'. (You may want to specify config.types[\"%s\"])", extLower, extLower)
		end

		local isPage  = isAny(fileTypes[extLower], "markdown","html")
		local isIndex = isPage  and getBasename(filename) == "index" and not isRedirection
		local isHome  = isIndex and pathRel == filename

		local category = isPage and "page" or "template"

		local permalinkRel = (
			not isPage and pathRel
			or isHome  and ""
			or isIndex and pathRel:sub(1, -#filename-1)
			or pathRel:sub(1, -#ext-2) .. "/"
		)

		local pathRelOut = (not isPage and permalinkRel or permalinkRel.."index.html")

		local isSpecial = (
			not isPage
			or isRedirection
			or attributeWithAny(
				htaErrors,
				"/"..permalinkRel,
				"/"..pathRelOut,
				"/"..rewriteOutputPath(pathRelOut),
				"/"..removeIndexFilename(rewriteOutputPath(pathRelOut))
			) ~= nil
		)

		local page; page = {
			_readonly = false,

			_category     = category,
			_isGenerating = false,
			_isGenerated  = false,
			_isSkipped    = false,
			_isLocked     = false, -- @Cleanup: Is this always synced with _readonly? If so, just remove _isLocked.
			_path         = pathRel,
			_pathOut      = pathRelOut,
			_pathForError = F("%s/%s", DIR_CONTENT, pathRel),
			_extension    = extLower,

			isPage = {
				v = isPage,
				g = function(field)  return field.v  end,
			},
			isIndex = {
				v = isIndex,
				g = function(field)  return field.v  end,
			},
			isHome = {
				v = isHome,
				g = function(field)  return field.v  end,
			},

			layout = {
				v = site.defaultLayout.v,
				g = function(field)  return field.v  end,
				s = function(field, layoutName)  field.v = layoutName  end,
			},
			title = {
				v = "",
				g = function(field)  return field.v  end,
				s = function(field, title)  field.v = title  end,
			},
			content = {
				v = "",
				g = function(field)  return field.v  end,
			},

			date = {
				v = getDatetime(0),
				g = function(field)  return field.v  end,
				s = function(field, datetime)  field.v = datetime  end,
			},
			publishDate = {
				v = "",
				g = function(field)  return field.v ~= "" and field.v or page.date.v  end,
				s = function(field, datetime)
					assertContext("template", "publishDate", 3)
					assertArg(1, datetime, "string")
					field.v = datetime
				end,
			},
			isDraft = {
				v = false,
				g = function(field)  return field.v  end,
				s = function(field, state)  field.v = state  end,
			},
			isSpecial = {
				v = isSpecial,
				g = function(field)  return field.v  end,
				s = function(field, state)  field.v = state  end,
			},

			aliases = {
				v = {},
				g = function(field)  return page._readonly and {unpack(field.v)} or field.v  end,
				s = function(field, aliases)  field.v = aliases  end,
			},

			url = {
				v = "/" .. (noTrailingSlash and permalinkRel:gsub("/$", "") or permalinkRel),
				g = function(field)  return field.v  end,
			},
			permalink = {
				v = site.baseUrl.v .. (noTrailingSlash and permalinkRel:gsub("/$", "") or permalinkRel),
				g = function(field)  return field.v  end,
			},
			rssLink = { -- @Incomplete @Doc
				v = "",
				g = function(field)  return field.v  end,
			},
			redirectionTarget = {
				v = "",
				g = function(field)  return field.v  end,
			},

			params = {
				v = {},
				g = function(field)  return field.v  end,
			},
		}

		!if DEV and 1==0 then
			printf("%-30s  %-1s  %s", pathRel, (not isPage and "" or isHome and "H" or isIndex and "I" or "P"), page.permalink.v)
		!end

		return page
	end
end



function _G.pathToSitePath(pathRel)
	if pathRel:find"^/" then
		errorf(2, "Path is not valid: %s", pathRel)
	end
	return "/"..pathRel
end

function _G.sitePathToPath(sitePath)
	if not sitePath:find"^/" then
		errorf(2, "Path is not a valid site path - they must start with '/': %s", sitePath)
	end
	return (sitePath:gsub("^/", ""))
end



-- Return any data as a Lua code string.
-- luaString = serializeLua( value )
do
	local SIMPLE_TYPES = {["boolean"]=true,["nil"]=true,["number"]=true}
	local KEYWORDS = {
		["and"]=true,["break"]=true,["do"]=true,["else"]=true,["elseif"]=true,
		["end"]=true,["false"]=true,["for"]=true,["function"]=true,["if"]=true,
		["in"]=true,["local"]=true,["nil"]=true,["not"]=true,["or"]=true,["repeat"]=true,
		["return"]=true,["then"]=true,["true"]=true,["until"]=true,["while"]=true,
	}

	local function _serializeLua(out, data)
		local dataType = type(data)

		if dataType == "table" then
			local first   = true
			local i       = 0
			local indices = {}

			local insert = table.insert
			insert(out, " { ")

			while true do
				i = i+1

				if data[i] == nil then
					i = i+1
					if data[i] == nil then  break  end

					if not first then  insert(out, ",")  end
					insert(out, "nil")
					first = false
				end

				if not first then  insert(out, ",")  end
				first = false

				_serializeLua(out, data[i])
				indices[i] = true
			end

			for k, v in pairs(data) do
				if not indices[k] then
					if not first then  insert(out, ",")  end
					first = false

					if not KEYWORDS[k] and type(k) == "string" and k:find"^[a-zA-Z_][a-zA-Z0-9_]*$" then
						insert(out, k)
					else
						insert(out, "[")
						_serializeLua(out, k)
						insert(out, "]")
					end

					insert(out, "=")
					_serializeLua(out, v)
				end
			end

			insert(out, " } ")

		elseif dataType == "string" then
			table.insert(out, F("%q", data))

		elseif SIMPLE_TYPES[dataType] then
			table.insert(out, tostring(data))

		else
			errorf("Cannot serialize value type '%s'. (%s)", dataType, tostring(data))
		end

		return out
	end

	function _G.serializeLua(data)
		return (table.concat(_serializeLua({}, data)))
	end

end



function _G.getKeys(t)
	local keys = {}
	for k in pairs(t) do  table.insert(keys, k)  end
	return keys
end



function _G.urlExists(url)
	-- @Robustness: A URL may not exist yet, but will soon. Should we only allow calling this in config.validate (and maybe config.after)?
	if not url:find"^/" then
		errorf(2, "Local URLs must begin with '/'. (%s)", url)
	end
	return writtenOutputUrls[url] == true
end



-- bool = isAny( valueToCompare, value1, ... )
function _G.isAny(v, ...)
	for i = 1, select("#", ...) do
		if v == select(i, ...) then  return true  end
	end
	return false
end



function _G.rewriteOutputPath(pathRel)
	local sitePath = pathToSitePath(pathRel)

	for _, pat in ipairs(rewriteExcludes) do
		if sitePath:find(pat) then  return pathRel  end
	end

	if type(outputPathFormat) == "function" then
		local sitePathNew = outputPathFormat(sitePath)

		if type(sitePathNew) ~= "string" then
			errorf("config.rewriteOutputPath() did not return a string. (%s)", sitePath)
		elseif sitePathNew == "" then
			errorf("config.rewriteOutputPath() returned an empty string. (%s)", sitePath)
		end

		return (sitePathToPath(sitePathNew))

	else
		return (sitePathToPath(F(outputPathFormat, sitePath)))
	end
end



-- removeItem( array, value1, ... )
-- @Incomplete: Change into this: anythingGotRemoved = removeItem( array, value1, ... )
function _G.removeItem(t, ...)
	for i = 1, select("#", ...) do
		local iToRemove = indexOf(t, select(i, ...))

		if iToRemove then  table.remove(t, iToRemove)  end
	end
end



-- Same as string.gsub(), but "%" has no meaning in the substitution.
function _G.gsubPlainSub(s, pat, repl)
	return s:gsub(pat, (repl:gsub("%%", "%%%%")))
end



-- string = htaccessRewriteEscapeTestString( string )
function _G.htaccessRewriteEscapeTestString(s)
	s = s:gsub('[$%%\\"]', "\\%0")

	return s
end

-- string = htaccessRewriteEscapeCondPattern( string [, isWhole=false ] )
function _G.htaccessRewriteEscapeCondPattern(s, isWhole)
	s = s:gsub('[$%%\\".+*?^()[%]]', "\\%0")

	if isWhole then  s = s:gsub("^[!=<>]", "\\%0")  end

	return s
end

-- string = htaccessRewriteEscapeRuleSubstitution( string [, isWhole=false ] )
function _G.htaccessRewriteEscapeRuleSubstitution(s, isWhole)
	if isWhole and s == "-" then  return "\\-"  end

	return (s:gsub('[$%%\\"]', "\\%0"))
end



-- Compute the difference in seconds between local time and UTC. (Normal time.)
-- http://lua-users.org/wiki/TimeZone
function _G.getTimezone()
	local now = os.time()
	return os.difftime(now, os.time(os.date("!*t", now)))
end

-- Return a timezone string in ISO 8601:2000 standard form (+hhmm or -hhmm).
function _G.getTimezoneOffsetString(tz)
	local h, m = math.modf(tz/3600)
	return F("%+.4d", 100*h+60*m)
end

-- Return the timezone offset in seconds, as it was on the given time. (DST obeyed.)
-- timezoneOffset = getTimezoneOffset( [ time=now ] )
function _G.getTimezoneOffset(time)
	time = time or os.time()
	local dateUtc   = os.date("!*t", time)
	local dateLocal = os.date("*t",  time)
	dateLocal.isdst = false -- This is the trick.
	return os.difftime(os.time(dateLocal), os.time(dateUtc))
end



function _G.isArgs(...)
	return select("#", ...) > 0
end



do
	local errMt = {
		__tostring = function(errObj)
			return
				errObj.stack[1]
				and F(
					"ERROR: %s\nstack traceback:\n\t%s\n",
					errObj.message, table.concat(errObj.stack, "\n\t")
				)
				or F("ERROR: %s\n", errObj.message)
		end,
	}

	function _G.xpcallErrorHandler(err)
		return isErrorObject(err) and err or makeError(tostring(err), 2)
	end

	function _G.makeError(message, level)
		assertArg(1, message, "string")
		assertArg(2, level,   "number","nil")

		level       = (level == 0) and 0 or (level or 1)
		local stack = {}

		if level > 0 then
			while level < 1/0 do
				level = level + 1

				local info = debug.getinfo(level, "nSl")
				if not info then  break  end

				local isFile     = info.source:find"^@" ~= nil
				local sourceName = cleanupPath(isFile and info.source:sub(2) or info.short_src)

				if isFile then
					sourceName = cleanupPath(sourceName)
				end

				local b = newStringBuilder()
				b("%s:", sourceName)

				if info.currentline > 0 then
					b("%d:", info.currentline)
				end

				if info.name then
					b(" in '%s'", info.name)
				elseif info.what == "main" then
					b(" in main chunk")
				elseif info.what == "C" or info.what == "tail" then
					b(" ?")
				else
					b(" in <%s:%d>", getFilename(sourceName), info.linedefined)
				end

				table.insert(stack, b())
			end

			while stack[#stack] == "[C]: ?" do
				stack[#stack] = nil
			end
		end

		message = message:gsub("^.-:%d+: ", cleanupPath)

		local errObj = setmetatable({message=message, stack=stack}, errMt)
		return errObj
	end

	function _G.makeErrorf(level, s, ...)
		if type(level) == "number" then
			return (makeError(F(s, ...), level+1))
		else
			return (makeError(F(level, s, ...), 2))
		end
	end

	function _G.isErrorObject(v)
		return type(v) == "table" and getmetatable(v) == errMt
	end
end



function _G.cleanupPath(someKindOfPath)
	local path = toNormalPath(someKindOfPath)

	repeat
		local count
		path, count = path:gsub("/[^/]+/%.%./", "/", 1) -- Not completely fool proof! We may need to properly parse the path, I think. @Robustness
	until count == 0

	return path
end



function _G.ipairsr(t)
	assertArg(1, t, "table")
	return iprev, t, #t+1
end

function _G.iprev(t, i)
	i = i-1
	local v = t[i]
	if v ~= nil then  return i, v  end
end



function _G.pairsSorted(t)
	local keys = sortNatural(getKeys(t))
	local i    = 0

	return function()
		i = i+1
		local k = keys[i]
		if k ~= nil then  return k, t[k]  end
	end
end



function _G.attributeWith(t, v)
	for k, item in pairs(t) do
		if item == v then  return k  end
	end
	return nil
end

function _G.attributeWithAny(t, ...)
	for k, item in pairs(t) do
		if isAny(item, ...) then  return k  end
	end
	return nil
end



function _G.sort(t, ...)
	table.sort(t, ...)
	return t
end



do
	local initted = false
	local gd, imageLoaders

	local function init()
		if initted then  return  end

		initted = true
		gd      = pcall(require, "gd") and require"gd" or nil

		if not gd then
			error("Failed loading Lua-GD.")
		end

		imageLoaders = {
			["png"]  = gd.createFromPng,
			["jpg"]  = gd.createFromJpeg,
			["jpeg"] = gd.createFromJpeg,
			["gif"]  = gd.createFromGif,
		}
	end

	function _G.loadImage(pathImageRel)
		init()

		local filename  = getFilename(pathImageRel)
		local extLower  = getExtension(filename):lower()
		local pathImage = DIR_CONTENT.."/"..pathImageRel

		if not isFile(pathImage) then
			return nil, F("File does not exist: %s", pathImage)
		end

		local imageLoader = imageLoaders[extLower]
		if not imageLoader then
			return nil, F("Unknown image file format '%'.", extLower)
		end

		local image = imageLoader(pathImage)
		if not image then
			return nil, F("Could not load image '%s'. Maybe the image is corrupted?", pathImage)
		end

		return image
	end
end

function _G.getImageDimensions(pathImageRel)
	local image, err = loadImage(pathImageRel)
	if not image then  return nil, err  end

	return image:sizeXY()
end



do
	local initted = false
	local socket

	local function init()
		if initted then  return  end
		initted = true
		socket  = pcall(require, "socket.core") and require"socket.core" or nil
	end

	function _G.getTimeBetter()
		init()
		return socket and socket.gettime() or os.time()
	end

	function _G.sleep(duration)
		init()
		if socket then
			socket.sleep(duration)
		else
			local endTime = getTimeBetter() + duration
			repeat until getTimeBetter() >= endTime -- Should we do some better operation to waste time?
		end
	end
end



function _G.getCwd()
	return (toNormalPath(lfs.currentdir()))
end



-- count = countStrings( string, needle [, plain=false ] )
function _G.countStrings(s, needle, plain)
	local count = 0
	local pos   = 1

	while true do
		local _, i2 = s:find(needle, pos, plain)
		if not i2 then  return count  end

		count = count + 1
		pos   = i2    + 1
	end
end

-- count = countSubStrings( string, startPosition, endPosition, needle [, plain=false ] )
function _G.countSubStrings(s, pos, posEnd, needle, plain)
	local count = 0

	while true do
		local _, i2 = s:find(needle, pos, plain)
		if not i2 or i2 > posEnd then  return count  end

		count = count + 1
		pos   = i2    + 1
	end
end



--[[============================================================
--=
--=  XML (and some HTML) handling module
--=  Provides a similar API as Penlight.
--=
--=  We don't follow the XML spec too closely, but this really
--=  should be enough for our use case!
--=
--=  Notes:
--=  - Only UTF-8 is supported.
--=  - <? ... ?> sequences are ignored.
--=  - <! ... > sequences (including comments) are ignored, except for CDATA sections which become text nodes.
--=
--=-------------------------------------------------------------
--=
--=  LuaWebGen - static website generator in Lua!
--=  - Written by Marcus 'ReFreezed' Thunstr√∂m
--=  - MIT License (See LICENSE.txt)
--=
--==============================================================

	xml.clone
	xml.compare
	xml.encodeRequiredEntities, xml.encodeMoreEntities
	xml.isElement, xml.isText
	xml.makeElementConstructors
	xml.newElement, xml.element
	xml.parseXml, xml.parseHtml
	xml.removeWhitespaceNodes
	xml.substitute
	xml.toHtml, xml.contentsToHtml
	xml.toXml, xml.toPrettyXml, xml.contentsToXml
	xml.walk

	Element.addChild
	Element.eachChild, Element.eachChildElement, Element.eachMatchingChildElement
	Element.filter
	Element.getAttributes, Element.setAttribute, Element.updateAttributes
	Element.getChildByName, Element.findAllElementsByName
	Element.getFirstElement
	Element.getText, Element.getTextOfDirectChildren
	Element.mapElements
	Element.match, Element.substitute
	Element.removeWhitespaceNodes
	Element.stackChild, Element.stackElement, Element.stackText, Element.stackUp, Element.stackReset
	Element.toHtml, Element.contentsToHtml
	Element.toXml, Element.toPrettyXml, Element.contentsToXml

--============================================================]]

!(
local XML_STANDARD_PREFACE  = '<?xml version="1.0" encoding="UTF-8"?>'
local HTML_STANDARD_PREFACE = '<!DOCTYPE html>'

local PATTERN_NAME_CHAR = "[-._:%w\128-\255]"

local _IS_TEXT = `(type(?) == "string")`
local function IS_TEXT(expr)
	return (_IS_TEXT:gsub("%?", expr))
end
)



local ENTITY_NAME_TO_UTF8             = require"entities".nameToUtf8
local EXTRA_ENTITIES_TO_ALWAYS_ENCODE = require"entities".extraEntitiesToAlwaysEncode

local HTML_EMPTY_ELEMENTS = {
	area    = true,
	base    = true,
	br      = true,
	col     = true,
	embed   = true,
	hr      = true,
	img     = true,
	input   = true,
	isindex = true,
	keygen  = true,
	link    = true,
	meta    = true,
	param   = true,
	source  = true,
	track   = true,
	wbr     = true,
}

local HTML_XML_ENTRY_TAGS = {
	math = true, -- MathML
	svg  = true, -- SVG
}

local HTML_END_TAG_PATTERNS_FOR_TAGS_WITH_UNENCODED_CONTENTS = {
	script = "</[Ss][Cc][Rr][Ii][Pp][Tt]%s*>",
	style  = "</[Ss][Tt][Yy][Ll][Ee]%s*>",
}



local xml = {}

local Element   = {}
Element.__index = Element



local documentCache = {}

-- node = cacheIfXmlString( xmlString )
-- node = cacheIfXmlString( node )
-- Returns nil and a message on error.
local function cacheIfXmlString(xmlStrOrEl)
	if type(xmlStrOrEl) == "string" then
		local xmlStr = xmlStrOrEl
		local el     = documentCache[xmlStr]
		if el then  return el  end

		local err ; el, err = xml.parse(xmlStr) -- @Incomplete: Use parseXml() instead!
		-- local err ; el, err = xml.parseXml(xmlStr)
		if not el then  return nil, err  end

		documentCache[xmlStr] = el
		return el

	elseif xml.isElement(xmlStrOrEl) then
		return xmlStrOrEl

	else
		return nil, "Template is not a document."
	end
end



local function insertNode(el, node)
	if node == "" then
		-- void
	elseif !!(IS_TEXT`node`) and !!(IS_TEXT`el[#el]`) then
		el[#el] = el[#el] .. node -- @Speed
	else
		table.insert(el, node)
	end
end

-- position = decodeEntities( string, position, stringForError, 0,                      pathForError, isHtml, element )
-- string   = decodeEntities( string, 1,        stringForError, positionOffsetForError, pathForError, isHtml, nil     )
local function decodeEntities(s, pos, sForError, posOffsetForError, pathForError, isHtml, el)
	!(
	local _INSERT = `
		if el then  insertNode(el, ?)  else  table.insert(replacements, ?)  end
	`
	local function INSERT(expr)
		return (_INSERT:gsub("%?", expr))
	end
	)

	local replacements = (not el) and {} or nil

	while true do
		local i = s:find("&", pos, true)
		if not i then  break  end
		pos = i + 1

		if isHtml and not s:find("^#?%w+;", pos) then
			fileWarning(pathForError, sForError, posOffsetForError+pos-1, "Encountered unencoded '&'. Treating it as text.")

			@@INSERT("&")

			if not el then
				-- @Cleanup: Don't use the 'replacements' thingy so we don't have to do this hack.
				s                 = s:sub(1, pos-1) .. "amp;" .. s:sub(pos)
				posOffsetForError = posOffsetForError - !(#"amp;")
			end

		else
			-- Entity, hex number.
			if s:find("^#[Xx]", pos) then
				pos = pos + !(#"#x")

				local i1, i2, cpStr = s:find(!("^(0*%x+)"), pos)
				if not i1 then
					fileError(pathForError, sForError, posOffsetForError+pos, "Invalid format for hexadecimal entity number.")
				end
				pos = i2 + 1

				local cp = tonumber(cpStr, 16)
				@@INSERT(utf8.codepointToString(cp))

			-- Entity, decimal number.
			elseif s:find("^#", pos) then
				pos = pos + !(#"#")

				local i1, i2, cpStr = s:find(!("^(0*%d+)"), pos)
				if not i1 then
					fileError(pathForError, sForError, posOffsetForError+pos, "Invalid format for decimal entity number.")
				end
				pos = i2 + 1

				local cp = tonumber(cpStr, 10)
				@@INSERT(utf8.codepointToString(cp))

			-- Entity, name.
			else
				local i1, i2, entityName = s:find(!("^("..PATTERN_NAME_CHAR.."+)"), pos)
				if not i1 then
					fileError(pathForError, sForError, posOffsetForError+pos, "Invalid format for entity name.")
				elseif not ENTITY_NAME_TO_UTF8[entityName] then
					fileError(pathForError, sForError, posOffsetForError+pos, "Unknown entity name '%s'.", entityName)
				end
				pos = i2 + 1

				@@INSERT(ENTITY_NAME_TO_UTF8[entityName])
			end

			if not s:find("^;", pos) then
				fileError(pathForError, sForError, posOffsetForError+pos, "Expected ';' at the end of the entity.")
			end
			pos = pos + !(#";")
		end

		if el then  break  end
	end

	if el then
		return pos

	else
		if replacements[1] then
			local i = 0
			s = s:gsub("&.-;", function()
				i = i + 1
				return replacements[i]
			end)
		end

		return s
	end
end

!(
local EAT_SPACE = `do local _, i2 = s:find("^%s*", pos) ; pos = i2 + 1 end`
)

-- position = parseAttributes( string, position, pathForError, isHtml, attributes )
local function parseAttributes(s, pos, pathForError, isHtml, attrs)
	while pos <= #s do
		local i1, i2, attrName = s:find(!("^("..PATTERN_NAME_CHAR.."+)"), pos)
		if not i1 then
			break
		end
		if isHtml then
			attrName = attrName:lower()
		end
		pos = i2 + 1

		!!(EAT_SPACE)

		-- No value.
		if isHtml and not s:find("^=", pos) then
			attrs[attrName] = ""

		else
			if not s:find("^=", pos) then
				fileError(pathForError, s, pos, "Expected '=' after attribute name '%s'.", attrName)
			end
			pos = pos + !(#"=")

			!!(EAT_SPACE)

			local posQuote = pos
			local quote    = s:sub(pos, pos)

			-- Quoted value.
			if quote == '"' or quote == "'" then
				pos                = pos + 1
				local attrValuePos = pos

				pos = s:find(quote, pos, true)
				if not pos then
					fileError(pathForError, s, posQuote, "Missing end quote (%s) for value of attribute '%s'.", quote, attrName)
				end

				local attrValue = s:sub(attrValuePos, pos-1)
				attrs[attrName] = decodeEntities(attrValue, 1, s, attrValuePos-1, pathForError, isHtml, nil)
				pos             = pos + !(#'"')

			-- Unquoted value.
			elseif isHtml then
				local attrValuePos = pos

				local i1, i2 = s:find("^[^%s/>]+", pos)
				if not i1 then
					fileError(pathForError, s, attrValuePos, "Expected value for attribute '%s'.", attrName)
				end
				pos = i2 + 1

				local attrValue = s:sub(attrValuePos, pos-1)
				attrs[attrName] = decodeEntities(attrValue, 1, s, attrValuePos-1, pathForError, isHtml, nil)

			else
				fileError(pathForError, s, pos, "Expected a quote for the value of attribute '%s'.", attrName)
			end
		end

		!!(EAT_SPACE)
	end

	return pos
end

-- position = parseElementContents( string, position, pathForError, element, isHtml, isTop )
local function parseElementContents(s, pos, pathForError, el, isHtml, isTop)
	while pos <= #s do
		local posStart = pos

		-- Processing instruction.
		if s:find("^<%?", pos) then
			if isHtml then
				fileError(pathForError, s, pos, "Encountered XML code in the HTML document.")
			end

			pos = pos + !(#"<?")

			while true do
				local posQuoteStart = s:find("[\"']", pos)
				local posPiEnd      = s:find("?>",    pos, true)

				if not posPiEnd then
					fileError(pathForError, s, posStart, "Missing end of processing instruction.")
				end

				if posQuoteStart and posQuoteStart < posPiEnd then
					local quote    = s:sub(posQuoteStart, posQuoteStart)
					pos            = posQuoteStart + !(#'"')

					local posQuoteEnd = s:find(quote, pos, true)
					if not posQuoteEnd then
						fileError(pathForError, s, posQuoteStart, "Missing end quote (%s) for string.", quote)
					end
					pos = posQuoteEnd + !(#'"')

				else
					pos = posPiEnd + !(#"?>")
					break
				end
			end

		-- Comment.
		elseif s:find("^<!%-%-", pos) then
			pos = pos + !(#"<!--")

			local i1, i2 = s:find("-->", pos, true)
			if not i1 then
				fileError(pathForError, s, posStart, "Missing end of comment.")
			end

			pos = i2 + 1

		-- CDATA section.
		elseif s:find("^<!%[CDATA%[", pos) then
			if isHtml then
				-- Should we allow this in all HTML? It should at least be allowed in SVG elements for example.
				fileError(pathForError, s, pos, "Encountered XML code in the HTML document.")
			end

			pos = pos + !(#"<![CDATA[")

			local i1, i2 = s:find("]]>", pos, true)
			if not i1 then
				fileError(pathForError, s, posStart, "Missing end of CDATA section.")
			end

			local text = s:sub(pos, i1-1)
			pos        = i2 + 1

			insertNode(el, text)

		-- Declaration.
		elseif s:find("^<!", pos) then
			-- Originally @Copypaste from the '<?' matching above.
			local balance = 1
			pos           = pos + !(#"<!")

			while true do
				local posQuoteStart = s:find("[\"']", pos)
				local posTagStart   = s:find("<",     pos, true)
				local posTagEnd     = s:find(">",     pos, true)

				if not posTagEnd then
					fileError(pathForError, s, posStart, "Missing end of declaration.")
				end

				if posQuoteStart and posQuoteStart < math.min(posTagEnd, (posTagStart or 1/0)) then
					local quote    = s:sub(posQuoteStart, posQuoteStart)
					pos            = posQuoteStart + !(#'"')

					local posQuoteEnd = s:find(quote, pos, true)
					if not posQuoteEnd then
						fileError(pathForError, s, posQuoteStart, "Missing end quote (%s) for string.", quote)
					end
					pos = posQuoteEnd + !(#'"')

				elseif posTagStart and posTagStart < posTagEnd then
					pos     = posTagStart + !(#"<")
					balance = balance     + 1

				else
					pos     = posTagEnd + !(#">")
					balance = balance   - 1
					if balance == 0 then  break  end
				end
			end

		-- End tag.
		elseif s:find("^</", pos) then
			return pos

		-- Start tag, or empty tag.
		elseif s:find("^<", pos) then
			local isHtml = isHtml -- Local variable because we may want to switch to XML parsing mode for the tag.

			pos = pos + !(#"<")

			local i1, i2, tagName = s:find(!("^("..PATTERN_NAME_CHAR.."+)"), pos)
			if not i1 then
				fileError(pathForError, s, pos, "Expected tag name after '<'.")
			end
			if isHtml and HTML_XML_ENTRY_TAGS[tagName] then
				isHtml = false
			end
			if isHtml then
				tagName = tagName:lower()
			end
			pos = i2 + 1

			local childEl = xml.newElement(tagName)

			if s:find("^%s", pos) then
				!!(EAT_SPACE)
				pos = parseAttributes(s, pos, pathForError, isHtml, childEl.attr)
			end

			local isEmpty = false

			if s:find("^/", pos) then
				pos     = pos + !(#"/")
				isEmpty = true

			elseif isHtml and HTML_EMPTY_ELEMENTS[tagName] then
				isEmpty = true
			end

			if not s:find("^>", pos) then
				fileError(pathForError, s, pos, "Expected '>'.")
			end
			pos = pos + !(#">")

			insertNode(el, childEl)

			if not isEmpty then
				if isHtml and HTML_END_TAG_PATTERNS_FOR_TAGS_WITH_UNENCODED_CONTENTS[tagName] then
					local specialTextNodeStart = pos
					local pat                  = HTML_END_TAG_PATTERNS_FOR_TAGS_WITH_UNENCODED_CONTENTS[tagName]

					local i1, i2 = s:find(pat, pos)
					if not i1 then
						fileError(pathForError, s, pos, "Missing end tag for <%s>.", tagName)
					end
					pos = i1

					childEl[1] = s:sub(specialTextNodeStart, pos-1) -- No entity decoding in this case!

				else
					pos = parseElementContents(s, pos, pathForError, childEl, isHtml, false)
				end

				if not s:find("^</", pos) then
					fileError(pathForError, s, pos, "Expected end tag for <%s> at line %d.", tagName, getLineNumber(s, posStart))
				end
				pos = pos + !(#"</")

				local i1, i2, tagNameEnd = s:find(!("^("..PATTERN_NAME_CHAR.."+)"), pos)
				if not i1 then
					fileError(pathForError, s, pos, "Expected tag name after '<'.")
				end
				if isHtml then
					tagNameEnd = tagNameEnd:lower()
				end
				if tagNameEnd ~= tagName then
					fileError(pathForError, s, pos, "Expected </%s>.", tagName)
				end
				pos = i2 + 1

				!!(EAT_SPACE)

				if not s:find("^>", pos) then
					fileError(pathForError, s, pos, "Expected '>'.")
				end
				pos = pos + !(#">")
			end

		--
		-- Only text-like nodes from here on!
		--

		-- Entity.
		elseif s:find("^&", pos) then
			if isTop then  fileError(pathForError, s, posOffsetForError+pos, "Invalid data outside root element.")  end

			pos = decodeEntities(s, pos, s, 0, pathForError, isHtml, el)

		-- Text.
		else
			local i1, i2, text = s:find("^([^<&]+)", pos)

			if isTop and text:find"%S" then
				fileError(pathForError, s, pos, "Invalid data outside root element.")
			end
			pos = i2 + 1

			if not isTop then  insertNode(el, text)  end
		end
	end

	return pos
end



--==============================================================
--= Element methods
--==============================================================



-- Element:addChild( childNode )
function Element.addChild(el, childNode)
	table.insert(el, childNode)
end
Element.add_direct_child = Element.addChild -- :PenlightCompatibility



-- element = Element:getFirstElement( )
function Element.getFirstElement(el)
	for _, childNode in ipairs(el) do
		if xml.isElement(childNode) then  return childNode  end
	end
	return nil
end
Element.first_childtag = Element.getFirstElement -- :PenlightCompatibility

-- element = Element:getChildByName( tag )
function Element.getChildByName(el, tagName)
	for _, childNode in ipairs(el) do
		if xml.isElement(childNode) and childNode.tag == tagName then
			return childNode
		end
	end
end
Element.child_with_name = Element.getChildByName -- :PenlightCompatibility

do
	local function _findAllElementsByName(el, tagName, elements, recurse)
		for _, childNode in ipairs(el) do
			if xml.isElement(childNode) then
				if childNode.tag == tagName then
					table.insert(elements, childNode)
				end
				if recurse then
					_findAllElementsByName(childNode, tagName, elements, true)
				end
			end
		end
	end

	-- elements = Element:findAllElementsByName( tag [, doNotRecurse=false ] )
	function Element.findAllElementsByName(el, tagName, doNotRecurse)
		local elements = {}
		_findAllElementsByName(el, tagName, elements, (not doNotRecurse))
		return elements
	end
	Element.get_elements_with_name = Element.findAllElementsByName -- :PenlightCompatibility
end



-- for childNode in Element:eachChild( )
function Element.eachChild(el)
	local i = 0
	return function()
		i = i + 1
		return el[i]
	end
end
Element.children = Element.eachChild -- :PenlightCompatibility

-- for childElement in Element:eachChildElement( )
function Element.eachChildElement(el)
	local i = 0

	return function()
		while true do
			i               = i + 1
			local childNode = el[i]

			if not childNode               then  return            end
			if xml.isElement(childNode) then  return childNode  end
		end
	end
end
Element.childtags = Element.eachChildElement -- :PenlightCompatibility

-- for childElement in Element:eachMatchingChildElement( tag )
function Element.eachMatchingChildElement(el, tagName)
	local i = 0

	return function()
		while true do
			i               = i + 1
			local childNode = el[i]

			if not childNode then  return  end

			if xml.isElement(childNode) and childNode.tag == tagName then
				return childNode
			end
		end
	end
end

-- :PenlightCompatibility
-- for childElement in Element:matching_tags( [ tag=any, xmlns=(self.attr.xmlns or any) ] ) -- This function has no new replacement and is @Undocumented.
function Element.matching_tags(el, tagName, xmlns)
	xmlns   = xmlns or el.attr.xmlns
	local i = 0

	return function()
		while true do
			i               = i + 1
			local childNode = el[i]

			if not childNode then  return  end

			if
				xml.isElement(childNode)
				and (not tagName or childNode.tag        == tagName)
				and (not xmlns   or childNode.attr.xmlns == xmlns)
			then
				return childNode
			end
		end
	end
end



-- attributes = Element:getAttributes( )
function Element.getAttributes(el)
	return el.attr
end
Element.get_attribs = Element.getAttributes -- :PenlightCompatibility

-- Element:setAttribute( attributeName, attributeValue )
-- Element:setAttribute( attributeName, nil ) -- Remove the attribute.
function Element.setAttribute(el, attrName, attrValue)
	el.attr[attrName] = attrValue
end
Element.set_attrib = Element.setAttribute -- :PenlightCompatibility

-- Element:updateAttributes( attributes )
function Element.updateAttributes(el, attrs)
	for attrName, attrValue in pairs(attrs) do
		el.attr[attrName] = attrValue
	end
end
Element.set_attribs = Element.updateAttributes -- :PenlightCompatibility



do
	local function _getText(buffer, el)
		for _, childNode in ipairs(el) do
			if !!(IS_TEXT`childNode`) then
				table.insert(buffer, childNode)
			else
				_getText(buffer, childNode)
			end
		end
	end

	-- text = Element:getText( )
	function Element.getText(el)
		local buffer = {}
		_getText(buffer, el)
		return table.concat(buffer)
	end
end

-- This function is pretty silly - use getText() instead!
-- text = Element:getTextOfDirectChildren( )
function Element.getTextOfDirectChildren(el)
	local buffer = {}
	for _, childNode in ipairs(el) do
		if !!(IS_TEXT`childNode`) then  table.insert(buffer, childNode)  end
	end
	return table.concat(buffer)
end
Element.get_text = Element.getTextOfDirectChildren -- :PenlightCompatibility



do
	local function isEmpty(attr)
		return not (attr and next(attr))
	end

	local function getKvPairIfAlone(t)
		local k, v = next(t)
		if next(t, k) ~= nil then  return nil  end
		return k, v
	end

	local function appendCapture(matches, capture)
		if isEmpty(capture) then  return  end -- No point in capturing empty tables...

		local k = nil

		if capture._ then -- If $_ was set then it is meant as the top-level key for the captured table.
			k         = capture._
			capture._ = nil

			if isEmpty(capture) then  return  end
		end

		-- A table with only one pair {[0]=value} shall be reduced to that value...
		local numKey, v = getKvPairIfAlone(capture)
		if numKey == 0 then  capture = v  end

		if k then
			matches[k] = capture
		else -- ... otherwise, we append the captured table.
			table.insert(matches, capture)
		end
	end

	local function maybeMakeNumber(pat)
		if pat:find"^%d+$" then -- $1 etc. means use this as an array location.
			return tonumber(pat)
		end
		return pat
	end

	local function captureAttribute(matches, pat, value)
		matches[maybeMakeNumber(pat:sub(2))] = value
		return true
	end

	local function _match(node, patEl, matches, keepGoing)
		if node == nil then  node = ""  end

		-- Attribute string matching is straight equality, except if the pattern is a $ capture, which always succeeds.
		if !!(IS_TEXT`node`) then
			if not !!(IS_TEXT`patEl`) then  return false  end

			-- print(node, patEl) -- DEBUG

			if patEl:find"^%$" then
				return captureAttribute(matches, patEl, node)
			else
				return node == patEl
			end
		end

		--
		-- This is an element node.
		-- For a match to succeed, the attributes must match as well.
		--
		local el = node
		-- print(el.tag, patEl.tag) -- DEBUG

		-- A tagname in the pattern ending with "-" is a wildcard and matches like an attribute.
		local tagNamePat = patEl.tag:match"^(.-)%-$"

		if tagNamePat then
			tagNamePat          = maybeMakeNumber(tagNamePat)
			matches[tagNamePat] = el.tag
		end

		local ok = true

		if el.tag == patEl.tag or tagNamePat then
			if isEmpty(patEl.attr) then
				-- void

			elseif isEmpty(el.attr) then
				ok = false

			else
				for attrName, patAttrValue in pairs(patEl.attr) do
					local elAttrValue = el.attr[attrName]

					if not _match(elAttrValue, patAttrValue, matches) then
						ok = false
						break
					end
				end
			end

			-- The pattern may have child nodes. We match partially, so that {P1,P2} shall match {X,P1,X,X,P2,..}.
			if ok and patEl[1] then
				local elChildI  = 1
				local patChildI = 1

				local function advanceElement()
					elChildI = elChildI + 1 -- Next child element of data.
					while el[elChildI] and !!(IS_TEXT`el[elChildI]`) do
						elChildI = elChildI + 1
					end
					return elChildI <= #el
				end

				repeat
					local childNode = patEl[patChildI]

					-- Repeated {{<...>}} patterns shall match one or more elements so e.g. {P+} will match {X,X,P,P,X,P,X,X,X}.
					if xml.isElement(childNode) and childNode.repeated then
						local found = false

						repeat
							local submatches = {}
							ok               = _match(el[elChildI], childNode, submatches, false)

							if ok then
								found = false--true
								appendCapture(matches, submatches)
							end
						until not advanceElement() or (found and not ok)

						patChildI = patChildI + 1

					else
						ok = _match(el[elChildI], childNode, matches, false)

						if ok then  patChildI = patChildI + 1  end
					end
				until not advanceElement() or patChildI > #patEl -- Run out of elements or patterns to match.

				-- If every element in our pattern matched ok, then it's been a successful match.
				if patChildI > #patEl then  return true  end
			end

			if ok then  return true  end

		else
			ok = false
		end

		-- Keep going anyway - look at the children!
		if keepGoing then
			for child in el:eachChildElement() do
				ok = _match(child, patEl, matches, keepGoing)
				if ok then  break  end
			end
		end

		return ok
	end

	-- matches = Element:match( xmlStringPattern )
	-- matches = Element:match( elementPattern )
	-- Returns nil and a message on error.
	-- (See https://lunarmodules.github.io/Penlight/manual/06-data.md.html#XML - look for sections describing templates)
	function Element.match(el, patStrOrEl)
		local patEl, err = cacheIfXmlString(patStrOrEl)
		if not patEl then  return nil, err  end

		xml.walk(patEl, false, function(tagName, currentEl)
			if
				!!(IS_TEXT`currentEl[1]`) and xml.isElement(currentEl[2]) and !!(IS_TEXT`currentEl[3]`)
				and currentEl[1]:find"%s*{{" and currentEl[3]:find"}}%s*"
			then
				table.remove(currentEl, 3)
				table.remove(currentEl, 1)
				currentEl[1].repeated = true
			end
		end)

		local matches = {}
		local ok      = _match(el, patEl, matches, true)

		if not ok then
			return nil, "Matching failed."
		end

		return matches
	end
end



--
-- These stack*() methods are @Undocumented because people should use the much
-- nicer makeElementConstructors() instead!
--

-- self = Element:stackChild( childNode )
function Element.stackChild(el, childNode)
	local targetEl = (el._last and el._last[#el._last] or el)
	targetEl:addChild(childNode)
	return el
end
Element.add_child = Element.stackChild -- :PenlightCompatibility

-- self = Element:stackElement( tag [, attributes ] )
function Element.stackElement(el, tagName, attrs)
	!ARGS "tagName:string ? attrs:table"

	el._last = el._last or {}

	local elToAdd  = xml.newElement(tagName, attrs)
	local targetEl = (el._last[#el._last] or el)

	targetEl:addChild(elToAdd)
	table.insert(el._last, elToAdd)

	return el
end
Element.addtag = Element.stackElement -- :PenlightCompatibility

-- self = Element:stackText( text )
function Element.stackText(el, text)
	local targetEl = (el._last and el._last[#el._last] or el)
	targetEl:addChild(text)
	return el
end
Element.text = Element.stackText -- :PenlightCompatibility

-- self = Element:stackUp( )
function Element.stackUp(el)
	if el._last then  table.remove(el._last)  end
	return el
end
Element.up = Element.stackUp -- :PenlightCompatibility

-- self = Element:stackReset( )
function Element.stackReset(el)
	if el._last then
		for i = #el._last, 1, -1 do
			el._last[i] = nil
		end
	end
	return el
end
Element.reset = Element.stackReset -- :PenlightCompatibility



-- self            = Element:mapElements( callback )
-- replacementNode = callback( childElement ) -- Returning nil removes the element.
function Element.mapElements(el, cb)
	local i = 1

	while el[i] do
		if xml.isElement(el[i]) then
			local replacement = cb(el[i])
			if replacement then
				el[i] = replacement
				i     = i + 1
			else
				table.remove(el, i)
			end
		else
			i = i + 1
		end
	end

	return el
end
Element.maptags = Element.mapElements -- :PenlightCompatibility



do
	local function prepareData(data)
		-- A hack for ensuring that $1 maps to first element of data, etc.
		-- Either this or could change the gsub call just below.
		for i, v in ipairs(data) do
			data[tostring(i)] = v
		end
	end

	-- newElement = Element:substitute( data )
	-- newElement = Element.substitute( xmlString, data )
	-- Returns nil and a message on error.
	function Element.substitute(templateStrOrEl, data)
		if not (type(data) == "table" and next(data)) then
			return nil, "data must be a non-empty table"
		end

		local dataIsData = (type(data[1]) ~= "table")
		if dataIsData then  prepareData(data)  end

		local templateEl, err = cacheIfXmlString(templateStrOrEl)
		if not templateEl then  return nil, err  end

		local function _substitute(item)
			return xml.clone(templateEl, function(s)
				return s:gsub("%$(%w+)", item)
			end)
		end

		if dataIsData then  return _substitute(data)  end

		local list = {}
		for _, item in ipairs(data) do
			prepareData(item)
			table.insert(list, _substitute(item))
		end

		if data.tag then
			list = xml.elem(data.tag, list)
		end

		return list
	end
	xml.substitute = Element.substitute -- :Alias
	Element.subst  = Element.substitute -- :PenlightCompatibility
end



--==============================================================
--= Library functions
--==============================================================



local function shouldEncodeAsCdata(s)
	if s:find("]]>", 1, true) then  return false  end

	local entitiesNeeded = 0
	local pos            = 1

	while pos <= #s do
		local charPos = s:find("[&<>\"']", pos)
		if not charPos then  return false  end

		entitiesNeeded = entitiesNeeded + 1
		if entitiesNeeded >= 4 then  return true  end

		pos = charPos + 1
	end
end

local function nodeToXml(buffer, node)
	if !!(IS_TEXT`node`) then
		if shouldEncodeAsCdata(node) then
			table.insert(buffer, "<![CDATA[")
			table.insert(buffer, node)
			table.insert(buffer, "]]>")
		else
			table.insert(buffer, xml.encodeMoreEntities(node))
		end
		return
	end

	local el = node

	table.insert(buffer, "<")
	table.insert(buffer, el.tag)

	for attrName, attrValue in pairsSorted(el.attr) do
		table.insert(buffer, " ")
		table.insert(buffer, attrName)
		table.insert(buffer, '="')
		table.insert(buffer, xml.encodeMoreEntities(attrValue))
		table.insert(buffer, '"')
	end

	if not el[1] then
		table.insert(buffer, "/>")

	else
		table.insert(buffer, ">")

		for _, childNode in ipairs(el) do
			nodeToXml(buffer, childNode)
		end

		table.insert(buffer, "</")
		table.insert(buffer, el.tag)
		table.insert(buffer, ">")
	end
end

-- xmlString = xml.toXml( node [, prefaceProcessingInstruction=false ] )
-- xmlString = xml.toXml( node, processingInstructionToPreface )
function xml.toXml(node, preface)
	local buffer = {}
	if preface then
		buffer[1] = (type(preface) == "string") and preface or !(XML_STANDARD_PREFACE.."\n")
	end
	nodeToXml(buffer, node)
	return table.concat(buffer, "")
end
Element.toXml = xml.toXml -- :Alias

-- xmlString = xml.contentsToXml( node ) -- @Doc
function xml.contentsToXml(node)
	local buffer = {}

	if !!(IS_TEXT`node`) then
		nodeToXml(buffer, node)
	else
		for _, childNode in ipairs(node) do
			nodeToXml(buffer, childNode)
		end
	end

	return table.concat(buffer, "")
end
Element.contentsToXml = xml.contentsToXml -- :Alias



local function nodeToXmlPretty(buffer, node, initialIndent,indent,attrIndent, indentTags)
	if !!(IS_TEXT`node`) then
		if not node:find"%S" then
			-- void
		elseif shouldEncodeAsCdata(node) then
			table.insert(buffer, "<![CDATA[")
			table.insert(buffer, node)
			table.insert(buffer, "]]>")
		else
			table.insert(buffer, xml.encodeMoreEntities(node))
		end
		return
	end

	local el = node

	if indentTags then  table.insert(buffer, "\n")  end
	table.insert(buffer, initialIndent)
	table.insert(buffer, "<")
	table.insert(buffer, el.tag)

	for attrName, attrValue in pairsSorted(el.attr) do
		if attrIndent then
			table.insert(buffer, "\n")
			table.insert(buffer, initialIndent)
			table.insert(buffer, attrIndent)
		else
			table.insert(buffer, " ")
		end

		table.insert(buffer, attrName)
		table.insert(buffer, '="')
		table.insert(buffer, xml.encodeMoreEntities(attrValue))
		table.insert(buffer, '"')
	end

	if attrIndent and next(el.attr) then
		table.insert(buffer, "\n")
		table.insert(buffer, initialIndent)
	end

	if not el[1] then
		table.insert(buffer, "/>")

	else
		table.insert(buffer, ">")

		local hasChildElements = false
		for _, childNode in ipairs(el) do
			nodeToXmlPretty(buffer, childNode, initialIndent..indent,indent,attrIndent, indentTags)
			hasChildElements = hasChildElements or xml.isElement(childNode)
		end

		if hasChildElements and indentTags then
			table.insert(buffer, "\n")
			table.insert(buffer, initialIndent)
		end

		table.insert(buffer, "</")
		table.insert(buffer, el.tag)
		table.insert(buffer, ">")
	end
end

--
-- This is only for (legacy) pretty-printing of the XML - call xml.toXml() or
-- element:toXml() to create an XML string without any modifications to the data.
--
-- xmlString = xml.toPrettyXml( node [, initialIndentationString="", indentationString=noIndentation, attributeIndentationString=noIndentation, prefaceProcessingInstruction=false ] )
-- xmlString = xml.toPrettyXml( node, initialIndentationString="", indentationString=noIndentation, attributeIndentationString=noIndentation, processingInstructionToPreface )
--
-- Specifying indentationString puts each tag on its own line.
-- Specifying attributeIndentationString puts each attribute on its own line.
--
function xml.toPrettyXml(node, initialIndent,indent,attrIndent, preface)
	local indentTags = (indent ~= nil)

	initialIndent = (initialIndent or "")
	indent        = (indent        or "")

	local buffer = {}
	if preface then
		buffer[1] = (type(preface) == "string") and preface or !(XML_STANDARD_PREFACE)
	end

	nodeToXmlPretty(buffer, node, initialIndent,indent,attrIndent, indentTags)

	return table.concat(buffer)
end
Element.toPrettyXml = xml.toPrettyXml -- :Alias
xml.tostring        = xml.toPrettyXml -- :PenlightCompatibility
Element.__tostring  = xml.toPrettyXml -- :PenlightCompatibility



local function nodeToHtml(buffer, node)
	if !!(IS_TEXT`node`) then
		table.insert(buffer, xml.encodeMoreEntities(node))
		return
	end

	local el = node

	if HTML_XML_ENTRY_TAGS[el.tag] then
		nodeToXml(buffer, el)
		return
	end

	local tagName = el.tag -- (Don't call :lower() because that may make HTML_XML_ENTRY_TAGS[tagName] true and we end up in a weird situation. Only normalize when parsing!)

	table.insert(buffer, "<")
	table.insert(buffer, tagName)

	for attrName, attrValue in pairsSorted(el.attr) do
		table.insert(buffer, " ")
		table.insert(buffer, attrName)

		if attrValue ~= "" then
			table.insert(buffer, '="')
			table.insert(buffer, xml.encodeMoreEntities(attrValue))
			table.insert(buffer, '"')
		end
	end

	table.insert(buffer, ">")

	if not HTML_EMPTY_ELEMENTS[tagName] then
		if el[1] then
			if HTML_END_TAG_PATTERNS_FOR_TAGS_WITH_UNENCODED_CONTENTS[tagName] then
				if el:getFirstElement() then
					errorf("HTML <%s> element has child elements, which is illegal.", tagName)
				end
				for _, childNode in ipairs(el) do
					table.insert(buffer, childNode) -- We trust that there's no </script> or anything in here.
				end
			else
				for _, childNode in ipairs(el) do
					nodeToHtml(buffer, childNode)
				end
			end
		end

		table.insert(buffer, "</")
		table.insert(buffer, tagName)
		table.insert(buffer, ">")

	elseif el[1] then
		errorf("HTML <%s> element should be empty, but it is not.", tagName)
	end
end

-- htmlString = xml.toHtml( node [, prefaceDoctype=false ] )
-- htmlString = xml.toHtml( node, doctypeToPreface )
function xml.toHtml(node, preface)
	local buffer = {}
	if preface then
		buffer[1] = (type(preface) == "string") and preface or !(HTML_STANDARD_PREFACE.."\n")
	end
	nodeToHtml(buffer, node)
	return table.concat(buffer, "")
end
Element.toHtml = xml.toHtml -- :Alias

-- htmlString = xml.contentsToHtml( node ) -- @Doc
function xml.contentsToHtml(node)
	local buffer = {}

	if !!(IS_TEXT`node`) then
		nodeToHtml(buffer, node)
	else
		for _, childNode in ipairs(node) do
			nodeToHtml(buffer, childNode)
		end
	end

	return table.concat(buffer, "")
end
Element.contentsToHtml = xml.contentsToHtml -- :Alias



-- document = xml.parseXml( xmlString [, filePathForError ] )
-- Returns nil and a message on error.
function xml.parseXml(s, pathForError)
	pathForError = pathForError or "<xml>"
	local doc    = nil

	local ok, err = pcall(function()
		if s:find"%z" then -- A valid UTF-16 file should always have NULLs in it.
			fileError(pathForError, s, 1, "Only UTF-8 is supported.")
		end

		local docWrapper = xml.newElement("")
		local pos        = parseElementContents(s, 1, pathForError, docWrapper, false, true)

		if pos <= #s then
			fileError(pathForError, s, pos, "Unexpected end tag.")
		end

		for _, node in ipairs(docWrapper) do
			if not !!(IS_TEXT`node`) then
				if doc then
					fileError(pathForError, s, #s+1, "There are multiple root elements.")
				end
				doc = node
			end
		end

		if not doc then
			fileError(pathForError, s, 0, "There is no document.")
		end
	end)

	if not ok then
		return nil, err
	end

	return doc
end

-- document = xml.parseHtml( xmlString [, filePathForError ] )
-- Returns nil and a message on error.
function xml.parseHtml(s, pathForError)
	pathForError = pathForError or "<html>"
	local doc    = nil

	local ok, err = pcall(function()
		if s:find"%z" then -- A valid UTF-16 file should always have NULL bytes in it.
			fileError(pathForError, s, 1, "Only UTF-8 is supported.")
		end

		local docWrapper = xml.newElement("")
		local pos        = parseElementContents(s, 1, pathForError, docWrapper, true, true)

		if pos <= #s then
			fileError(pathForError, s, pos, "Unexpected end tag.")
		end

		for _, node in ipairs(docWrapper) do
			if not !!(IS_TEXT`node`) then
				if doc then
					fileError(pathForError, s, #s, "There are multiple root elements.")
				end
				doc = node
			end
		end

		if not doc then
			fileError(pathForError, s, 0, "There is no document.")
		end
	end)

	if not ok then
		return nil, err
	end

	return doc
end

-- Use parseXml() instead! :PenlightCompatibility
--
-- document = xml.parse( xmlString,     isFile, useBasic )
-- document = xml.parse( xmlFileHandle, isFile, useBasic )
--
-- 'isFile' and 'useBasic' are ignored.
-- Returns nil and a message on error.
--
function xml.parse(s, isFile, useBasic)
	if type(s) == "userdata" then
		s = s:read"*a"
		if not s then
			return nil, "Could not read file."
		end
	end

	local doc, err = xml.parseXml(s)
	if not doc then  return nil, err  end

	xml.removeWhitespaceNodes(doc)
	return doc
end

-- Use parseXml() or parseHtml() instead! :PenlightCompatibility
--
-- document = xml.basic_parse( string [, preserveAllWhitespace=false, isHtml=false ] )
--
function xml.basic_parse(s, preserveAllWhitespace, isHtml)
	local doc

	if isHtml then
		doc = assert(xml.parseHtml(s))
	else
		doc = assert(xml.parseXml(s))
	end

	if not preserveAllWhitespace then
		xml.removeWhitespaceNodes(doc)
	end

	return doc
end

-- :PenlightCompatibility
-- document = xml.parsehtml( htmlString )
function xml.parsehtml(s)
	return (xml.basic_parse(s, false, true))
end



local function _walk(doc, depthFirst, cb)
	if not depthFirst then
		local action = cb(doc.tag, doc)
		if     not action                 then  -- void
		elseif action == "stop"           then  return "stop"
		elseif action == "ignorechildren" then  return
		end
	end

	for _, childNode in ipairs(doc) do
		if xml.isElement(childNode) then
			if _walk(childNode, depthFirst, cb) == "stop" then  return "stop"  end
		end
	end

	if depthFirst then
		if cb(doc.tag, doc) == "stop" then  return "stop"  end
	end
end

-- xml.walk( document, depthFirst, callback )
-- traversalAction = callback( tag, element )
-- traversalAction = "stop"|"ignorechildren"|nil
-- If depthFirst is true then returning "ignorechildren" does nothing.
function xml.walk(doc, depthFirst, cb)
	!ARGS "doc:table depthFirst:boolean cb:function"
	_walk(doc, depthFirst, cb)
end



-- bool = xml.isElement( value )
function xml.isElement(v)
	return getmetatable(v) == Element
end
xml.is_tag = xml.isElement -- :PenlightCompatibility

-- bool = xml.isText( value )
function xml.isText(v)
	return type(v) == "string"
end



-- element = xml.newElement( tag [, attributes ] )
function xml.newElement(tagName, attrs)
	!ARGS "tagName:string ? attrs:table"

	local el = {
		_last = nil,-- { element1, ... }

		tag  = tagName,
		attr = attrs or {--[[ [attrName1]=attrValue1, ... ]]},

		-- [1] = childNode1, ...
	}
	return setmetatable(el, Element)
end
xml.new = xml.newElement -- :PenlightCompatibility



-- element = xml.element( tag [, childNode ] )
-- element = xml.element( tag, attributesAndChildNodes )
function xml.element(tagName, prototype)
	!ARGS "tagName:string ? prototype:table,string"

	local el = xml.newElement(tagName)

	if not prototype then
		-- void

	elseif !!(IS_TEXT`prototype`) or xml.isElement(prototype) then
		el[1] = prototype

	else
		for k, v in pairsSorted(prototype) do
			if type(k) == "string" then
				el.attr[k] = v
			else
				el[k] = v
			end
		end
	end

	return el
end
xml.elem = xml.element -- :PenlightCompatibility



do
	local function _clone(node, textSubstCallback, parentEl)
		if !!(IS_TEXT`node`) then
			if textSubstCallback then
				node = textSubstCallback(node, "*TEXT", parentEl) or errorf("No value returned from text substitution callback for '*TEXT'.")
			end
			return node
		end

		local el = node

		local elClone = xml.newElement("")
		local tagName = el.tag

		if textSubstCallback then
			tagName = textSubstCallback(tagName, "*TAG", el) or errorf("No value returned from text substitution callback for '*TAG'.")
		end

		elClone.tag = tagName

		for attrName, attrValue in pairs(el.attr) do
			if textSubstCallback then
				attrValue = textSubstCallback(attrValue, attrName, el) or errorf("No value returned from text substitution callback for '%s'.", attrName)
			end
			elClone.attr[attrName] = attrValue
		end

		for i, childNode in ipairs(el) do
			elClone[i] = _clone(childNode, textSubstCallback, el)
		end

		return elClone
	end

	-- clone = xml.clone( node [, textSubstitutionCallback ] )
	-- text  = textSubstitutionCallback( text, kind, parentElement )
	-- kind  = attributeName | "*TEXT" | "*TAG"
	-- parentElement is nil if 'node' is a text node.
	function xml.clone(node, textSubstCallback)
		return (_clone(node, textSubstCallback, nil))
	end
	Element.filter = xml.clone -- :Alias
end



-- nodesLookEqual = xml.compare( value1, value2 )
-- Returns false if any value is not a node.
function xml.compare(v1, v2)
	if !!(IS_TEXT`v1`) and !!(IS_TEXT`v2`) then
		return v1 == v2
	end
	if not (xml.isElement(v1) and xml.isElement(v2)) then
		return false
	end

	if v1.tag ~= v2.tag then  return false  end
	if #v1    ~= #v2    then  return false  end

	for k, v in pairs(v1.attr) do
		if v2.attr[k] ~= v then  return false  end
	end
	for k, v in pairs(v2.attr) do
		if v1.attr[k] ~= v then  return false  end
	end

	for i = 1, #v1 do
		if not xml.compare(v1[i], v2[i]) then
			return false
		end
	end

	return true
end



do
	local constructors = {}

	-- constructor1, ... = xml.makeElementConstructors( tags )
	-- constructor1, ... = xml.makeElementConstructors( "tag,..." )
	-- element = constructor( [ childNode ] )
	-- element = constructor( attributesAndChildNodes )
	function xml.makeElementConstructors(tagNames)
		if type(tagNames) == "string" then
			local tagNamesStr = tagNames
			tagNames          = {}

			for tagName in tagNamesStr:gmatch"[^,]+" do
				tagName = tagName:gsub("^%s+", ""):gsub("%s+$", "")
				if tagName == "" then
					error("A value in the comma-separated list is empty.", 2)
				end

				table.insert(tagNames, tagName)
			end
		end

		for i, tagName in ipairs(tagNames) do
			constructors[i] = function(prototype)
				return xml.element(tagName, prototype)
			end
		end

		return unpack(constructors, 1, #tagNames)
	end
	xml.tags = xml.makeElementConstructors -- :PenlightCompatibility
end



function xml.removeWhitespaceNodes(doc)
	for i, childNode in ipairsr(doc) do
		if xml.isElement(childNode) then
			xml.removeWhitespaceNodes(childNode)
		elseif childNode:match"^%s+$" then
			table.remove(doc, i)
		end
	end
end
Element.removeWhitespaceNodes = xml.removeWhitespaceNodes -- :Alias



local CHAR_TO_ENTITY = {
	["&"] = "&amp;",
	["<"] = "&lt;",
	[">"] = "&gt;",
	['"'] = "&quot;",
	["'"] = "&apos;",
}

-- Encode special characters.
function xml.encodeRequiredEntities(s)
	return (s:gsub("[&<>\"']", CHAR_TO_ENTITY))
end

-- Encode special characters and some additional characters (like non-breaking space).
function xml.encodeMoreEntities(s)
	s = xml.encodeRequiredEntities(s)

	-- Note: We encode HTML entities in XML documents too. It's probably fine, but who knows!
	for _, name in ipairs(EXTRA_ENTITIES_TO_ALWAYS_ENCODE) do
		local c = EXTRA_ENTITIES_TO_ALWAYS_ENCODE[name]
		if s:find(c, 1, true) then
			s = s:gsub(c, "&"..name..";")
		end
	end

	return s
end



--==============================================================

return xml
